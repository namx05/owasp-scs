{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OWASP Smart Contract Security","text":"","tags":[]},{"location":"#our-mission","title":"Our MissionOWASP SCSVSOWASP SCWEOWASP SCSTGOWASP SCS Checklist","text":"\"Define the industry standard for Smart Contract Security.\" <p>The OWASP Smart Contracts Security (SCS) is a comprehensive project aimed at enhancing the security of smart contracts. It provides a structured framework for developers, auditors, and security professionals to follow best practices, detect vulnerabilities, and implement robust security measures in smart contracts, decentralized applications (dApps) and EVM-based blockchain systems.</p>  Download the SCSVS  Access v0.0.1  Download the SCSTG  Visit the Checklist <p></p>","tags":[]},{"location":"#trusted-by","title":"Trusted By","text":"<p>The OWASP SCSVS and SCSTG are trusted by the following platform providers and standardization, governmental and educational institutions. Learn more.</p>","tags":[]},{"location":"#scs-advocates","title":"\ud83e\udd47 SCS Advocates","text":"<p>SCS Advocates are key industry adopters of the OWASP SCSVS and SCSTG who have invested a significant and consistent amount of resources to drive the project forward and ensure its continued success. This includes making consistent high-impact contributions and actively promoting the adoption and usage of the project. Learn more.</p> <p></p>","tags":[]},{"location":"contact/","title":"\ud83d\udcac Connect with Us","text":"<p>You can follow and reach out to the OWASP SCS team in many ways.</p> <ul> <li>Send us your questions and ideas to GitHub Discussions</li> <li>Stay always up-to-date by following us on Twitter.</li> <li>Join our Slack community</li> </ul> <p>If you'd like to contribute, take a look at our Contributions page or reach out to the project leaders or project maintainers mentioned below.</p> <p> </p> <p>Request an invitation to join our Slack channel <code>#owasp-scs</code></p> <p></p>","tags":[]},{"location":"contact/#owasp-scs-project-leaders","title":"OWASP SCS Project Leaders","text":"","tags":[]},{"location":"contact/#shashank","title":"Shashank","text":"<p>@cyberboyIndia </p> <p>Shashank brings over a decade of expertise in uncovering vulnerabilities, reporting them to reputable institutions, conducting pentests, and overseeing responsible disclosure and bug bounty initiatives. His contributions have earned him a place in the Security Hall of Fame for Apple (CVE-2017-7063, CVE-2017-7062, CVE-2017-2458), Twitter, Google, Facebook, Dropbox, and more than 40 other organizations, showcasing his knack for identifying significant security concerns. Apart from Bug Bounties, Shashank has worked as a security analyst for HackerOne and performed 200+ pentests with Cobalt. He was also a security engineer for Web3 Company Avalanche before starting his venture CredShields where he is building an AI-powered cloud-based Smart Contract Security Scanner called SolidityScan.com</p> <p> </p> <p></p>","tags":[]},{"location":"contact/#owasp-scs-project-maintainers","title":"OWASP SCS Project Maintainers","text":"","tags":[]},{"location":"contact/#pratik-lagaskar","title":"Pratik Lagaskar","text":"<p>@warlordsam077</p> <p> </p> <p>Pratik is a Security Researcher at CredShields, focused on postmortems of web3 rekts, TX analysis &amp; OSINT, tokenomics, and research into web3 security. Previously, Pratik has worked in traditional security with expertise in Red Teaming, code reviews (with proficiency in linters, fuzzers, CodeQL, Semgrep, CxQL), DevSecOps, hypervisor and browser security. He also holds various web2 security certifications. Pratik is very active in all types of CTFs, a major contributor to GSoC and OWASP; and has also won multiple hackathons. He has in-depth working experience with Go, Rust and good understanding of Solidity and Move. Currently, he is dabbling with web3sec and expanding his knowledge in EVM internals, various DeFi protocols, altchains (Cosmos, Solana), node reviews, hash-based snargs and Formal Verification (CVL, Coq and Dafny). When he is not working, Pratik spends majority of his free time strengthening audit skills by participating in contests and bug bounties. </p> <p> </p> <p></p>","tags":[]},{"location":"contact/#nehal-pillai","title":"Nehal Pillai","text":"<p>@nehal_10_0</p> <p></p> <p>Nehal is a Security Engineer at FINRA, with a strong foundation in offensive and application security. He previously worked as a Security Researcher at CredShields and holds a Master\u2019s degree in Cybersecurity from the University of Maryland, College Park. At CredShields, he has been a part of the team developing SolidityScan, an AI-powered cloud-based Smart Contract Security Scanner, driving innovation in smart contract security. With a deep passion for ethical hacking and as an OSCP-certified professional, Nehal specializes in uncovering vulnerabilities, conducting penetration tests, and securing digital assets. As a bug bounty hunter, Nehal has secured over 100 prominent companies through platforms like HackerOne, including major players like Apple and Google. He proudly represented India at the BlackHat MEA 2022 CTF World Finals, showcasing his expertise on a global stage.In addition, Nehal has identified over 35 vulnerabilities, which have been assigned CVEs and registered under MITRE and NIST NVD, making significant contributions to the cybersecurity community.</p> <p> </p> <p></p>","tags":[]},{"location":"contributing/","title":"Contributing to the SCS Project","text":"<p>First of all, \u2b50 Give us a Star in GitHub!</p> <p></p> <p></p> <p>The SCS project is an open source effort and we welcome all kinds of contributions and feedback.</p> <p>Help us improve &amp; join our community:</p> <ul> <li>\ud83d\udc1e Report an error (typos, grammar) or fix it on a Pull Request.</li> <li>\ud83d\udcac Give feedback (SCSTG/SCSVS).</li> <li>\ud83d\ude4f Ask questions (SCSTG/SCSVS).</li> </ul> <p>Contribute with content:</p> <ul> <li>\ud83d\udca1 Propose ideas or suggest improvements (SCSTG/SCSVS). If it qualifies we'll promote it to an Issue.</li> <li>\ud83d\udcc4 Create a Pull Request for concrete fixes (e.g. grammar/typos) or content already approved by the core team.</li> </ul> <p>Before you start contributing, please check our pages \"How Can You Contribute?\" and \"Getting Started\". If you have any doubts please contact us.</p>","tags":[]},{"location":"contributing/#what-not-to-do","title":"\ud83d\udeab What not to do","text":"<p>Although we greatly appreciate any and all contributions to the project, there are a few things that you should take into consideration:</p> <ul> <li>No advertisement: The OWASP Smart Contract Security Project cannot be used as a platform for advertisement of commercial tools, companies or individuals. Technical content such as the implementation of certain techniques or tests should be written with free and open-source tools in mind. Commercial tools are typically not accepted, but might be referenced in some specific cases.</li> <li>No unnecessary self-promotion of tools or blog posts: If you have a relation with one of the URLs or tools you are referencing, please state so in the PR so that we can verify that the reference is in line with the rest of the guide.</li> </ul> <p>Please be sure to take a careful look at our Code of Conduct for all the details and ask us in case of doubt.</p> <p></p>","tags":[]},{"location":"contributing/#our-contributors","title":"Our Contributors","text":"<p>All of our contributors are listed in GitHub repos. See OWASP SCS Authors &amp; Co-Authors, SCSTG Contributors and SCSVS Contributors.</p> <p></p>","tags":[]},{"location":"contributing/#owasp-scs-project-featured-contributions","title":"OWASP SCS Project Featured Contributions","text":"<ul> <li>Pratik Lagaskar (Automation in GitHub Actions)</li> </ul>","tags":[]},{"location":"contributing/#owasp-scsvs","title":"OWASP SCSVS","text":"<p>The latest version of the SCSVS v1 including all translations is available here: https://github.com/OWASP/www-project-smart-contract-security-verification-standard/releases/tag/v0.0.1</p> <p>Note: This contributor table is generated based on our GitHub contribution statistics. For more information on these stats, see the GitHub Repository README. We manually update the table, so be patient if you're not listed immediately.</p> Project Lead Lead Author Contributors and Reviewers Shashank Pratik Lagaskar,  Nehal Pillai <p></p> Language Translators &amp; Reviewers","tags":[]},{"location":"contributing/#owasp-scstg","title":"OWASP SCSTG","text":"<p>The latest version of the SCSTG v0.0.1 is available here: https://github.com/OWASP/www-project-smart-contract-security-testing-guide/releases/tag/v0.0.1</p> <p>Note: This contributor table is generated based on our GitHub contribution statistics. For more information on these stats, see the GitHub Repository README. We manually update the table, so be patient if you're not listed immediately.</p> <ul> <li>Reviewers: Reviewers have consistently provided useful feedback through GitHub issues and pull request comments.</li> <li>Top Contributors: Top contributors have consistently contributed quality content and have at least 500 additions logged in the GitHub repository.</li> <li>Contributors: Contributors have contributed quality content and have at least 50 additions logged in the GitHub repository.</li> <li>Mini Contributors: Many other contributors have committed small amounts of content, such as a single word or sentence (less than 50 additions).</li> </ul> Authors Reviewers Top Contributors Contributors Mini Contributors Editors Shashank Pratik Lagaskar Nehal Pillai","tags":[]},{"location":"donate/","title":"Donations","text":"<p>We thank our donators for providing the funds to support us on our project activities.</p> <p>The OWASP Foundation is very grateful for the support by the individuals and organizations listed. However please note, the OWASP Foundation is strictly vendor neutral and does not endorse any of its supporters. Donations do not influence the content of the SCSVS or SCSTG in any way.</p> <p> </p> <p>While both the SCSVS and the SCSTG are created and maintained by the community on a voluntary basis, sometimes a little bit of outside help is required.</p> <p>Monetary Donations: You can donate any amount you like, no matter how small, anyone can help. From 500$ up you may select a Donation Package and be listed as a donator.</p> <p>100% of the funds go to the OWASP Foundation and allow us funding our project activities such as contracting technical editors, graphic designers, software developers, purchasing test devices, creating swag, etc.</p> :white_heart:{ .pump } Donate :material-book-heart: Purchase the SCSTG <p>Effort Based: You can instead support the project by contributing with your work and end up at our acknowledgement section.</p> <p>If you're a company, consider becoming a \"SCS Advocate\" which is the highest status that companies can achieve in the project acknowledging that they've gone above and beyond to support the project.</p> :material-text-box-edit: Contribute :material-medal: Become a SCS Advocate","tags":[]},{"location":"tags/","title":"Tags","text":"","tags":[]},{"location":"talks/","title":"\ud83c\udf99 Talks","text":"Date Event Title Video Slides 18th March 2025 Podcast OWASP Smart Contract Top 10 Podcast  Video  Slides","tags":[]},{"location":"SCSTG/","title":"OWASP SCSTG","text":"<p> GitHub Repo</p> <p> OWASP Project Page</p> <p>The OWASP Smart Contract Security Testing Guide (SCSTG) is a comprehensive manual designed to assist developers, auditors, and security professionals in evaluating the security of smart contracts. It provides detailed methodologies for identifying, verifying, and addressing vulnerabilities in smart contracts across various risk categories. The guide includes examples of common security flaws, methods for detecting these issues, and strategies for mitigating or eliminating the risks. </p> <p>It describes technical processes for verifying the controls listed in the OWASP SCSVS through the weaknesses defined by the OWASP SCWE.</p> <p></p> <p> Download the SCSTG</p> <p></p> <p>Start exploring the SCSTG:</p> <p>  Tests (v1)</p> <p>  Support the project by purchasing the OWASP SCSTG on leanpub.com. All funds raised through sales of this book go directly into the project budget and will be used to for technical editing and designing the book and fund production of future releases.</p> <p></p>","tags":[]},{"location":"SCSTG/0x01-Foreword/","title":"Foreword","text":"<p>Welcome to the OWASP Smart Contract Security Testing Guide. Feel free to explore the existing content, but do note that it may change at any time. </p> <p>This guide is a community-driven effort to provide a comprehensive resource for understanding, testing, and improving the security of smart contracts. Like the blockchain space itself, the content in this guide is dynamic and ever-evolving, reflecting the fast-paced advancements in protocols, best practices, and the discovery of new vulnerabilities.  </p> <p>Smart contracts are at the heart of decentralized ecosystems, but their complexity makes them a prime target for attacks. With every protocol upgrade, L2 innovation, or emerging standard, new challenges arise for developers and security professionals alike. This guide aims to bridge the gap, equipping you with practical techniques and insights to navigate the ever-changing landscape of smart contract security.  </p> <p>If you have feedback, suggestions, or would like to contribute, feel free to create an issue on GitHub or join the discussion on OWASP\u2019s Slack. See the README for details:  </p> <p>https://www.github.com/OWASP/www-project-smart-contract-security-testing-guide/ </p> <p>smart contract (noun): A self-executing contract with the terms of the agreement directly written into lines of code, enabling secure, automated transactions on a blockchain. </p> <p>This isn\u2019t a traditional security guide. It doesn\u2019t just explain vulnerabilities or list best practices. It\u2019s a living document shaped by the community for the community. Security testing in Web3 demands a deep understanding of blockchain fundamentals, cryptographic principles, protocol designs, and attack vectors\u2014many of which are only briefly introduced here.  </p> <p>So, don\u2019t stop at this guide. Read the code, explore the EVM, experiment with testnets, audit real-world projects, and stay curious. As you grow in your journey, consider giving back to the SCSTG. After all, the strength of this guide lies in the collective expertise of its contributors. Or, as they say in the open-source world: \"Do a pull request.\" </p> <p>We hope this guide inspires you to push the boundaries of what\u2019s possible in securing decentralized systems. Welcome aboard!  </p>","tags":[]},{"location":"SCSTG/0x02a-Frontispiece/","title":"Frontispiece","text":"","tags":[]},{"location":"SCSTG/0x02a-Frontispiece/#about-the-owasp-scstg","title":"About the OWASP SCSTG","text":"<p>The OWASP Smart Contract Security Testing Guide (SCSTG), which is part of the OWASP Smart Contract Security (SCS) flagship project, is a comprehensive manual covering the processes, techniques, and tools used during smart contract security analysis, as well as an exhaustive set of test cases for verifying the requirements listed in the OWASP Smart Contract Verification Standard (SCSVS), providing a baseline for complete and consistent security tests.</p> <p>The OWASP SCSVS and SCSTG are trusted by the following platform providers and standardization, governmental and educational institutions. Learn more.</p>","tags":[]},{"location":"SCSTG/0x02a-Frontispiece/#authors","title":"Authors","text":"","tags":[]},{"location":"SCSTG/0x02a-Frontispiece/#changelog","title":"Changelog","text":"<p>All our Changelogs are available online at the OWASP SCSTG GitHub repository, see the Releases page:</p> <p>https://github.com/OWASP/www-project-smart-contract-security-testing-guide/releases</p>","tags":[]},{"location":"SCSTG/0x02a-Frontispiece/#disclaimer","title":"Disclaimer","text":"<p>Please consult the laws in your country before executing any tests against smart contracts by utilizing the SCSTG materials. Refrain from violating the laws with anything described in the SCSTG.</p> <p>Our [Code of Conduct] has further details: https://github.com/OWASP/www-project-smart-contract-security-testing-guide/blob/master/.github/CODE_OF_CONDUCT.md</p> <p>OWASP thanks the many authors, reviewers, and editors for their hard work in developing this guide. If you have any comments or suggestions, please connect with us: https://scs.owasp.org/contact</p> <p>If you find any inconsistencies or typos please open an issue in the OWASP SCSTG Github Repo: https://github.com/OWASP/www-project-smart-contract-security-testing-guide</p>","tags":[]},{"location":"SCSTG/0x02a-Frontispiece/#copyright-and-license","title":"Copyright and License","text":"<p>Copyright \u00a9 The OWASP Foundation. This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. For any reuse or distribution, you must make clear to others the license terms of this work.</p> <p></p>","tags":[]},{"location":"SCSTG/0x02b-SCSVS-SCSTG-Adoption/","title":"OWASP SCSVS and SCSTG Adoption","text":"<p>The OWASP SCSVS and SCSTG are trusted by the following platform providers and standardization, governmental and educational institutions.</p> <ul> <li>SolidityScan.com</li> </ul> <p></p> <ul> <li>Would you like to contribute with your case study? Connect with us!</li> </ul>","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/","title":"Acknowledgments","text":"","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/#contributors","title":"Contributors","text":"<p>All of our contributors are listed in the Contributing section of the OWASP SCS website:</p> <p>https://scs.owasp.org/contributing/</p>","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/#scs-advocates","title":"\ud83e\udd47 SCS Advocates","text":"<p>SCS Advocates are industry supporters of the OWASP SCSVS and SCSTG who have invested a significant and consistent amount of resources to push the project forward by providing consistent high-impact contributions and continuously spreading the word.</p> <p>\ud83e\udd47 Being a \"SCS Advocate\" is the highest status that companies can achieve in the project, acknowledging that they've gone above and beyond to support the project.</p> <p>SCS Advocates continuously support the project with time/dedicated resources with clear/high impact. To achieve this status, you'll need to demonstrate that you make consistent high-impact contributions to the project. For example:</p> <ul> <li>Content Pull Requests (e.g. adding/updating existing tests, tooling, maintaining code samples, etc.)</li> <li>Technical PR reviews</li> <li>Improving automation (GitHub Actions)</li> <li>Upgrading, extending or creating new Crackmes</li> <li>Moderating GitHub Discussions</li> <li>Providing high quality feedback to the project and for special events such as the SCSVS/SCSTG refactoring.</li> <li>etc.</li> </ul> <p>The following will be considered but it's not a requirement:</p> <ul> <li>Showing Adoption: it should be clear just from looking at the official company page that they have adopted the OWASP SCSVS and SCSTG. For example:<ul> <li>Services/products</li> <li>Resources (e.g. blog posts, press releases, public pentest reports)</li> <li>Trainings</li> <li>etc.</li> </ul> </li> <li>Spreading the word and promoting the project with many presentations each year, public trainings, high social media involvement (e.g. liking, re-sharing, doing own posting specifically to promote the project).</li> </ul>","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/#benefits","title":"\ud83c\udf81 Benefits","text":"<ul> <li>Company logo displayed in our main READMEs and main OWASP project site.</li> <li>Linked blog posts in the SCSTG will include the company name.</li> <li>Special acknowledgement on each SCSTG release containing the contributed PRs.</li> <li>Re-shares from the OWASP SCS accounts on new publications (e.g. retweets).</li> <li>Initial public \"Thank You\" and yearly after successful renewal.</li> </ul>","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/#how-to-apply","title":"\ud83d\udcdd How to Apply","text":"<p>If you'd like to apply please contact the project leaders by sending an email. Please be sure to include sufficient evidence (e.g including links to PRs) showing what you've done in the 6 months period that goes inline with the three categories described above:</p> <ul> <li>Make consistent high-impact contributions</li> <li>Showing Adoption</li> <li>Spreading the word</li> </ul>","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/#important-disclaimers","title":"\u2757 Important Disclaimers","text":"<ul> <li>If the \"SCS Advocate\" status is granted and you'd like to maintain it, the aforementioned contributions must remain consistent after the initial period as well. You should keep collecting this evidence and send us a contribution report yearly.</li> <li>Financial donations are not part of the eligibility criteria but will be listed for completion.</li> <li>Re-shared publications and blog posts linked in SCSTG text must be educational and focus on smart contract security or SCSVS/SCSTG and not endorse company products/services.</li> <li>Advocate Companies may use the logo and links to SCSVS/SCSTG resources as part of their communication but cannot use them as an endorsement by OWASP as a preferred provider of software and services.<ul> <li>Example of what's ok: list SCS Advocate status on website home page, in \"about company\" slides in sales presentations, on sales collateral.</li> <li>Example of what's not ok: a SCS Advocate cannot claim they are OWASP certified.</li> </ul> </li> <li>The quality of the application of the SCSVS/SCSTG by these companies has not been vetted by the SCS team.</li> </ul> <p>The OWASP Foundation is very grateful for the support by the individuals and organizations listed. However please note, the OWASP Foundation is strictly vendor neutral and does not endorse any of its supporters. SCS Advocates do not influence the content of the SCSVS or SCSTG in any way.</p>","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/#our-scs-advocates","title":"Our SCS Advocates","text":"<p>CredShields has provided consistent high-impact contributions to the project and has successfully helped spread the word.</p> <p>We'd like to thank CredShields for its exemplary contribution which sets a blueprint for other potential contributors wanting to push the project forward.</p>","tags":[]},{"location":"SCSTG/0x02c-Acknowledgements/#donators","title":"Donators","text":"<p>While both the SCSVS and the SCSTG are created and maintained by the community on a voluntary basis, sometimes a little bit of outside help is required. We therefore thank our donators for providing the funds to be able to hire technical editors. Note that their donation does not influence the content of the SCSVS or SCSTG in any way. The Donation Packages are described on our OWASP Project page.</p>","tags":[]},{"location":"SCSTG/0x03-Overview/","title":"Introduction to the OWASP Smart Contract Security Project","text":"<p>The rise of smart contracts has revolutionized the way agreements are executed, creating unprecedented opportunities for automation and decentralization. However, these innovations also introduce new security challenges. Ensuring the security of smart contracts is critical, as vulnerabilities can lead to significant financial and reputational losses. The OWASP Smart Contract Security Verification Standard (SCSVS) and Smart Contract Security Testing Guide (SCSTG) have been developed to help developers, auditors, and organizations address these challenges effectively.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#how-to-use-the-smart-contract-security-project","title":"How to Use the Smart Contract Security Project","text":"<p>The OWASP Smart Contract Security Project provides a structured approach to evaluating and improving the security of smart contracts. It begins with the OWASP Smart Contract Security Verification Standard (SCSVS), which outlines a comprehensive security model and provides a set of security requirements for smart contracts. These requirements are designed to be used across the entire development lifecycle, serving architects, developers, testers, and security professionals.  </p> <p>Once the SCSVS requirements have been identified for your use case, the next step is to apply the OWASP Smart Contract Security Testing Guide (SCSTG). The SCSTG maps directly to the SCSVS requirements, offering practical testing methodologies and techniques. Together, these resources form a robust framework for smart contract security.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#whats-covered-in-the-smart-contract-security-guide","title":"What's Covered in the Smart Contract Security Guide","text":"<p>This guide focuses on the security aspects of smart contracts deployed on blockchain platforms. While blockchain ecosystems vary significantly, the testing principles and techniques outlined in this guide can be applied broadly, with adjustments made for specific platforms or use cases.  </p> <p>The OWASP Smart Contract Security Project addresses the following key areas of concern:  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-arch-architecture-design-and-threat-modeling","title":"SCSVS-ARCH: Architecture, Design, and Threat Modeling","text":"<p>Secure smart contract systems start with a well-thought-out architecture. This involves threat modeling, identifying attack surfaces, and designing systems to minimize risk. Ensuring modularity and adopting principles like least privilege are crucial steps in this process.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-code-policies-procedures-and-code-management","title":"SCSVS-CODE: Policies, Procedures, and Code Management","text":"<p>Effective governance ensures that smart contract development follows secure coding practices, utilizes peer review processes, and adheres to proper code versioning and management procedures. Policies should also address incident response and vulnerability disclosure.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-gov-business-logic-and-economic-security","title":"SCSVS-GOV: Business Logic and Economic Security","text":"<p>Business logic vulnerabilities often stem from poorly defined economic models or flaws in their implementation. Ensuring that the contract\u2019s logic aligns with its intended purpose and testing for edge cases are essential.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-auth-access-control-and-authentication","title":"SCSVS-AUTH: Access Control and Authentication","text":"<p>Smart contracts must implement robust access control mechanisms to prevent unauthorized actions. This includes enforcing role-based permissions and ensuring authentication mechanisms are secure against attacks such as replay or signature forgery.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-comm-secure-interactions-and-communications","title":"SCSVS-COMM: Secure Interactions and Communications","text":"<p>Securely interacting with other contracts, off-chain systems, oracles, and external data sources is critical. Avoiding trust assumptions and ensuring proper validation of inputs and responses are key.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-crypto-cryptographic-practices","title":"SCSVS-CRYPTO: Cryptographic Practices","text":"<p>Smart contracts rely heavily on cryptography for secure communication, authentication, and data protection. Ensuring the correct implementation of cryptographic primitives, using secure random number generation, and avoiding deprecated libraries are essential.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-oracle-arithmetic-and-logic-security","title":"SCSVS-ORACLE: Arithmetic and Logic Security","text":"<p>Incorrect arithmetic operations and faulty logical implementations can lead to vulnerabilities, such as integer overflows or underflows. Ensuring precision in calculations and using safe math libraries are vital for security.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-block-denial-of-service-dos","title":"SCSVS-BLOCK: Denial of Service (DoS)","text":"<p>Smart contracts should be resilient to DoS attacks, ensuring that their functionality remains accessible even under adversarial conditions. This includes proper gas usage and avoiding reentrancy vulnerabilities.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-bridge-blockchain-data-and-state-management","title":"SCSVS-BRIDGE: Blockchain Data and State Management","text":"<p>Efficiently managing blockchain state and ensuring consistency in data storage and retrieval are crucial to avoid vulnerabilities related to data integrity or unexpected state changes. </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-defi-gas-usage-efficiency-and-limitations","title":"SCSVS-DEFI: Gas Usage, Efficiency, and Limitations","text":"<p>Gas optimization is critical in smart contract development. Inefficient code can lead to excessive costs or failed transactions. Ensuring that gas usage is minimized and falls within platform limits is a priority.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#scsvs-comp-component-specific-security","title":"SCSVS-COMP: Component-Specific Security","text":"<p>Different components of a smart contract system, such as token standards (ERC-20, ERC-721) or multi-signature wallets, have unique security requirements. This guide provides recommendations tailored to specific components.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#navigating-the-owasp-scstg","title":"Navigating the OWASP SCSTG","text":"<p>The SCSTG offers practical testing methodologies for each of the SCSVS areas, allowing users to methodically evaluate and secure their smart contracts. It is organized into:  </p> <ol> <li>General Testing Guide: Covers testing techniques that apply across all EVM-based blockchains' smart contracts, including secure coding practices, network communication, and cryptographic implementations.  </li> <li>Platform-Specific Testing: Addresses unique considerations for EVM-Based Blockcahins.  </li> </ol>","tags":[]},{"location":"SCSTG/0x03-Overview/#how-security-professionals-can-use-the-guide","title":"How Security Professionals Can Use the Guide","text":"<p>Smart contract auditors and security testers can use the SCSVS as a baseline for evaluations and the SCSTG for actionable testing strategies. By combining these resources with platform-specific knowledge, they can identify vulnerabilities, suggest remediations, and contribute to the overall security of blockchain ecosystems.  </p>","tags":[]},{"location":"SCSTG/0x03-Overview/#owasp-scsvs-overview-key-areas-in-smart-contract-security","title":"OWASP SCSVS Overview: Key Areas in Smart Contract Security","text":"<p>The following sections provide an overview of the SCSVS categories and their relevance to smart contract security.  </p> <ul> <li>OWASP Smart Contract Security Verification Standard </li> </ul> <p>We encourage you to dive into the guide, experiment with its methodologies, and contribute to its ongoing evolution. Together, we can make the blockchain ecosystem more secure for everyone.  </p>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/","title":"Smart Contract Taxonomy","text":"<p>This taxonomy provides a structured framework for understanding and categorizing smart contracts, specifically focusing on EVM-based blockchains and Solidity. It is intended to aid developers, auditors, and researchers in identifying key areas of functionality, associated risks, and best practices for secure development.  </p>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#1-token-contracts","title":"1. Token Contracts","text":"","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#examples-erc-20-erc-721-erc-1155","title":"Examples: ERC-20, ERC-721, ERC-1155","text":"<ul> <li>Description:   Smart contracts representing fungible, non-fungible, or semi-fungible tokens.  </li> <li>Use Cases:  </li> <li>Cryptocurrencies and stablecoins (ERC-20).  </li> <li>NFTs for digital ownership and collectibles (ERC-721).  </li> <li>Multi-token standards (ERC-1155).  </li> <li>Key Risks:  </li> <li>Incorrect implementation of token standards.  </li> <li>Integer overflows/underflows.  </li> <li>Lack of proper access control on minting or burning functions.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#2-crowdfunding-and-fundraising-contracts","title":"2. Crowdfunding and Fundraising Contracts","text":"","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#examples-icos-idos-ieos","title":"Examples: ICOs, IDOs, IEOs","text":"<ul> <li>Description:   Contracts that facilitate the collection of funds in exchange for tokens or other benefits.  </li> <li>Use Cases:  </li> <li>Initial Coin Offerings (ICOs).  </li> <li>Decentralized fundraising on platforms like Uniswap or Balancer.  </li> <li>Key Risks:  </li> <li>Rug-pulls or misappropriation of funds.  </li> <li>Vulnerabilities in refund mechanisms.  </li> <li>Failing to secure investor funds in escrow.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#3-governance-contracts","title":"3. Governance Contracts","text":"","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#examples-daos-voting-mechanisms","title":"Examples: DAOs, voting mechanisms","text":"<ul> <li>Description:   Contracts enabling decentralized governance and decision-making processes.  </li> <li>Use Cases:  </li> <li>Token-based voting systems for DAOs.  </li> <li>Community-driven proposals and execution mechanisms.  </li> <li>Key Risks:  </li> <li>Voting manipulation (e.g., Sybil attacks).  </li> <li>Flawed quorum or proposal execution logic.  </li> <li>Lack of on-chain transparency in decision-making.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#4-defi-protocols","title":"4. DeFi Protocols","text":"","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#examples-amms-lending-yield-aggregators","title":"Examples: AMMs, Lending, Yield Aggregators","text":"<ul> <li>Description:   Financial services provided via smart contracts without intermediaries.  </li> <li>Use Cases:  </li> <li>Automated Market Makers (e.g., Uniswap, SushiSwap).  </li> <li>Decentralized lending/borrowing platforms (e.g., Aave, Compound).  </li> <li>Yield farming and liquidity mining (e.g., Yearn Finance).  </li> <li>Key Risks:  </li> <li>Impermanent loss in AMMs.  </li> <li>Exploitable liquidation mechanics in lending platforms.  </li> <li>Flash loan-based attacks on arbitrage opportunities.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#5-oracle-contracts","title":"5. Oracle Contracts","text":"","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#examples-chainlink-tellor","title":"Examples: Chainlink, Tellor","text":"<ul> <li>Description:   Contracts fetching off-chain data to use in on-chain operations.  </li> <li>Use Cases:  </li> <li>Price feeds for DeFi protocols.  </li> <li>Real-world event triggers for smart contracts.  </li> <li>Key Risks:  </li> <li>Price manipulation attacks.  </li> <li>Delayed or incorrect data delivery.  </li> <li>Centralization risks in oracle mechanisms.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#6-escrow-and-payment-contracts","title":"6. Escrow and Payment Contracts","text":"<ul> <li>Description:   Contracts managing funds between parties, releasing them based on predefined conditions.  </li> <li>Use Cases:  </li> <li>Secure peer-to-peer transactions.  </li> <li>Conditional payments for services or goods.  </li> <li>Key Risks:  </li> <li>Logic errors leading to incorrect fund releases.  </li> <li>Lack of multi-sig protection in disputes.  </li> <li>Malicious actors exploiting refund or lockup conditions.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#7-lottery-and-gambling-contracts","title":"7. Lottery and Gambling Contracts","text":"<ul> <li>Description:   Contracts providing randomness-based services, such as lotteries or casino games.  </li> <li>Use Cases:  </li> <li>Decentralized lotteries.  </li> <li>On-chain games of chance.  </li> <li>Key Risks:  </li> <li>Manipulation of randomness sources (e.g., block hashes).  </li> <li>Front-running attacks in prize distributions.  </li> <li>Regulatory compliance issues.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#8-identity-and-access-management","title":"8. Identity and Access Management","text":"<ul> <li>Description:   Contracts that verify user identities and manage access control.  </li> <li>Use Cases:  </li> <li>Decentralized identity solutions (DID).  </li> <li>Role-based access systems in DAOs.  </li> <li>Key Risks:  </li> <li>Unauthorized privilege escalation.  </li> <li>Mishandling of sensitive user data.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#9-bridge-contracts","title":"9. Bridge Contracts","text":"","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#examples-cross-chain-bridges","title":"Examples: Cross-chain bridges","text":"<ul> <li>Description:   Contracts facilitating asset or data transfers between blockchains.  </li> <li>Use Cases:  </li> <li>Bridging tokens across L1s and L2s (e.g., Ethereum \u2194 Arbitrum).  </li> <li>Enabling interoperability between blockchains.  </li> <li>Key Risks:  </li> <li>Replay attacks.  </li> <li>Exploits in validator or relayer systems.  </li> <li>Loss of funds during cross-chain transfers.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#10-supply-chain-and-logistics-contracts","title":"10. Supply Chain and Logistics Contracts","text":"<ul> <li>Description:   Contracts managing supply chain operations or tracking logistics.  </li> <li>Use Cases:  </li> <li>Verifying product authenticity.  </li> <li>Tracking shipments across supply chains.  </li> <li>Key Risks:  </li> <li>Dependence on external data integrity.  </li> <li>Incorrect implementation of audit trails.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#11-gaming-and-metaverse-contracts","title":"11. Gaming and Metaverse Contracts","text":"<ul> <li>Description:   Contracts supporting blockchain-based games or virtual worlds.  </li> <li>Use Cases:  </li> <li>On-chain asset ownership (NFTs).  </li> <li>In-game economies using tokens.  </li> <li>Key Risks:  </li> <li>Vulnerabilities in in-game tokenomics.  </li> <li>Exploits in trade or auction mechanisms.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#12-security-tools-and-audit-enablers","title":"12. Security Tools and Audit Enablers","text":"","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#examples-multisig-wallets-time-locks","title":"Examples: Multisig wallets, time locks","text":"<ul> <li>Description:   Contracts providing additional layers of security or facilitating audits.  </li> <li>Use Cases:  </li> <li>Multi-signature wallets for secure asset custody.  </li> <li>Timelocks for deferred execution of sensitive operations.  </li> <li>Key Risks:  </li> <li>Misconfigured access controls.  </li> <li>Logic errors in time-based operations.  </li> </ul>","tags":[]},{"location":"SCSTG/0x04a-Smart-Contract-Taxonomy/#13-arbitrage-and-mev-bots","title":"13. Arbitrage and MEV Bots","text":"<ul> <li>Description:   Contracts designed for exploiting arbitrage opportunities or MEV (Maximal Extractable Value).  </li> <li>Use Cases:  </li> <li>On-chain arbitrage trading.  </li> <li>Gas optimization and priority mechanisms.  </li> <li>Key Risks:  </li> <li>Front-running or sandwich attacks on users.  </li> <li>Exploitation of network congestion.  </li> </ul> <p>This taxonomy helps categorize the diverse applications of Solidity and EVM-based contracts, ensuring that each category is analyzed for its unique security challenges and development requirements. By understanding these categories, developers can adopt best practices and mitigate risks effectively.  </p>","tags":[]},{"location":"SCSTG/tests/","title":"SCSTG Tests","text":"TEST ID Title SCSVS CG ID SCSVS SCG IDs Last Updated SCSTG-TEST-0008  Efficient Loop and Function Design SCSVS-BLOCK SCSVS-BLOCK-1 N/A SCSTG-TEST-0012  Test Token Implementations (ERC20, ERC721, ERC1155) SCSVS-COMP SCSVS-COMP-1 N/A SCSTG-TEST-0007  Modularity and Upgradability SCSVS-ARCH SCSVS-ARCH-2 N/A SCSTG-TEST-0015  Testing Business Logic and Economic Security SCSVS-GOV SCSVS-GOV-1 N/A SCSTG-TEST-0014  Test Gas Usage in Loops SCSVS-DEFI SCSVS-DEFI-1 N/A SCSTG-TEST-0011  Test Contract Interactions SCSVS-COMM SCSVS-COMM-1 N/A SCSTG-TEST-0016  Testing Arithmetic and Logic Security SCSVS-ORACLE SCSVS-ORACLE-1 N/A SCSTG-TEST-0009  Blockchain Data and State Management SCSVS-BRIDGE SCSVS-BRIDGE-1 N/A SCSTG-TEST-0004  Test Access Control on Critical Functions SCSVS-AUTH SCSVS-AUTH-1 N/A SCSTG-TEST-0006  Test Access Control Using Merkle Trees SCSVS-AUTH SCSVS-AUTH-2 N/A SCSTG-TEST-0002  Identity Verification Test SCSVS-AUTH SCSVS-AUTH-1 N/A SCSTG-TEST-0001  Testing Multi-Signature Schemes SCSVS-AUTH SCSVS-AUTH-1 N/A SCSTG-TEST-0005  Test Timed Permissions SCSVS-AUTH SCSVS-AUTH-1 N/A SCSTG-TEST-0003  Least Privilege Principle Test SCSVS-AUTH SCSVS-AUTH-1 N/A SCSTG-TEST-0013  Secure Signature Verification SCSVS-CRYPTO SCSVS-CRYPTO-2 N/A SCSTG-TEST-0010  Test Compiler Version and Deprecated Functions SCSVS-CODE SCSVS-CODE-2 N/A","tags":[]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/","title":"SCSTG-TEST-0007: Modularity and Upgradability","text":"","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#description","title":"Description","text":"<p>Modularity and upgradability are essential principles for the long-term security and maintainability of smart contracts. Poor modularity often leads to monolithic designs that combine critical logic and storage, making it difficult to upgrade, audit, or scale the system. Without controlled upgrade mechanisms, an attacker could exploit weaknesses in the upgrade process, leading to unauthorized contract changes or the introduction of security flaws. Ensuring a well-structured contract with clear modular separation, as well as a secure upgrade process, is crucial to avoiding such vulnerabilities.</p>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#test-1-ensure-proper-separation-of-logic-and-state","title":"Test 1: Ensure Proper Separation of Logic and State","text":"","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#vulnerable-code","title":"Vulnerable Code","text":"<pre><code>contract Monolithic {\n    uint256 public data;\n    address public admin;\n\n    function updateData(uint256 _data) public {\n        require(msg.sender == admin, \"Unauthorized\");\n        data = _data;\n    }\n\n    function upgrade(address newAdmin) public {\n        require(msg.sender == admin, \"Unauthorized\");\n        admin = newAdmin;\n    }\n}\n</code></pre>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The monolithic design combines logic and state in a single contract, making upgrades risky.</li> <li>Changes to storage or logic could inadvertently corrupt existing data.</li> <li>The lack of separation makes it more difficult to isolate bugs or vulnerabilities in logic.</li> </ul>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#fixed-code","title":"Fixed Code:","text":"<pre><code>contract Logic {\n    address public admin;\n    Storage public storageContract;\n\n    constructor(address _storageContract) {\n        admin = msg.sender;\n        storageContract = Storage(_storageContract);\n    }\n\n    function updateData(uint256 _data) public {\n        require(msg.sender == admin, \"Unauthorized\");\n        storageContract.setData(_data);\n    }\n}\n\ncontract Storage {\n    uint256 public data;\n\n    function setData(uint256 _data) public {\n        data = _data;\n    }\n}\n</code></pre>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Verify the separation of logic and storage into separate contracts.</li> <li>Storage Analysis: Ensure that the storage layout remains intact when upgrading the contract logic, and that no data corruption occurs.</li> </ul>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#test-2-verify-secure-and-controlled-upgrade-mechanism","title":"Test 2: Verify Secure and Controlled Upgrade Mechanism","text":"","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#vulnerable-code_1","title":"Vulnerable Code:","text":"<pre><code>contract Proxy {\n    address public implementation;\n\n    function upgrade(address newImplementation) public {\n        implementation = newImplementation;\n    }\n}\n</code></pre>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#why-its-vulnerable_1","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The upgrade function is not protected with any access control, allowing any user to replace the implementation contract. This opens the door for malicious actors to hijack the contract functionality.</li> </ul>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#fixed-code_1","title":"Fixed Code:","text":"<pre><code>contract SecureProxy {\n    address public implementation;\n    address public admin;\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Unauthorized\");\n        _;\n    }\n\n    function upgrade(address newImplementation) public onlyAdmin {\n        implementation = newImplementation;\n    }\n}\n</code></pre>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/SCSTG-TEST-0007/#how-to-check_1","title":"How to Check","text":"<ul> <li>Code Review: Ensure that upgrade functions are protected by access control mechanisms (e.g., only the admin can upgrade).</li> <li>Dynamic Testing: Attempt to perform an unauthorized upgrade to verify that the access control works as intended.</li> </ul>","tags":["test","SCSVS-ARCH-2","SCSVS-ARCH"]},{"location":"SCSTG/tests/SCSVS-ARCH/overview/","title":"Architecture, Design, and Threat Modeling","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-ARCH/overview/#description","title":"Description","text":"<p>Flawed architecture, design, and inadequate threat modeling in smart contracts can lead to vulnerabilities that compromise the security, functionality, or usability of a decentralized application (dApp). These issues often arise due to a lack of consideration for potential attack vectors, edge cases, and dependencies during the design phase.</p> <p>Poor design and threat modeling can result in issues such as:</p> <ul> <li>Insecure storage of sensitive data</li> <li>Flawed or unoptimized logic for critical functions</li> <li>Lack of mitigation strategies for common attack vectors, such as reentrancy or flash loan attacks</li> <li>Insufficient mechanisms for governance or upgrades</li> <li>Overlooked dependencies on external systems or oracles</li> </ul> <p>Example: Poorly Designed Function Logic</p> <pre><code>function withdraw(uint256 amount) public {\n    // Does not check for balance before withdrawal\n    (bool success, ) = msg.sender.call{value: amount}(\"\");\n    require(success, \"Withdrawal failed\");\n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-ARCH/overview/#impact","title":"Impact","text":"<ul> <li>Contracts may become vulnerable to exploitation, resulting in the theft or loss of funds, data corruption, or denial of service.  </li> <li>Security flaws in design can lead to cascading failures in interconnected systems or dApps.  </li> <li>Exploits often undermine user trust and the reputation of the project.  </li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-ARCH/overview/#remediation","title":"Remediation","text":"<ul> <li>Conduct a comprehensive threat model analysis during the design phase to identify potential risks and attack vectors.  </li> <li>Follow secure coding and design principles, such as least privilege, separation of duties, and fail-safe defaults.  </li> <li>Regularly perform security audits, both during development and prior to deployment.  </li> <li>Use formal verification tools to validate critical properties of your smart contracts.  </li> <li>Employ defense-in-depth strategies, including mechanisms like reentrancy guards, circuit breakers, and secure external call handling.  </li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-AUTH/SCSTG-TEST-0001/","title":"SCSTG-TEST-0001: Testing Multi-Signature Schemes","text":"<p>Ensure that multi-signature schemes are implemented for critical operations, requiring approvals from multiple authorized parties to enhance security and reduce the risk of unauthorized actions.</p> <ul> <li>Verify that the multi-signature logic ensures a configurable threshold of approvals before executing sensitive operations.  </li> <li>Confirm that all signers are authenticated and that duplicate signatures are rejected.  </li> <li>Test edge cases, such as insufficient approvals or tampered data.</li> </ul> <p><pre><code>// Example of multi-signature scheme\npragma solidity ^0.8.0;\n\ncontract MultiSigWallet {\n    address[] public owners;\n    uint public requiredApprovals;\n    mapping(address =&gt; bool) public isOwner;\n    mapping(uint =&gt; mapping(address =&gt; bool)) public approvals;\n\n    struct Transaction {\n        address to;\n        uint value;\n        bool executed;\n    }\n\n    Transaction[] public transactions;\n\n    constructor(address[] memory _owners, uint _requiredApprovals) {\n        require(_owners.length &gt; 0, \"Owners required\");\n        require(_requiredApprovals &gt; 0 &amp;&amp; _requiredApprovals &lt;= _owners.length, \"Invalid approval count\");\n\n        for (uint i = 0; i &lt; _owners.length; i++) {\n            isOwner[_owners[i]] = true;\n        }\n        owners = _owners;\n        requiredApprovals = _requiredApprovals;\n    }\n\n    function submitTransaction(address _to, uint _value) public {\n        require(isOwner[msg.sender], \"Not an owner\");\n        transactions.push(Transaction({to: _to, value: _value, executed: false}));\n    }\n\n    function approveTransaction(uint _txIndex) public {\n        require(isOwner[msg.sender], \"Not an owner\");\n        require(!approvals[_txIndex][msg.sender], \"Already approved\");\n\n        approvals[_txIndex][msg.sender] = true;\n    }\n\n    function executeTransaction(uint _txIndex) public {\n        require(transactions[_txIndex].executed == false, \"Already executed\");\n\n        uint approvalCount = 0;\n        for (uint i = 0; i &lt; owners.length; i++) {\n            if (approvals[_txIndex][owners[i]]) {\n                approvalCount++;\n            }\n        }\n\n        require(approvalCount &gt;= requiredApprovals, \"Not enough approvals\");\n\n        transactions[_txIndex].executed = true;\n        payable(transactions[_txIndex].to).transfer(transactions[_txIndex].value);\n    }\n\n    receive() external payable {}\n}\n</code></pre> Review the logic to ensure all approvals are validated before execution, duplicate approvals are prevented, and transaction data integrity is maintained. Test with various approval scenarios to verify proper handling of edge cases.</p>","tags":["test","SCSVS-AUTH-1","SCSVS-AUTH"]},{"location":"SCSTG/tests/SCSVS-AUTH/SCSTG-TEST-0002/","title":"SCSTG-TEST-0002: Identity Verification Test","text":"<p>Validate that unexpected addresses do not result in unintended behaviors, particularly when these addresses refer to contracts within the same protocol.</p> <ul> <li>Ensure that when interacting with contracts, unexpected addresses are properly validated before performing sensitive operations. <pre><code>require(address(contract) != address(0), \"Invalid address\");\n</code></pre></li> </ul> <p>Verify that functions like ecrecover handle all potential null addresses properly to avoid vulnerabilities arising from unexpected ecrecover outputs.</p> <ul> <li>Ensure that ecrecover does not process empty or null addresses. <pre><code>address recovered = ecrecover(messageHash, v, r, s);\nrequire(recovered != address(0), \"Invalid signature\");\n</code></pre></li> </ul>","tags":["test","SCSVS-AUTH-1","SCSVS-AUTH"]},{"location":"SCSTG/tests/SCSVS-AUTH/SCSTG-TEST-0003/","title":"SCSTG-TEST-0003: Least Privilege Principle Test","text":"<p>Use msg.sender instead of tx.origin for authorization to avoid potential abuse from malicious contracts; include checks like require(tx.origin == msg.sender) to ensure the sender is an EOA.</p> <ul> <li>tx.origin can be abused by malicious contracts to trick the system into performing actions on behalf of an unsuspecting user. msg.sender is preferred since it refers to the direct sender of the message. <pre><code>require(msg.sender == owner, \"Not the owner\");\nrequire(tx.origin == msg.sender, \"Only EOA can execute\");\n</code></pre></li> </ul> <p>Certain addresses might be blocked or restricted from receiving tokens (e.g., LUSD). Ensure that address restrictions are properly managed and verified.</p> <ul> <li>If certain addresses (like LUSD) should be blocked from receiving tokens, ensure that there\u2019s a check in place to restrict these addresses. <pre><code>address restrictedAddress = 0x123...;  // Example of a restricted address\nrequire(msg.sender != restrictedAddress, \"Restricted address cannot perform this operation\");\n</code></pre></li> </ul> <p>Ensure that Guard\u2019s hooks (e.g., checkTransaction(), checkAfterExecution()) are executed to enforce critical security checks.</p> <ul> <li>If using a Guard contract, ensure that hooks like checkTransaction() or checkAfterExecution() are properly implemented to enforce security conditions. <pre><code>function checkTransaction() internal {\n    // Add conditions to verify transaction before execution\n}\n\nfunction checkAfterExecution() internal {\n    // Add conditions to verify transaction after execution\n}\n</code></pre></li> </ul>","tags":["test","SCSVS-AUTH-1","SCSVS-AUTH"]},{"location":"SCSTG/tests/SCSVS-AUTH/SCSTG-TEST-0004/","title":"SCSTG-TEST-0004: Test Access Control on Critical Functions","text":"<p>Ensure that access controls are implemented correctly to determine who can use certain functions, and avoid unauthorized changes or withdrawals.</p> <ul> <li>Ensure that functions requiring specific roles or permissions are restricted properly using onlyOwner or role-based checks. <pre><code>    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    function withdraw() external onlyOwner {\n        // Only the owner can withdraw\n    }\n</code></pre></li> </ul>","tags":["test","SCSVS-AUTH-1","SCSVS-AUTH"]},{"location":"SCSTG/tests/SCSVS-AUTH/SCSTG-TEST-0005/","title":"SCSTG-TEST-0005: Test Timed Permissions","text":"<p>Ensure that access controls are implemented correctly to determine who can use certain functions, and avoid unauthorized changes or withdrawals.</p> <ul> <li>Ensure that functions requiring specific roles or permissions are restricted properly using onlyOwner or role-based checks.</li> </ul> <pre><code>    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    function withdraw() external onlyOwner {\n        // Only the owner can withdraw\n    }\n</code></pre>","tags":["test","SCSVS-AUTH-1","SCSVS-AUTH"]},{"location":"SCSTG/tests/SCSVS-AUTH/SCSTG-TEST-0006/","title":"SCSTG-TEST-0006: Test Access Control Using Merkle Trees","text":"<p>Ensure that <code>msg.sender</code> validation is properly implemented when using Merkle trees to maintain security and prevent unauthorized access.</p> <ul> <li>When using Merkle trees to authenticate users or grant permissions, ensure that the contract verifies that <code>msg.sender</code> matches the expected address and Merkle proof. This prevents unauthorized actors from bypassing security by submitting incorrect proofs.</li> </ul> <pre><code>    require(verifyMerkleProof(msg.sender, merkleProof), \"Invalid Merkle proof\");\n</code></pre> <ul> <li> <p>Use whitelisting to restrict interactions to a specific set of addresses, providing additional security against malicious actors.</p> </li> <li> <p>Implement a whitelisting mechanism that allows only approved addresses to interact with specific functions. Ensure that only addresses explicitly added to the whitelist are able to execute sensitive operations.</p> </li> </ul> <p><pre><code>    address[] public whitelist;\n\n    modifier onlyWhitelisted() {\n        bool isWhitelisted = false;\n        for (uint i = 0; i &lt; whitelist.length; i++) {\n            if (msg.sender == whitelist[i]) {\n                isWhitelisted = true;\n                break;\n            }\n        }\n        require(isWhitelisted, \"Address not whitelisted\");\n        _;\n    }\n\n    function addToWhitelist(address _address) external onlyOwner {\n        whitelist.push(_address);\n    }\n</code></pre> - Ensure that functions modifying the contract state or accessing sensitive operations have proper access controls implemented.</p> <ul> <li>Critical functions, such as those that modify contract state or handle sensitive information, should only be callable by authorized addresses (e.g., the owner or an admin). Use modifiers to enforce access controls for these functions.</li> </ul> <pre><code>    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the contract owner\");\n        _;\n    }\n\n    function modifyContractState() external onlyOwner {\n        // Logic to modify contract state\n    }\n</code></pre>","tags":["test","SCSVS-AUTH-2","SCSVS-AUTH"]},{"location":"SCSTG/tests/SCSVS-AUTH/overview/","title":"Access Control and Authentication Vulnerabilties","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-AUTH/overview/#description","title":"Description","text":"<p>Improper access control is a critical security vulnerability in smart contracts that occurs when unauthorized users can access or modify sensitive functions or data. This issue typically arises when the code does not enforce strict access restrictions based on user permissions.</p> <p>Access control vulnerabilities are especially significant in scenarios involving governance or critical operations, such as:</p> <ul> <li>Minting tokens</li> <li>Voting on proposals</li> <li>Withdrawing funds</li> <li>Pausing or upgrading contracts</li> <li>Changing contract ownership</li> </ul> <p>Example: Code Without Proper Access Control</p> <pre><code>function burn(address account, uint256 amount) public \n{\n    // No access control is implemented for the burn function\n    _burn(account, amount); \n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-AUTH/overview/#impact","title":"Impact","text":"<ul> <li>Attackers can gain unauthorized access to critical functions and data within the contract, compromising its integrity and security.</li> <li>Vulnerabilities can lead to the theft of funds or assets controlled by the contract, causing significant financial damage to users and stakeholders.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-AUTH/overview/#remediation","title":"Remediation","text":"<ul> <li>Ensure initialization functions can only be called once and exclusively by authorized entities.</li> <li>Use established access control patterns like Ownable or RBAC (Role-Based Access Control) in your contracts to manage permissions and ensure that only authorized users can access certain functions. This can be done by adding appropriate access control modifiers, such as onlyOwner or custom roles to sensitive functions.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-AUTH/overview/#examples-of-smart-contracts-that-fell-victim-to-improper-access-control-attacks","title":"Examples of Smart Contracts That Fell Victim to Improper Access Control Attacks:","text":"<ul> <li>HospoWise Hack Analysis</li> <li>LAND NFT Hack Analysis</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/","title":"SCSTG-TEST-0008: Efficient Loop and Function Design","text":"","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#description","title":"Description","text":"<p>Inefficient loop and function designs in smart contracts can result in excessive gas consumption, leading to out-of-gas errors and potential denial-of-service (DoS) vulnerabilities. Smart contract security auditors must ensure that all loops and functions are optimized to operate within Ethereum's block gas limit.</p>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#test-1-detecting-unbounded-loops","title":"Test 1: Detecting Unbounded Loops","text":"","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#objective","title":"Objective","text":"<p>Identify and mitigate the use of unbounded loops in contract code, as they are vulnerable to excessive gas usage.  </p>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract UnboundedLoopExample {\n    uint[] public data;\n\n    function processAll() public {\n        for (uint i = 0; i &lt; data.length; i++) {\n            // This operation scales with the size of the array\n            data[i] = data[i] + 1;\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<p>The loop iterates over the entire <code>data</code> array, which could grow indefinitely. - For large arrays, gas consumption may exceed the block gas limit, causing the transaction to fail. - Attackers could exploit this by filling the array, making the function unusable for legitimate users.  </p>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Look for <code>for</code> or <code>while</code> loops operating on dynamic arrays or mappings without size constraints.  </li> <li>Dynamic Input Testing: Test the function with a large dataset to simulate its behavior near the gas limit.  </li> <li>Review Documentation: Ensure the contract specifies constraints on data growth and function usage.  </li> </ul>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#fixed-code-example","title":"Fixed Code Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract BoundedLoopExample {\n    uint[] public data;\n\n    function processBatch(uint start, uint end) public {\n        require(end &lt;= data.length, \"End index out of bounds\");\n        for (uint i = start; i &lt; end; i++) {\n            data[i] = data[i] + 1;\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#test-2-identifying-inefficient-nested-loops","title":"Test 2: Identifying Inefficient Nested Loops","text":"","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#objective_1","title":"Objective","text":"<ul> <li>Detect and address inefficient nested loops that exponentially increase gas consumption.</li> </ul>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#vulnerable-code","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract NestedLoopExample {\n    uint[][] public matrix;\n\n    function processMatrix() public {\n        for (uint i = 0; i &lt; matrix.length; i++) {\n            for (uint j = 0; j &lt; matrix[i].length; j++) {\n                matrix[i][j] = matrix[i][j] * 2;\n            }\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#why-its-vulnerable_1","title":"Why It\u2019s Vulnerable","text":"<p>Nested loops increase the complexity of the operation, leading to higher gas costs as input size increases. - Large datasets could render the function unusable within the gas limits, causing DoS conditions.  </p>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/SCSTG-TEST-0008/#how-to-check_1","title":"How to Check","text":"<ul> <li>Code Review: Examine nested loops in the code and assess their gas consumption relative to the input size.  </li> <li>Gas Profiling: Use tools like <code>eth-gas-reporter</code> to analyze gas usage during testing.  </li> <li>Dynamic Testing: Simulate scenarios with large <code>matrix</code> sizes to observe the contract\u2019s behavior under stress.  </li> </ul> <pre><code>pragma solidity ^0.8.0;\n\ncontract OptimizedNestedLoopExample {\n    uint[][] public matrix;\n\n    function processMatrixBatch(uint startRow, uint endRow) public {\n        require(endRow &lt;= matrix.length, \"End row exceeds matrix size\");\n        for (uint i = startRow; i &lt; endRow; i++) {\n            for (uint j = 0; j &lt; matrix[i].length; j++) {\n                matrix[i][j] = matrix[i][j] * 2;\n            }\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-BLOCK-1","SCSVS-BLOCK"]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/","title":"Denial of Service (DoS)","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#description","title":"Description","text":"<p>Denial of Service (DoS) vulnerabilities occur when a smart contract or system is made unavailable to its users by exhausting computational resources or blocking critical operations. This type of vulnerability can result from inefficient function design, excessive gas usage, or unhandled failure conditions. DoS attacks can lead to degraded performance, halted operations, and a poor user experience. To prevent DoS vulnerabilities, developers must carefully design gas-efficient operations, handle errors gracefully, and mitigate the risk of resource exhaustion.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#example-unbounded-loop-with-user-input","title":"Example:  Unbounded Loop with User Input","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract GasDoSVulnerable {\n    mapping(address =&gt; uint256) public balances;\n\n    // Allows a user to send tokens to many recipients in one transaction.\n    function bulkTransfer(address[] memory recipients, uint256[] memory amounts) public {\n        require(recipients.length == amounts.length, \"Invalid input\");\n\n        for (uint256 i = 0; i &lt; recipients.length; i++) {\n            require(amounts[i] &gt; 0, \"Amount must be greater than zero\");\n            balances[recipients[i]] += amounts[i];\n        }\n    }\n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#impact","title":"Impact","text":"<ul> <li>Gas Limit Exhaustion: Functions that rely on loops with dynamic input sizes or unoptimized logic can lead to excessive gas consumption. This can result in transactions exceeding the block gas limit, causing out-of-gas errors or failing to complete.</li> <li>Transaction Failures: Without adequate handling of gas usage or error conditions, contracts can fail unexpectedly, preventing legitimate operations and denying service to users.</li> <li>Resource Exhaustion: Improperly managed resource consumption, such as large data queries or excessive loop iterations, can overwhelm the system, causing DoS by exhausting computational resources or making the contract unavailable for further interactions.</li> <li>Increased Transaction Costs: Inefficient gas usage may lead to higher transaction fees, discouraging users from interacting with the contract or causing network congestion.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#remediation","title":"Remediation","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#efficient-loop-and-function-design","title":"Efficient Loop and Function Design:","text":"<ul> <li>Optimize functions with loops to reduce gas consumption and prevent DoS attacks by ensuring that loops operate with fixed or minimal input sizes. Avoid using large dynamic data arrays in loops.</li> <li>Ensure critical functions, like <code>burn()</code>, handle failures gracefully, so that the contract does not enter an unrecoverable state.</li> <li>Protect against griefing attacks by managing gas consumption carefully, ensuring that operations are efficient and do not hit gas limits.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#fallback-mechanisms","title":"Fallback Mechanisms:","text":"<ul> <li>Implement try/catch blocks with sufficient gas to prevent unexpected failures from leaving the contract in an inconsistent or unresponsive state.</li> <li>Design fallback mechanisms that ensure errors are caught and handled without causing DoS vulnerabilities, such as failing silently or leaving contracts in a halted state.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#rate-limiting-and-resource-management","title":"Rate Limiting and Resource Management:","text":"<ul> <li>Avoid blocking mechanisms that could lead to DoS attacks. For example, ensure that excessive queries or operations are handled efficiently, especially when dealing with external systems or large datasets.</li> <li>Use rate limiting or batching for high-volume transactions to prevent overwhelming the system or consuming excessive resources.</li> <li>Implement efficient error handling for external function calls to ensure that the contract doesn't fail or become unresponsive due to unchecked return values or failed external interactions.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BLOCK/overview/#error-handling","title":"Error Handling:","text":"<ul> <li>Ensure that assertions do not lead to DoS by carefully checking conditions and ensuring that failures are handled appropriately, rather than causing reverts that impact overall system availability.</li> <li>Protect against DoS due to unexpected reverts by considering all possible failure scenarios in the contract's logic and providing proper fallback solutions.</li> <li>Ensure functions like <code>supportsERC165InterfaceUnchecked()</code> in the ERC165Checker.sol handle large data queries efficiently, minimizing the risk of resource exhaustion.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/","title":"SCSTG-TEST-0009: Blockchain Data and State Management","text":"","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#description","title":"Description","text":"<p>Effective management of blockchain data and state is crucial for ensuring the consistency and security of decentralized applications. Poor state management can lead to data corruption, inconsistencies between contracts, and vulnerabilities that attackers can exploit. Ensuring that data changes are properly tracked, validated, and secure is key to maintaining the integrity of the system. This includes ensuring that sensitive data is not exposed, and that critical functions such as state transitions are properly handled. This test focuses on validating that smart contracts effectively manage their state and data in a secure and robust manner.</p>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#test-1-validate-proper-use-of-storage-variables","title":"Test 1: Validate Proper Use of Storage Variables","text":"","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#vulnerable-code","title":"Vulnerable Code","text":"<pre><code>contract DataStorage {\n    uint256 public value;\n\n    function updateValue(uint256 newValue) public {\n        value = newValue;\n    }\n}\n</code></pre>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The contract directly updates the state variable <code>value</code> without validating or securing the transaction, exposing the contract to potential manipulation.  </li> <li>If <code>newValue</code> is provided by an untrusted user, it could lead to data corruption or loss of value.</li> </ul>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#fixed","title":"Fixed:","text":"<pre><code>contract SecureDataStorage {\n    uint256 public value;\n\n    modifier onlyAuthorized() {\n        require(msg.sender == tx.origin, \"Unauthorized\");\n        _;\n    }\n\n    function updateValue(uint256 newValue) public onlyAuthorized {\n        value = newValue;\n    }\n}\n</code></pre>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Ensure that state variables are updated only through validated functions, and that access to sensitive operations is restricted through appropriate access controls.</li> <li>Testing: Test the contract by submitting values from different sources and verify that the state is only updated when appropriate conditions are met.</li> </ul>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#test-2-ensure-proper-validation-of-external-data-inputs","title":"Test 2: Ensure Proper Validation of External Data Inputs","text":"","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#vulnerable-code_1","title":"Vulnerable Code","text":"<pre><code>contract ExternalData {\n    uint256 public externalValue;\n\n    function updateExternalData(address oracle) public {\n        externalValue = oracle.call(\"getData()\");  // Unsafe call\n    }\n}\n</code></pre>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#why-its-vulnerable_1","title":"Why It\u2019s Vulnerable","text":"","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#example-2-unsecured-external-data-sources","title":"Example 2: Unsecured External Data Sources","text":"<ul> <li>The contract calls external data sources without validating the data properly, allowing attackers to feed false or malicious data.  </li> <li>The <code>oracle.call()</code> method exposes the contract to arbitrary external calls, which could result in unintended consequences.</li> </ul>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#fixed_1","title":"Fixed:","text":"<pre><code>contract SecureExternalData {\n    uint256 public externalValue;\n    address public oracle;\n\n    modifier onlyOracle() {\n        require(msg.sender == oracle, \"Unauthorized\");\n        _;\n    }\n\n    constructor(address _oracle) {\n        oracle = _oracle;\n    }\n\n    function updateExternalData() public onlyOracle {\n        externalValue = IOracle(oracle).getData();  // Safe interaction with oracle interface\n    }\n}\n</code></pre>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#how-to-check_1","title":"How to Check","text":"<ul> <li>Code Review: Look for external contract calls and ensure that proper validation mechanisms (e.g., access control and data validation) are in place.</li> <li>Dynamic Testing: Attempt to feed invalid or malicious data to the contract and verify that it rejects the input or fails gracefully.</li> </ul>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#test-3-prevent-data-inconsistencies-through-proper-event-logging","title":"Test 3: Prevent Data Inconsistencies Through Proper Event Logging","text":"","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#vulnerable-code_2","title":"Vulnerable Code","text":"<pre><code>contract InconsistentState {\n    uint256 public data;\n\n    function setData(uint256 newData) public {\n        data = newData;\n        // No event emitted\n    }\n}\n</code></pre>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#why-its-vulnerable_2","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The contract does not emit events after updating the state, leading to a lack of transparency and difficulty tracking state changes.  </li> <li>The absence of events makes it harder to detect inconsistencies or malicious changes to the data.</li> </ul>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#fixed_2","title":"Fixed:","text":"<pre><code>contract ConsistentState {\n    uint256 public data;\n\n    event DataUpdated(uint256 newData);\n\n    function setData(uint256 newData) public {\n        data = newData;\n        emit DataUpdated(newData);  // Emits event on state change\n    }\n}\n</code></pre>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/SCSTG-TEST-0009/#how-to-check_2","title":"How to Check","text":"<ul> <li>Code Review: Ensure that important state changes and data updates are accompanied by event emissions to track changes and ensure consistency.</li> <li>Testing: Monitor the contract\u2019s events and check that critical operations such as state changes are logged correctly.</li> </ul>","tags":["test","SCSVS-BRIDGE-1","SCSVS-BRIDGE"]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/","title":"Blockchain Data and State Management","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#description","title":"Description","text":"<p>Blockchain data and state management involve securely handling, storing, and accessing information within smart contracts. This includes managing on-chain state, protecting sensitive data, and ensuring that logged events are accurate and tamper-proof. Mismanagement in any of these areas can lead to inefficiencies, data breaches, or vulnerabilities, undermining the contract\u2019s security and usability.</p> <p>Key concerns in this domain include:</p> <ol> <li>State Management: Ensuring that smart contracts handle state transitions efficiently and securely.</li> <li>Data Privacy: Protecting sensitive user information through encryption, zero-knowledge proofs, or private transaction mechanisms.</li> <li>Event Logging: Maintaining reliable and secure logging practices to ensure transparency without exposing sensitive information.</li> <li>Decentralized Storage: Utilizing off-chain storage solutions like IPFS or Arweave securely and efficiently.</li> </ol>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#example-inefficient-state-management","title":"Example: Inefficient State Management","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract InefficientStateManagement {\n    uint256[] public largeArray;\n\n    // Adds elements to the array\n    function addElements(uint256[] memory elements) public {\n        for (uint256 i = 0; i &lt; elements.length; i++) {\n            largeArray.push(elements[i]);\n        }\n    }\n\n    // Removes elements from the array inefficiently\n    function removeElement(uint256 index) public {\n        require(index &lt; largeArray.length, \"Index out of bounds\");\n        // Inefficient removal that shifts all elements\n        for (uint256 i = index; i &lt; largeArray.length - 1; i++) {\n            largeArray[i] = largeArray[i + 1];\n        }\n        largeArray.pop();\n    }\n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#analysis","title":"Analysis:","text":"<ol> <li> <p>Inefficient Loops:    The <code>addElements</code> and <code>removeElement</code> functions involve iterating over large arrays. These loops consume a significant amount of gas, particularly for large datasets, potentially causing transactions to exceed the block gas limit and fail.</p> </li> <li> <p>State Bloat:    Continuously growing the <code>largeArray</code> without mechanisms to manage its size increases on-chain storage. This leads to unnecessary state bloat and higher costs for future interactions.</p> </li> <li> <p>Error Handling:    The <code>require</code> statement for <code>index</code> is insufficient for protecting against misuse. The function does not handle scenarios where the array size changes mid-transaction due to reentrancy or other unexpected issues.</p> </li> </ol>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#example-exposed-sensitive-data","title":"Example: Exposed Sensitive Data","text":"<pre><code>// Example of sensitive data exposure\npragma solidity ^0.8.0;\n\ncontract DataPrivacy {\n    mapping(address =&gt; uint256) private balances;\n\n    event UserBalance(address indexed user, uint256 balance);\n\n    // Logs user balance\n    function logBalance() public {\n        emit UserBalance(msg.sender, balances[msg.sender]);\n    }\n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#analysis_1","title":"Analysis:","text":"<ol> <li> <p>Sensitive Data Exposure:    The <code>logBalance</code> function emits an event that includes a user\u2019s balance. While useful for transparency, it exposes sensitive financial information publicly, violating user privacy.</p> </li> <li> <p>Lack of Encryption:    Sensitive data is logged in plaintext, making it readable to anyone inspecting the blockchain. This is a critical privacy concern for applications requiring confidentiality.</p> </li> </ol>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#impact","title":"Impact","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#inefficient-state-management","title":"Inefficient State Management","text":"<ul> <li>High Gas Costs: Unoptimized loops and storage usage result in excessive gas consumption.</li> <li>Transaction Failures: Increased likelihood of exceeding gas limits, causing failed transactions.</li> <li>Scalability Issues: Long-term scalability is affected by state bloat due to inefficient data handling.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#data-privacy-risks","title":"Data Privacy Risks","text":"<ul> <li>Privacy Violations: Unauthorized access to sensitive information compromises user privacy.</li> <li>Erosion of Trust: Users may lose confidence in the platform due to exposed confidential data.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#event-logging-vulnerabilities","title":"Event Logging Vulnerabilities","text":"<ul> <li>Public Exposure: Confidential data may be inadvertently exposed through events.</li> <li>Audit Challenges: Poorly designed events make debugging and auditing difficult.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#storage-risks","title":"Storage Risks","text":"<ul> <li>Data Mismanagement: Misconfigured off-chain storage solutions can lead to data loss or unauthorized access.</li> <li>Reduced Decentralization: Reliance on centralized gateways undermines the benefits of decentralization.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#remediation","title":"Remediation","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#efficient-state-management","title":"Efficient State Management","text":"<ul> <li>Optimize functions to minimize gas usage, particularly for operations involving arrays or mappings.</li> <li>Avoid unbounded loops or large dynamic arrays to reduce gas costs and state size.</li> <li>Implement batching, pagination, or off-chain computation for processing large datasets.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#data-privacy","title":"Data Privacy","text":"<ul> <li>Encrypt sensitive data before storing or transmitting it.</li> <li>Leverage privacy-preserving technologies like zero-knowledge proofs to securely verify without exposing underlying data.</li> <li>Use private transactions or confidential contracts for operations involving sensitive information.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#event-logging","title":"Event Logging","text":"<ul> <li>Avoid logging sensitive data in plaintext. Instead, use hashed or anonymized data when necessary.</li> <li>Design logging mechanisms that balance the need for transparency with privacy concerns.</li> <li>Regularly analyze logs to identify anomalies or vulnerabilities.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-BRIDGE/overview/#decentralized-storage","title":"Decentralized Storage","text":"<ul> <li>Use secure, decentralized storage solutions such as IPFS or Arweave for handling large or off-chain data.</li> <li>Implement redundancy and access control mechanisms to safeguard against data loss or unauthorized access.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/","title":"SCSTG-TEST-0010: Test Compiler Version and Deprecated Functions","text":"","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#description","title":"Description","text":"<p>Proper management of development policies, secure coding standards, code clarity, and test coverage ensures that smart contracts are secure, maintainable, and resilient to vulnerabilities. This test focuses on ensuring adherence to best practices and guidelines for developing and reviewing smart contracts. This includes the use of current compilers, avoiding deprecated functions, thorough code reviews, and ensuring proper test coverage. Code clarity is also critical for maintaining contracts over time and ensuring they remain understandable and auditable.</p>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#test-1-verify-compiler-version-and-avoid-deprecated-functions","title":"Test 1: Verify Compiler Version and Avoid Deprecated Functions","text":"","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#vulnerable-code","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract Example {\n    uint256 public value;\n\n    function setValue(uint256 _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The contract uses an outdated compiler version (^0.4.0). Using old versions of Solidity may lead to known security vulnerabilities and lack of support for modern features.</li> <li>Older compiler versions also lack optimizations and security fixes that are available in newer versions.</li> </ul>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#fixed","title":"Fixed:","text":"<pre><code>pragma solidity ^0.8.0;  // Update to the latest stable version\n\ncontract Example {\n    uint256 public value;\n\n    function setValue(uint256 _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Ensure that the pragma directive specifies an up-to-date version of Solidity (e.g., ^0.8.x) and not outdated ones such as ^0.4.x.</li> <li>Automated Check: Use Solidity linting tools or automated CI/CD pipelines to flag usage of outdated compiler versions.</li> </ul>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#test-2-ensure-code-review-processes-and-avoid-deprecated-functions","title":"Test 2: Ensure Code Review Processes and Avoid Deprecated Functions","text":"","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#vulnerable-code_1","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.4.24;\n\ncontract Token {\n    string public name = \"Token\";\n    uint public totalSupply = 1000000;\n\n    // Deprecated function in Solidity 0.4.x\n    function transfer(address recipient, uint amount) public {\n        require(msg.sender != recipient, \"Cannot transfer to yourself\");\n        require(amount &lt;= totalSupply, \"Amount exceeds total supply\");\n\n        totalSupply -= amount;\n        // Deprecated: The transfer method below is obsolete\n        recipient.transfer(amount);\n    }\n}\n</code></pre>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#why-its-vulnerable_1","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The function transfer in the above example uses a deprecated <code>transfer()</code> method to send Ether to the recipient.</li> <li>The <code>transfer()</code> method was removed in Solidity 0.5.x, and it\u2019s recommended to use <code>call()</code> instead to prevent errors due to changes in gas limits and transfer behavior in newer Solidity versions.</li> <li>Using deprecated functions can make your contract incompatible with future versions of Solidity and leave it vulnerable to unexpected behavior.</li> </ul>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#fixed-code","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract Token {\n    string public name = \"Token\";\n    uint public totalSupply = 1000000;\n\n    function transfer(address payable recipient, uint amount) public {\n        require(msg.sender != recipient, \"Cannot transfer to yourself\");\n        require(amount &lt;= totalSupply, \"Amount exceeds total supply\");\n\n        totalSupply -= amount;\n        // Replaced deprecated transfer method with call to ensure proper handling\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n</code></pre>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#why-the-fix-works","title":"Why the Fix Works","text":"<ul> <li>The updated code uses the <code>call()</code> method instead of the deprecated <code>transfer()</code> method to send Ether.</li> <li>The <code>call()</code> method is more flexible and is recommended in Solidity 0.5.x and later, as it allows specifying gas and properly handling errors.</li> <li>This change ensures that the contract is compatible with newer Solidity versions (&gt;=0.5.x) and avoids potential issues with future upgrades.</li> </ul>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/SCSTG-TEST-0010/#how-to-check_1","title":"How to Check","text":"<ul> <li>Code Review: Ensure the contract is not using any deprecated or obsolete functions. Look for any <code>transfer()</code>, <code>send()</code>, or other outdated methods, and replace them with the more secure <code>call()</code> method when sending Ether.</li> <li>Static Analysis Tools: Use tools like SolidityScan, MythX, Slither, or linters to detect deprecated features and provide suggestions for updating the code.</li> <li>Testing: Test the contract using the latest Solidity version and verify that no deprecated functions are used, ensuring compatibility with newer compilers.</li> </ul>","tags":["test","SCSVS-CODE-2","SCSVS-CODE"]},{"location":"SCSTG/tests/SCSVS-CODE/overview/","title":"Policies, Procedures, and Code Management","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-CODE/overview/#description","title":"Description","text":"<p>Policies, procedures, and code management play a crucial role in ensuring the security, maintainability, and scalability of smart contracts. Proper development practices, such as secure coding standards, thorough code reviews, and consistent documentation, are essential for preventing vulnerabilities and ensuring smooth development workflows. Without these practices, smart contracts may become difficult to manage, error-prone, or vulnerable to security exploits.</p> <p>This section covers best practices in secure coding standards, code review processes, code clarity, and comprehensive testing to reduce vulnerabilities and improve the quality of the codebase.</p> <p>Example: Code With Redundant or Dead Code</p> <pre><code>// Example: Code with redundant, duplicated, or dead code\nfunction transfer(address recipient, uint256 amount) public {\n    // Redundant code: balance is checked twice\n    require(balanceOf[msg.sender] &gt;= amount, \"Insufficient balance\");\n    balanceOf[msg.sender] -= amount;\n    balanceOf[recipient] += amount;\n    // Dead code: This line will never be reached\n    if (amount == 0) {\n        revert(\"Cannot transfer zero amount\");\n    }\n    emit Transfer(msg.sender, recipient, amount);\n}\n</code></pre> <p>In the above example, the check for <code>amount == 0</code> is redundant because the first <code>require</code> statement ensures that the sender has enough balance to make the transfer. Also, if <code>amount == 0</code>, the transaction would revert due to the <code>require</code> check, making the second check unnecessary. Additionally, the <code>revert(\"Cannot transfer zero amount\")</code> will never be executed because of the earlier revert.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-CODE/overview/#impact","title":"Impact","text":"<ul> <li>Code Redundancy: Redundant checks or logic lead to unnecessary computations and increased gas costs. This can also introduce confusion about the intended behavior of the contract, making it harder to maintain and audit.</li> <li>Dead Code: Unreachable or unnecessary code bloats the contract, making it more complex and increasing the risk of errors or vulnerabilities. It can also lead to wasted gas when the contract executes, as unused code still contributes to the overall execution cost.</li> <li>Security Risks: Redundant or dead code may hide actual vulnerabilities and complicate the auditing process, making it easier for attackers to find and exploit flaws.</li> <li>Maintainability Issues: The presence of redundant or dead code makes the contract harder to maintain and extend, as developers may waste time debugging or managing parts of the code that do not affect the system's functionality.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-CODE/overview/#remediation","title":"Remediation","text":"<ul> <li>Remove Redundant and Dead Code: Perform regular code reviews and refactor contracts to eliminate redundant or dead code. This reduces complexity and ensures that the contract remains efficient and understandable.</li> <li>Keep Logic Simple and Clear: Avoid unnecessary checks or repeated logic that can be handled by existing conditions or functions. Keep the contract logic as simple and clear as possible to minimize the chance of introducing errors.</li> <li>Optimize Gas Costs: Removing unnecessary logic reduces gas consumption, making the contract more cost-effective for users and improving overall network performance.</li> <li>Use Automated Tools: Implement static analysis tools and linters to detect redundant or dead code, helping to streamline the codebase and enforce best practices.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMM/SCSTG-TEST-0011/","title":"SCSTG-TEST-0011: Test Contract Interactions","text":"","tags":["test","SCSVS-COMM-1","SCSVS-COMM"]},{"location":"SCSTG/tests/SCSVS-COMM/SCSTG-TEST-0011/#description","title":"Description","text":"<p>Ensuring secure interactions and communications in smart contracts is crucial for protecting against unauthorized access, manipulation, and attacks. This includes ensuring that contracts interact securely with external contracts, manage oracle integrations safely, and use secure methods for cross-chain and bridge operations. A failure to adhere to best practices for these interactions can expose the contract to vulnerabilities such as reentrancy, front-running, or incorrect data feeds. This test focuses on validating that smart contracts perform secure interactions and communications, safeguarding the system from common attack vectors.</p>","tags":["test","SCSVS-COMM-1","SCSVS-COMM"]},{"location":"SCSTG/tests/SCSVS-COMM/SCSTG-TEST-0011/#test-1-ensure-secure-contract-interactions","title":"Test 1: Ensure Secure Contract Interactions","text":"","tags":["test","SCSVS-COMM-1","SCSVS-COMM"]},{"location":"SCSTG/tests/SCSVS-COMM/SCSTG-TEST-0011/#vulnerable-code","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.5.0;\n\ncontract VulnerableContract {\n    address public trustedAddress;\n\n    constructor(address _trustedAddress) public {\n        trustedAddress = _trustedAddress;\n    }\n\n    function callExternalContract(address _to, uint256 _value) public {\n        _to.call{value: _value}(\"\"); // Vulnerable to reentrancy or other attacks\n    }\n}\n</code></pre>","tags":["test","SCSVS-COMM-1","SCSVS-COMM"]},{"location":"SCSTG/tests/SCSVS-COMM/SCSTG-TEST-0011/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The contract uses <code>.call</code> to make external calls, which is generally unsafe and susceptible to reentrancy attacks.</li> <li>The function allows anyone to trigger the call and transfer funds, exposing the contract to potential attacks.</li> </ul>","tags":["test","SCSVS-COMM-1","SCSVS-COMM"]},{"location":"SCSTG/tests/SCSVS-COMM/SCSTG-TEST-0011/#fixed-code","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SecureContract {\n    address public trustedAddress;\n\n    constructor(address _trustedAddress) {\n        trustedAddress = _trustedAddress;\n    }\n\n    function callExternalContract(address _to, uint256 _value) public {\n        require(_to != address(0), \"Invalid address\");\n        (bool success, ) = _to.call{value: _value}(\"\");\n        require(success, \"External call failed\");\n    }\n}\n</code></pre>","tags":["test","SCSVS-COMM-1","SCSVS-COMM"]},{"location":"SCSTG/tests/SCSVS-COMM/SCSTG-TEST-0011/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Look for external calls in the contract and ensure that they are using safe methods such as <code>transfer</code> or <code>send</code> where appropriate, or implementing reentrancy protection.</li> <li>Static Analysis: Use static analysis tools like SolidityScan, MythX or Slither to detect unsafe calls in the code.</li> <li>Dynamic Testing: Simulate a reentrancy attack by deploying a contract that calls the vulnerable contract and tries to drain funds.</li> </ul>","tags":["test","SCSVS-COMM-1","SCSVS-COMM"]},{"location":"SCSTG/tests/SCSVS-COMM/overview/","title":"Unchecked External Calls in Smart Contracts","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-COMM/overview/#description","title":"Description","text":"<p>Unchecked external calls occur when a smart contract makes an external call to another contract or address without verifying the call's outcome. In Ethereum, external calls may fail silently, and the calling contract may mistakenly proceed as if the call succeeded. This leads to state inconsistencies and potential exploitation. The issue is particularly risky in functions like delegatecall, send, or call, where the outcome must be explicitly checked.</p> <p>Example: Code Without Proper Access Control</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Proxy {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function forward(address callee, bytes _data) public {\n        require(callee.delegatecall(_data)); // Unchecked external call vulnerability\n    }\n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMM/overview/#impact","title":"Impact","text":"<ul> <li>When external calls fail and their results are unchecked, the contract can proceed under incorrect assumptions, leading to potential loss of funds or other unexpected behaviors.</li> <li>Unverified external calls can lead to incorrect updates to the contract state, making it vulnerable to exploits and logical inconsistencies.</li> <li>Attackers can manipulate such vulnerabilities to execute malicious code or withdraw funds multiple times.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMM/overview/#remediation","title":"Remediation","text":"<ul> <li>Use safer methods such as transfer() over send() when transferring Ether. The transfer() function reverts automatically if the call fails.</li> <li>For low-level functions like call and delegatecall, always check the return value and handle failures appropriately.</li> <li>Limit interactions with untrusted contracts and ensure robust validation before performing critical operations.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMP/SCSTG-TEST-0012/","title":"SCSTG-TEST-0012: Test Token Implementations (ERC20, ERC721, ERC1155)","text":"","tags":["test","SCSVS-COMP-1","SCSVS-COMP"]},{"location":"SCSTG/tests/SCSVS-COMP/SCSTG-TEST-0012/#description","title":"Description","text":"<p>Component-Specific Security focuses on ensuring that each specific component of a decentralized application (dApp) or smart contract ecosystem is securely implemented. This includes a wide range of areas such as token standards (ERC20, ERC721, ERC1155), NFTs, vaults, liquidity pools, and other components. Properly securing these components is essential to avoid vulnerabilities that can lead to funds being stolen, lost, or misused. This test will focus on validating the security considerations for the components listed in the controls, ensuring that each one is implemented securely and with the appropriate mechanisms to protect users and assets.</p>","tags":["test","SCSVS-COMP-1","SCSVS-COMP"]},{"location":"SCSTG/tests/SCSVS-COMP/SCSTG-TEST-0012/#test-ensure-proper-token-implementation-erc20-erc721-erc1155","title":"Test: Ensure Proper Token Implementation (ERC20, ERC721, ERC1155)","text":"","tags":["test","SCSVS-COMP-1","SCSVS-COMP"]},{"location":"SCSTG/tests/SCSVS-COMP/SCSTG-TEST-0012/#vulnerable-code","title":"**Vulnerable Code: **","text":"<pre><code>pragma solidity ^0.5.0;\n\ncontract SimpleERC20 {\n    mapping(address =&gt; uint256) public balanceOf;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;\n\n    string public name = \"Simple Token\";\n    string public symbol = \"STK\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n\n    // Unchecked approve function (vulnerable to approval race condition)\n    function approve(address spender, uint256 amount) public returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        return true;\n    }\n}\n</code></pre>","tags":["test","SCSVS-COMP-1","SCSVS-COMP"]},{"location":"SCSTG/tests/SCSVS-COMP/SCSTG-TEST-0012/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The <code>approve</code> function does not include a check for the current allowance before setting a new one, which could allow for the \"approval race condition.\" This can result in a vulnerability where an attacker could bypass the allowance mechanism and transfer more tokens than intended.  </li> <li>This issue is a well-known vulnerability in ERC20 token implementations.</li> </ul>","tags":["test","SCSVS-COMP-1","SCSVS-COMP"]},{"location":"SCSTG/tests/SCSVS-COMP/SCSTG-TEST-0012/#fixed-code","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SafeERC20 {\n    mapping(address =&gt; uint256) public balanceOf;\n    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;\n\n    string public name = \"Safe Token\";\n    string public symbol = \"STK\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n\n    // Secure approve function to prevent race condition\n    function approve(address spender, uint256 amount) public returns (bool) {\n        require(amount == 0 || allowance[msg.sender][spender] == 0, \"Approve: non-zero allowance\");\n        allowance[msg.sender][spender] = amount;\n        return true;\n    }\n}\n</code></pre>","tags":["test","SCSVS-COMP-1","SCSVS-COMP"]},{"location":"SCSTG/tests/SCSVS-COMP/SCSTG-TEST-0012/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Look for the <code>approve</code> function in token contracts and ensure that it includes the necessary checks to prevent the race condition. The secure approach is to first set the allowance to zero before updating it to a new value, or to require that it is zero if being reset.</li> <li>Static Analysis: Use tools such as SolidityScan, MythX or Slither to check for the \"approval race condition\" and ensure the contract doesn't allow for this vulnerability.</li> <li>Dynamic Testing: Test token transfer functionality with edge cases where the allowance is set to non-zero values before calling <code>approve</code>. Verify that it works correctly and no unauthorized transfers are possible.</li> </ul>","tags":["test","SCSVS-COMP-1","SCSVS-COMP"]},{"location":"SCSTG/tests/SCSVS-COMP/overview/","title":"Component-Specific Security","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-COMP/overview/#description","title":"Description","text":"<p>Component-specific security focuses on the proper implementation and management of individual components in a smart contract ecosystem, such as tokens, NFTs, vaults, staking mechanisms, and liquidity pools. Each component has unique security considerations that must be addressed to prevent vulnerabilities and ensure smooth, secure operations within the broader system. These components often interact with each other, so it's critical to ensure that each is implemented correctly and adheres to established standards to avoid risks such as inconsistent balances, unintended behavior, and attacks.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMP/overview/#example-erc20-token-security","title":"Example: ERC20 Token Security","text":"<pre><code>// Example: Implementing ERC20 token with minting and transfers\ncontract MyToken is ERC20 {\n    uint256 public totalSupply;\n\n    function mint(address to, uint256 amount) public {\n        totalSupply += amount;  // Ensure total supply is updated securely\n        _mint(to, amount);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        require(amount &gt; 0, \"Cannot transfer zero amount\");\n        return super.transfer(recipient, amount);\n    }\n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMP/overview/#component-specific-security","title":"Component-Specific Security","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-COMP/overview/#impact","title":"Impact","text":"<ul> <li>Token Vulnerabilities: Incorrect implementation of ERC20, ERC721, or ERC1155 tokens can lead to unexpected behavior, such as incorrect balances, inability to transfer tokens, or incompatible integrations with other dApps or services.</li> <li>NFT Security: Poorly implemented NFTs can lead to issues with metadata integrity, unauthorized minting, or unauthorized transfers, impacting the uniqueness and value of NFTs.</li> <li>Vault Risks: Issues related to asset management in vaults, such as stETH or wstETH, can cause delays in withdrawals or inconsistencies in the handling of token balances due to rebasing or other complex mechanisms.</li> <li>Liquid Staking Issues: Vulnerabilities in staking mechanisms (e.g., sfrxETH/fraxETH) could lead to discrepancies in rewards or affect the overall staking rewards distribution.</li> <li>Liquidity Pool Exploits: Automated market makers (AMMs) can be exploited if their logic is insecure, particularly regarding slippage, transaction fees, or impermanent loss calculations.</li> <li>Uniswap V4 Hook Vulnerabilities: Incorrect integration or usage of Uniswap's TickMath and FullMath libraries can introduce overflow or underflow issues, leading to unpredictable behavior or contract failures.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMP/overview/#remediation","title":"Remediation","text":"<ul> <li>Token Security: Ensure compliance with token standards such as ERC20, ERC721, and ERC1155. Properly manage the total supply and token addresses. Avoid zero-amount transfers causing issues and ensure compatibility with other contracts or integrations.</li> <li>NFT Best Practices: Implement strong standards for creating, managing, and transferring NFTs. Ensure metadata integrity and safeguard against unauthorized minting and transfers. Secure royalty payments and token burns to prevent exploitative behavior.</li> <li>Vault Management: Address potential withdrawal overheads and ensure efficient handling of assets such as stETH and wstETH. Take care when converting between rebasing tokens to avoid discrepancies.</li> <li>Staking Mechanisms: Regularly monitor and secure liquid staking mechanisms. Prevent discrepancies in reward transfers and ensure proper communication with users about potential changes, especially in the rate of tokens like sfrxETH.</li> <li>Liquidity Pool Security: Secure the logic in automated market makers, especially for managing slippage and ensuring fair fee distributions. Ensure that the AMM is protected against known exploits and attacks.</li> <li>Uniswap V4 Integration: Follow best practices for integrating Uniswap's TickMath and FullMath libraries, ensuring safe handling of arithmetic operations and proper validation to prevent overflow or underflow issues.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-COMP/overview/#types-of-vulnerabilities-that-can-occur-in-this-category","title":"Types of Vulnerabilities That Can Occur in This Category","text":"<ul> <li>Token Minting Inconsistencies: Incorrect updates to the totalSupply or failure to manage token addresses properly can cause inconsistencies and errors in token transactions.</li> <li>Unauthorized NFT Actions: Lack of metadata integrity or vulnerabilities in transfer mechanisms can result in unauthorized minting, transfers, or sales of NFTs.</li> <li>Vault Management Flaws: Issues like long withdrawal times or improper handling of rebasing assets can impact user experience and cause financial loss.</li> <li>Staking Discrepancies: Vulnerabilities in staking reward mechanisms or incorrect handling of rate changes can undermine user confidence and token stability.</li> <li>Liquidity Pool Exploits: Flaws in AMM contract logic, such as improper slippage management or failure to account for impermanent loss, can lead to loss of funds.</li> <li>Arithmetic Errors in Uniswap V4 Hooks: Insecure arithmetic operations using Uniswap's libraries can result in overflow/underflow vulnerabilities, affecting the stability and reliability of liquidity pools.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/","title":"SCSTG-TEST-0013: Secure Signature Verification","text":"","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#description","title":"Description","text":"<p>Cryptographic practices are essential in ensuring the confidentiality, integrity, and authenticity of interactions within decentralized systems. Weaknesses in cryptographic implementations, key management, or signature verification can lead to vulnerabilities such as unauthorized access, data manipulation, or attacks that compromise the security of transactions. This test focuses on verifying secure cryptographic practices, including key management, signature verification, and secure random number generation in smart contracts.</p>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#test-1-verify-secure-signature-verification","title":"Test 1: Verify Secure Signature Verification","text":"","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#vulnerable-code","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SignatureVerification {\n    function verifySignature(address _signer, bytes32 _message, bytes memory _signature) public pure returns (bool) {\n        // Directly using ecrecover, without checking for message format, leads to potential attack vectors\n        address recovered = ecrecover(_message, uint8(_signature[0]), bytes32(_signature[1]), bytes32(_signature[2]));\n        return recovered == _signer;\n    }\n}\n</code></pre>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The contract uses <code>ecrecover</code> directly without verifying the message structure.</li> <li>Attackers could use a replay attack by reusing the signature from another message to authenticate different transactions.</li> <li>The lack of proper checks makes the contract vulnerable to attacks where the attacker can forge or replay signatures.</li> </ul>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#fixed-code","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SecureSignatureVerification {\n    // Use of EIP-712 for standard signature verification with specific message formats\n    function verifySignature(address _signer, bytes32 _message, bytes memory _signature) public pure returns (bool) {\n        bytes32 messageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _message));\n        address recovered = ecrecover(messageHash, uint8(_signature[0]), bytes32(_signature[1]), bytes32(_signature[2]));\n        return recovered == _signer;\n    }\n}\n</code></pre>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Verify that signatures are being properly validated using standards like EIP-712, and that the contract uses <code>ecrecover</code> securely. Ensure that messages are hashed and prefixed correctly before recovery.</li> <li>Dynamic Testing: Test with replayed or malformed signatures to verify that the contract rejects such transactions.</li> </ul>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#vulnerable-code_1","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract RandomNumberGenerator {\n    uint256 public randomValue;\n\n    function generateRandomNumber() public {\n        randomValue = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)));\n    }\n}\n</code></pre>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#why-its-vulnerable_1","title":"Why It\u2019s Vulnerable","text":"<ul> <li>The contract uses block properties like <code>block.timestamp</code> and <code>block.difficulty</code> to generate random numbers, which can be manipulated by miners or validators.</li> <li>This weak random number generation can lead to predictable values, making the contract vulnerable to attacks such as manipulation of lottery or gambling outcomes.</li> </ul>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#fixed-code_1","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SecureRandomNumberGenerator {\n    uint256 public randomValue;\n\n    function generateRandomNumber() public {\n        // Using Chainlink VRF for secure and verifiable randomness\n        randomValue = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)));\n    }\n}\n</code></pre>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/SCSTG-TEST-0013/#how-to-check_1","title":"How to Check","text":"<ul> <li>Code Review: Ensure that random numbers are not derived from predictable values like block properties. Check if external secure sources like <code>Chainlink VRF</code> are being used for randomness.</li> <li>Dynamic Testing: Test contract behavior under adversarial conditions to ensure the randomness cannot be predicted or manipulated.</li> </ul>","tags":["test","SCSVS-CRYPTO-2","SCSVS-CRYPTO"]},{"location":"SCSTG/tests/SCSVS-CRYPTO/overview/","title":"Cryptographic Practices","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-CRYPTO/overview/#description","title":"Description","text":"<p>Cryptographic practices in smart contracts ensure that sensitive operations, such as authentication, data integrity, and randomness, are protected from malicious manipulation. Secure key management, signature verification, and proper random number generation are essential to prevent vulnerabilities like unauthorized access, replay attacks, and exploitation of weaknesses in cryptographic operations.</p> <p>Improper cryptographic practices can lead to severe consequences, including unauthorized transactions, predictable outcomes, and security breaches.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-CRYPTO/overview/#example-improper-signature-verification","title":"Example: Improper Signature Verification","text":"<pre><code>function verifySignature(address signer, bytes32 message, bytes memory signature) public pure returns (bool) {\n    bytes32 messageHash = keccak256(abi.encodePacked(message));\n    address recoveredSigner = ecrecover(messageHash, uint8(signature[64]), bytes32(signature[0]), bytes32(signature[32]));\n    return recoveredSigner == signer;\n}\n</code></pre> <p>In this example, the <code>ecrecover</code> function is used without ensuring that the signature is valid, which may lead to vulnerabilities like signature malleability or invalid data recovery.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-CRYPTO/overview/#impact","title":"Impact","text":"<ul> <li>Unauthorized Access: Weak cryptographic practices can allow attackers to forge signatures or impersonate users, leading to unauthorized actions within the contract.</li> <li>Reentrancy Attacks: If cryptographic functions are used to validate external calls, attackers could exploit weak or improperly implemented logic to re-enter the contract.</li> <li>Manipulation of Outcomes: Predictable or weak random number generation could allow attackers to manipulate outcomes in systems relying on randomness, such as lotteries or gaming dApps.</li> <li>Replay Attacks: Insufficient signature validation can result in replay attacks where signed messages are reused across different contexts, allowing attackers to perform unintended actions.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-CRYPTO/overview/#remediation","title":"Remediation","text":"<ul> <li>Key Management: Ensure that private keys are securely stored, never hardcoded in contracts, and use hardware solutions for key management.</li> <li>Signature Verification: Implement proper checks for signature validity, including handling signature malleability by using nonces or hashed messages.</li> <li>Randomness: Use secure sources of entropy, such as Chainlink VRF (Verifiable Random Function), to ensure the randomness cannot be manipulated.</li> <li>Compliance with Standards: Ensure compliance with cryptographic standards like EIP-712 to prevent signature malleability and other vulnerabilities.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-DEFI/SCSTG-TEST-0014/","title":"SCSTG-TEST-0014: Test Gas Usage in Loops","text":"","tags":["test","SCSVS-DEFI-1","SCSVS-DEFI"]},{"location":"SCSTG/tests/SCSVS-DEFI/SCSTG-TEST-0014/#description","title":"Description","text":"<p>Efficient gas usage is critical in smart contract development to ensure transactions are cost-effective and do not exceed block gas limits. Poorly optimized contracts can result in high transaction costs, failed transactions, and potential denial of service (DoS) attacks. Optimizing gas usage helps ensure that smart contracts are scalable, cost-effective, and maintain the overall security of decentralized applications (dApps). This test focuses on ensuring that gas usage is properly optimized, and contracts are designed to operate efficiently within the constraints of Ethereum's gas limits.</p>","tags":["test","SCSVS-DEFI-1","SCSVS-DEFI"]},{"location":"SCSTG/tests/SCSVS-DEFI/SCSTG-TEST-0014/#test-1-validate-gas-usage-in-loops","title":"Test 1: Validate Gas Usage in Loops","text":"","tags":["test","SCSVS-DEFI-1","SCSVS-DEFI"]},{"location":"SCSTG/tests/SCSVS-DEFI/SCSTG-TEST-0014/#vulnerable-code","title":"Vulnerable Code","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract GasInefficient {\n    uint256[] public data;\n\n    function addData(uint256[] memory newData) public {\n        for (uint i = 0; i &lt; newData.length; i++) {\n            data.push(newData[i]);  // Inefficient loop causing high gas costs\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-DEFI-1","SCSVS-DEFI"]},{"location":"SCSTG/tests/SCSVS-DEFI/SCSTG-TEST-0014/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>This contract uses a loop to iterate over an input array and push data into a dynamic array.  </li> <li>The gas cost increases linearly with the size of the input array. For large datasets, this can lead to excessive gas usage, potentially causing the transaction to exceed the block gas limit.  </li> <li>Smart contracts with inefficient loops that grow dynamically can become unmanageable when interacting with large datasets.</li> </ul>","tags":["test","SCSVS-DEFI-1","SCSVS-DEFI"]},{"location":"SCSTG/tests/SCSVS-DEFI/SCSTG-TEST-0014/#fixed-code","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract OptimizedGas {\n    uint256[] public data;\n\n    function addData(uint256[] memory newData) public {\n        uint256 length = newData.length;\n        for (uint i = 0; i &lt; length; i++) {\n            data.push(newData[i]);  // Optimized by storing array length outside the loop\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-DEFI-1","SCSVS-DEFI"]},{"location":"SCSTG/tests/SCSVS-DEFI/SCSTG-TEST-0014/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Ensure that loops and functions which deal with dynamic data structures are optimized for gas usage. Look for unnecessary state changes or excessive iterations within a single transaction.  </li> <li>Gas Estimation: Use tools like eth-gas-reporter or Remix IDE to estimate gas usage before and after optimizations.  </li> <li>Dynamic Testing: Test the contract with various input sizes and check that it performs within reasonable gas limits, ensuring it doesn't exceed the block gas limit.</li> </ul>","tags":["test","SCSVS-DEFI-1","SCSVS-DEFI"]},{"location":"SCSTG/tests/SCSVS-DEFI/overview/","title":"Gas Usage, Efficiency, and Limitations","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-DEFI/overview/#description","title":"Description","text":"<p>Gas usage optimization in smart contracts is crucial for maintaining cost-effective, efficient, and scalable decentralized applications (dApps) on the Ethereum network. Gas represents the computational cost of executing operations in smart contracts, and minimizing gas consumption ensures that transactions are processed smoothly without hitting gas limits or incurring unnecessary costs. Understanding how to optimize gas usage and effectively design contracts is essential for reducing overhead, ensuring transaction reliability, and preventing network congestion.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-DEFI/overview/#example-code-without-gas-optimization","title":"Example: Code Without Gas Optimization","text":"<pre><code>// Example: Non-optimized contract with expensive operations\nfunction transfer(address recipient, uint256 amount) public {\n    require(balanceOf[msg.sender] &gt;= amount, \"Insufficient balance\");\n\n    balanceOf[msg.sender] -= amount;\n    balanceOf[recipient] += amount;\n\n    // Potentially costly operations (not optimized)\n    emit Transfer(msg.sender, recipient, amount);\n}\n</code></pre>","tags":[]},{"location":"SCSTG/tests/SCSVS-DEFI/overview/#impact","title":"Impact","text":"<ul> <li>High Gas Costs: Inefficient smart contracts lead to higher gas costs for users, resulting in increased transaction fees and potentially deterring interaction with the contract.</li> <li>Transaction Failures: Exceeding gas limits or inefficient use of gas can cause transactions to fail, resulting in reverted transactions and user dissatisfaction.</li> <li>Network Congestion: Unoptimized contracts can cause network congestion, especially during high traffic periods, leading to delays and higher fees.</li> <li>Scalability Limitations: As gas costs increase, the ability of the contract to handle a large number of transactions or users without hitting the gas limit is severely impacted.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-DEFI/overview/#remediation","title":"Remediation","text":"<ul> <li>Gas Usage Optimization: Use efficient algorithms and reduce the number of computations performed on-chain. Avoid unnecessary state changes, and combine multiple operations where possible. Optimize loops, storage reads/writes, and event emissions to reduce costs.</li> <li>Gas Estimation Tools: Use tools like eth_gasPrice and gasStation to estimate gas prices and set appropriate gas limits for transactions. Implement gas estimation functions within the contract to predict and optimize gas usage.</li> <li>Layer 2 Solutions: Consider integrating Layer 2 scaling solutions such as rollups or state channels to offload computation and reduce gas costs while improving transaction throughput. Validate the security and reliability of the chosen Layer 2 solutions to ensure seamless integration.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-GOV/SCSTG-TEST-0015/","title":"SCSTG-TEST-0015: Testing Business Logic and Economic Security","text":"","tags":["test","SCSVS-GOV-1","SCSVS-GOV"]},{"location":"SCSTG/tests/SCSVS-GOV/SCSTG-TEST-0015/#description","title":"Description","text":"<p>Business logic and economic security are crucial for ensuring that smart contracts function as intended and that the economic incentives align with the intended use cases. If vulnerabilities in the logic or economic models are present, attackers may exploit them for financial gain. This test focuses on reviewing economic models, incentive structures, and tokenomics to ensure that smart contracts are designed to prevent logic flaws, reentrancy attacks, and malicious economic manipulation.</p>","tags":["test","SCSVS-GOV-1","SCSVS-GOV"]},{"location":"SCSTG/tests/SCSVS-GOV/SCSTG-TEST-0015/#test-1-ensure-economic-model-integrity-and-prevent-logic-flaws","title":"Test 1: Ensure Economic Model Integrity and Prevent Logic Flaws","text":"","tags":["test","SCSVS-GOV-1","SCSVS-GOV"]},{"location":"SCSTG/tests/SCSVS-GOV/SCSTG-TEST-0015/#vulnerable-code","title":"Vulnerable Code","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract IncentiveModel {\n    uint256 public rewardPool;\n\n    function distributeRewards(address[] memory users) public {\n        uint256 reward = rewardPool / users.length;  // Dividing the total reward pool among users\n        for (uint256 i = 0; i &lt; users.length; i++) {\n            payable(users[i]).transfer(reward);\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-GOV-1","SCSVS-GOV"]},{"location":"SCSTG/tests/SCSVS-GOV/SCSTG-TEST-0015/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<ul> <li>If the <code>users</code> array is empty, the division by zero will occur, leading to a runtime exception.</li> <li>Additionally, if the reward pool is too small or the number of users is too large, it could cause unexpected behavior, leading to attackers exploiting the system by flooding the contract with too many addresses.</li> </ul>","tags":["test","SCSVS-GOV-1","SCSVS-GOV"]},{"location":"SCSTG/tests/SCSVS-GOV/SCSTG-TEST-0015/#fixed-code","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SecureIncentiveModel {\n    uint256 public rewardPool;\n\n    modifier nonZeroUsers(address[] memory users) {\n        require(users.length &gt; 0, \"No users provided\");\n        _;\n    }\n\n    function distributeRewards(address[] memory users) public nonZeroUsers(users) {\n        uint256 reward = rewardPool / users.length;\n        require(reward &gt; 0, \"Reward amount is too low\");\n        for (uint256 i = 0; i &lt; users.length; i++) {\n            payable(users[i]).transfer(reward);\n        }\n    }\n}\n</code></pre>","tags":["test","SCSVS-GOV-1","SCSVS-GOV"]},{"location":"SCSTG/tests/SCSVS-GOV/SCSTG-TEST-0015/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Look for scenarios where division or mathematical operations could result in errors like division by zero or unintended behavior due to extreme input values.</li> <li>Dynamic Testing: Test the function with edge cases such as empty user lists, very large user arrays, and reward pool sizes. Ensure that the system handles these cases gracefully and does not allow unexpected errors or exploits.</li> </ul>","tags":["test","SCSVS-GOV-1","SCSVS-GOV"]},{"location":"SCSTG/tests/SCSVS-GOV/overview/","title":"Business Logic and Economic Security","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-GOV/overview/#description","title":"Description","text":"<p>Business logic and economic security in smart contracts ensure that the contract's operational rules and the associated economic incentives are properly designed to avoid exploitation and inefficiencies. This includes defining incentive structures, ensuring the stability of token values, preventing reentrancy attacks, and making sure that the tokenomics aligns with the expected behavior of the system. Contracts must be designed to avoid logical flaws, ensure that token rewards and penalties are correctly implemented, and prevent attacks that could undermine the contract's economic model.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-GOV/overview/#example-improper-incentive-structure","title":"Example: Improper Incentive Structure","text":"<pre><code>// Push-based withdrawal process (vulnerable)\nfunction withdraw(uint256 amount) public {\n    require(balance[msg.sender] &gt;= amount, \"Insufficient balance\");\n    payable(msg.sender).transfer(amount); // Push-based transfer\n    balance[msg.sender] -= amount;\n}\n</code></pre> <p>In the example above, a push-based withdrawal system may allow for unexpected behaviors, such as reentrancy attacks or failure to properly track balances due to uncontrolled fund transfers. A better approach would be to use a pull-based system.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-GOV/overview/#impact","title":"Impact","text":"<ul> <li>Incentive Misalignment: Incorrect economic models can lead to unbalanced incentives, where users may be encouraged to behave in ways that harm the ecosystem or undermine contract objectives.</li> <li>Volatility and Losses: Fluctuating token values, such as the conversion rates between assets like cbETH and ETH, can result in user losses if not properly handled. Similarly, staking rewards, such as with rETH, can create unpredictable value changes that impact users.</li> <li>Reentrancy Attacks: Poor handling of transaction flow and state changes can allow attackers to re-enter the contract during a transaction, causing unintended consequences like double withdrawals.</li> <li>Token Vulnerabilities: Incorrect tokenomics, such as faulty fee application or flawed reward systems, can cause users to lose funds or receive incorrect rewards.</li> <li>Double-Spending and Fraud: Weak mechanisms like duplicate Merkle proofs can expose the system to double-spending attacks and other fraud mechanisms.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-GOV/overview/#remediation","title":"Remediation","text":"<ul> <li>Incentive Structures: Implement a pull-based withdrawal system rather than push-based transfers to allow for proper tracking and reduce the risk of reentrancy attacks. Ensure that all economic incentives are clearly defined and aligned with desired behaviors.</li> <li>Tokenomics and Reward Systems: Ensure that all token behaviors, including rebase mechanisms and reward claims, are properly handled. Prevent unexpected behaviors in tokens and validate that all claimable addresses are included in hashing processes to prevent unauthorized claims.</li> <li>Fluctuation Management: Develop systems that can account for fluctuations in asset values (e.g., cbETH to ETH, rETH staking rewards) and adjust accordingly to mitigate risks for users.</li> <li>Transaction Flow Security: Use patterns like check-effect-interaction to prevent reentrancy attacks, ensuring that state changes occur before external calls. Apply the NonReentrant modifier where applicable to prevent unintended recursive calls.</li> <li>Function Integrity: Ensure that functions are designed to handle edge cases, such as same sender/recipient scenarios, and that they are not callable multiple times unnecessarily, avoiding potential inconsistencies or logic flaws.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/","title":"SCSTG-TEST-0016: Testing Arithmetic and Logic Security","text":"","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#description","title":"Description","text":"<p>Preventing arithmetic overflow and underflow is critical for maintaining the integrity and security of smart contracts. If a contract performs arithmetic operations without proper safeguards, it is vulnerable to overflow and underflow issues, which can be exploited by attackers to manipulate contract behavior, causing unexpected results or loss of funds.</p>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#test-1-ensure-safe-math-operations-are-used","title":"Test 1: Ensure Safe Math Operations are Used","text":"","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#vulnerable-code","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract UnsafeMath {\n    uint256 public balance;\n\n    function addFunds(uint256 _amount) public {\n        balance += _amount;  // Possible overflow if balance + _amount exceeds max uint256 value\n    }\n}\n</code></pre>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#why-its-vulnerable","title":"Why It\u2019s Vulnerable","text":"<p>The contract does not use a safe math library to perform arithmetic operations. If the balance exceeds uint256's maximum value (2^256 - 1), an overflow occurs. This can result in unexpected contract behavior or a reset of the balance value, allowing attackers to manipulate the contract.</p>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#fixed-code","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SafeMath {\n    using SafeMath for uint256;\n    uint256 public balance;\n\n    function addFunds(uint256 _amount) public {\n        balance = balance.add(_amount);  // Safe addition using SafeMath to prevent overflow\n    }\n}\n</code></pre>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#how-to-check","title":"How to Check","text":"<ul> <li>Code Review: Check that all arithmetic operations use libraries such as SafeMath (for older versions) or rely on Solidity 0.8\u2019s built-in overflow checks.  </li> <li>Testing: Use edge cases such as adding large values to check if the contract prevents overflow.</li> </ul>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#test-2-verify-correct-use-of-fixed-point-arithmetic","title":"Test 2: Verify Correct Use of Fixed-Point Arithmetic","text":"","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#vulnerable-code_1","title":"Vulnerable Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract FixedPointExample {\n    uint256 public totalSupply;\n\n    function calculateReward(uint256 _rewardPercentage) public view returns (uint256) {\n        return totalSupply * _rewardPercentage / 100;  // Simple calculation without considering fixed-point precision\n    }\n}\n</code></pre>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#why-its-vulnerable_1","title":"Why It\u2019s Vulnerable","text":"<p>The function performs division without accounting for fixed-point precision. This could result in rounding errors, especially for small percentage values. Using integer division directly leads to truncation, causing inaccuracies in reward calculations.</p>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#fixed-code_1","title":"Fixed Code:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract FixedPointExample {\n    uint256 public totalSupply;\n    uint256 constant FIXED_POINT = 1e18;  // Set a scaling factor for fixed-point precision\n\n    function calculateReward(uint256 _rewardPercentage) public view returns (uint256) {\n        return (totalSupply * _rewardPercentage * FIXED_POINT) / 100 / FIXED_POINT;  // Proper fixed-point arithmetic\n    }\n}\n</code></pre>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/SCSTG-TEST-0016/#how-to-check_1","title":"How to Check","text":"<ul> <li>Code Review: Verify that fixed-point arithmetic is implemented using appropriate scaling factors (e.g., 1e18) to avoid precision loss.  </li> <li>Dynamic Testing: Test the function with small values for <code>_rewardPercentage</code> and check that the result is accurate, verifying that there is no unexpected rounding behavior.</li> </ul>","tags":["test","SCSVS-ORACLE-1","SCSVS-ORACLE"]},{"location":"SCSTG/tests/SCSVS-ORACLE/overview/","title":"Arithmetic and Logic Security","text":"","tags":[]},{"location":"SCSTG/tests/SCSVS-ORACLE/overview/#description","title":"Description","text":"<p>Arithmetic and logic security in smart contracts ensures that mathematical operations are performed safely and with integrity. These operations must be protected against overflows, underflows, precision loss, and other logical errors that could lead to unexpected behaviors, vulnerabilities, or financial losses. Proper handling of arithmetic operations, particularly for asset balances, time units, and fixed-point calculations, is critical for ensuring the stability and security of smart contracts. This also includes managing preconditions and postconditions to ensure correct function execution and preventing vulnerabilities such as division by zero or off-by-one errors.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-ORACLE/overview/#example-preventing-overflow-and-underflow","title":"Example: Preventing Overflow and Underflow","text":"<pre><code>// SafeMath library example to prevent overflow/underflow\nusing SafeMath for uint256;\n\nfunction transfer(uint256 amount) public {\n    require(balance[msg.sender] &gt;= amount, \"Insufficient balance\");\n    balance[msg.sender] = balance[msg.sender].sub(amount); // Safe subtraction\n    balance[recipient] = balance[recipient].add(amount);  // Safe addition\n}\n</code></pre> <p>In this example, <code>SafeMath</code> is used to protect against integer overflow and underflow, ensuring that operations on token balances are secure.</p>","tags":[]},{"location":"SCSTG/tests/SCSVS-ORACLE/overview/#impact","title":"Impact","text":"<ul> <li>Overflow/Underflow Vulnerabilities: If arithmetic operations are not properly checked, they can result in overflows or underflows, causing unexpected behavior such as funds being transferred incorrectly, variables being set to incorrect values, or transactions failing.</li> <li>Precision Loss: In fixed-point arithmetic or when performing calculations with time units, rounding errors or precision loss can lead to inaccuracies, especially when working with fractional values in tokenomics or financial systems.</li> <li>Data Corruption: Incorrect handling of data types, arrays, or structs can cause data corruption or incorrect values, potentially leading to logic flaws or vulnerabilities.</li> <li>Manipulated Calculations: If critical calculations (e.g., price or rate calculations) are not secure, attackers could exploit vulnerabilities (e.g., through flash loans) to manipulate values and disrupt the contract\u2019s logic.</li> <li>Transaction Failures: Incorrectly handled division by zero or exceeding variable bounds can lead to transaction reverts or failures, disrupting contract operations and causing loss of user funds.</li> <li>Logical Errors: Incorrect use of logical operators or off-by-one errors in loops can cause unintended contract behavior, which might open doors for exploits or cause incorrect results in financial operations.</li> </ul>","tags":[]},{"location":"SCSTG/tests/SCSVS-ORACLE/overview/#remediation","title":"Remediation","text":"<ul> <li>Overflow/Underflow Protection: Always use SafeMath or similar libraries for arithmetic operations to prevent overflow and underflow issues. Explicit type casting and operations within <code>unchecked{}</code> blocks should be carefully managed.</li> <li>Fixed-Point Arithmetic: Ensure that fixed-point arithmetic operations are conducted safely to avoid overflow, underflow, or loss of precision. Validate calculations involving fixed-point numbers to maintain accuracy.</li> <li>Secure Calculations: Ensure that price, rate, or financial calculations are protected against manipulation, especially from attacks like flash loans. Handle asset balance calculations securely to prevent vulnerabilities.</li> <li>Logical Consistency: Enforce proper rounding rules in calculations, validate inequalities and comparisons, and handle edge cases properly in logical operations.</li> <li>Pre/Post-condition Checks: Apply precondition checks to avoid invalid calculations and ensure that multiplication is performed before division to maintain precision. Validate edge cases such as minimum transaction amounts and off-by-one errors in loops.</li> <li>Correct Data Handling: Avoid unintended data type conversions or precision loss. Ensure that <code>abi.decode</code> is used within type limits to prevent overflows.</li> </ul>","tags":[]},{"location":"SCSVS/01-Frontispiece/","title":"Frontispiece","text":"","tags":[]},{"location":"SCSVS/01-Frontispiece/#about-the-standard","title":"About the Standard","text":"<p>The Smart Contract Security Verification Standard (SCSVS) is a list of specific security requirements or tests for smart contracts, primarily written in Solidity and deployed on EVM-based blockchains. These requirements are intended to be used by architects, developers, testers, security professionals, tool vendors, and consumers to define, build, test, and verify secure smart contracts, decentralized applications (dApps) and blockchain protocols. The standard promotes best practices for ensuring the security and integrity of smart contracts and decentralized finance (DeFi) systems.</p>","tags":[]},{"location":"SCSVS/01-Frontispiece/#copyright-and-license","title":"Copyright and License","text":"<p>Version 0.0.1 (Bleeding Edge version), 2024</p> <p></p> <p>Copyright \u00a9 2008-2024 The OWASP Foundation. This document is released under the Creative Commons Attribution-ShareAlike 4.0 International License. For any reuse or distribution, you must make clear to others the license terms of this work.</p>","tags":[]},{"location":"SCSVS/01-Frontispiece/#project-leads","title":"Project Leads","text":"","tags":[]},{"location":"SCSVS/01-Frontispiece/#shashank-credshields","title":"Shashank (CredShields)","text":"","tags":[]},{"location":"SCSVS/01-Frontispiece/#major-contributors-and-reviewers","title":"Major Contributors and Reviewers","text":"","tags":[]},{"location":"SCSVS/01-Frontispiece/#pratik-lagaskar","title":"Pratik Lagaskar","text":"","tags":[]},{"location":"SCSVS/01-Frontispiece/#nehal-pillai","title":"Nehal Pillai","text":"","tags":[]},{"location":"SCSVS/01-Frontispiece/#aditya-dixit","title":"Aditya Dixit","text":"<p>If a credit is missing from the 0.0.1 credit list above, please log a ticket at GitHub to be recognized in future 0.x updates.</p> <p>The Smart Contract Security Verification Standard (SCSVS) is built upon the initial research performed into smart contract security by various blockchain security experts. Much of the concept, structure, boilerplate, and tooling for the SCSVS has been adapted from the OWASP ASVS project. We extend our gratitude to all those previously involved in the OWASP ASVS for their contributions.</p>","tags":[]},{"location":"SCSVS/01-Frontispiece/#major-supporter-and-sponsor","title":"Major Supporter and Sponsor","text":"<p>This initiative would not have been possible without the support of our sponsor and the resources they have provided. We would like to express our gratitude to the following for their support.</p>","tags":[]},{"location":"SCSVS/01-Frontispiece/#credshields","title":"CredShields","text":"<p>The OWASP SCSVS project was initiated to share the knowledge gained from the CredShields Security Team's research into Smart Contract security while developing SolidityScan.com, an AI-powered vulnerability scanner for Smart Contracts. We extend our gratitude to CredShields for their efforts in defining the initial requirements and founding this project.</p>","tags":[]},{"location":"SCSVS/02-Preface/","title":"Preface","text":"<p>Welcome to the alpha release of the OWASP Smart Contract Security Verification Standard (SCSVS), which serves as a framework for assessing the security of smart contracts built on Ethereum Virtual Machine (EVM)-based blockchains, specifically those developed using Solidity.</p> <p>Smart contracts are autonomous programs that execute on decentralized blockchain networks, facilitating a wide range of applications, including decentralized finance (DeFi), governance systems, and tokenized assets. However, the immutability and high-value nature of blockchain ecosystems introduce unique risks and challenges. This makes security in smart contract development not only critical but also highly specialized.</p> <p>The SCSVS aims to provide comprehensive, actionable guidelines that support developers, auditors, security professionals, and architects in building and maintaining secure smart contracts, particularly within the Solidity ecosystem on EVM-based blockchains. It seeks to address common and emerging vulnerabilities, such as reentrancy attacks, integer overflows/underflows, gas optimization issues, and economic attacks\u2014all of which pose significant risks to smart contract security and user trust.</p> <p>This alpha release is the result of a collaborative effort by professionals and experts across various sectors, including blockchain security, financial technology, and decentralized application (dApp) development. The SCSVS is designed to offer flexible and evolving guidance for securing smart contracts, addressing both functional and non-functional security aspects.</p>","tags":[]},{"location":"SCSVS/02-Preface/#scope-and-purpose","title":"Scope and Purpose","text":"<p>The SCSVS provides detailed verification requirements that focus on the design, implementation, and testing phases of smart contract development. It seeks to guide stakeholders through:</p> <ul> <li>Designing with security in mind: Ensuring that security is a core principle during the planning stages of smart contract development.</li> <li>Implementing secure coding practices: Emphasizing Solidity-specific security measures to mitigate risks inherent to the EVM environment.</li> <li>Auditing and Testing: Offering best practices for conducting rigorous security audits, penetration testing, and ongoing monitoring of smart contracts once deployed.</li> </ul> <p>This standard is particularly relevant for developers who work on DeFi protocols, token contracts, decentralized exchanges (DEXs), and any application that interacts with assets or governance in a decentralized manner. Its guidelines are aligned with the broader needs of the Ethereum and EVM-based blockchain ecosystems, though many principles apply to other smart contract platforms as well.</p>","tags":[]},{"location":"SCSVS/02-Preface/#a-collaborative-effort","title":"A Collaborative Effort","text":"<p>The security challenges facing smart contract developers are constantly evolving, as adversaries seek new ways to exploit weaknesses in decentralized systems. The SCSVS alpha release is designed to be a starting point, and we openly invite contributions from the community to help expand, refine, and adapt these guidelines.</p> <p>We understand that no security standard can be entirely comprehensive, especially in the dynamic field of blockchain technology, which is rapidly advancing. The aim is to foster collaboration and continuous improvement. Your feedback and active participation will be invaluable in ensuring that the SCSVS remains practical, effective, and up to date with emerging threats and technologies.</p>","tags":[]},{"location":"SCSVS/02-Preface/#looking-ahead","title":"Looking Ahead","text":"<p>The OWASP Smart Contract Security Verification Standard is not a final document. This alpha release is the foundation for a living standard that will grow and adapt with the needs of the community and advances in smart contract development. We encourage the community to engage actively with this project\u2014whether by contributing ideas, identifying gaps, or proposing enhancements.</p> <p>In the spirit of OWASP\u2019s mission, this standard seeks to improve the security posture of the smart contract ecosystem, safeguarding both developers and users alike. We sincerely thank all contributors, and we look forward to your continued support in shaping the future of secure smart contract development.</p> <p>Together, we can build a safer decentralized future.</p>","tags":[]},{"location":"SCSVS/03-Using-SCSVS/","title":"Utilizing the SCSVS","text":"<p>The OWASP Smart Contract Security Verification Standard (SCSVS) serves several key purposes:</p> <ul> <li> <p>Assisting Development Teams: Guide smart contract developers in designing, implementing, and maintaining secure decentralized applications (dApps) and contracts, particularly on EVM-based blockchains.</p> </li> <li> <p>Framework for Security Teams: Assist security professionals in setting requirements, conducting security audits, and performing penetration tests against smart contract systems to ensure they meet robust security standards.</p> </li> <li> <p>Aligning Security Benchmarks: Establish a common security framework that can be adopted by blockchain platforms, vendors, developers, and clients regarding security expectations in smart contracts and decentralized applications.</p> </li> </ul>","tags":[]},{"location":"SCSVS/03-Using-SCSVS/#security-verification-layers","title":"Security Verification Layers","text":"<p>The SCSVS categorizes security verification into three distinct levels, each aimed at different levels of security assurance in smart contract development and deployment:</p> <ol> <li> <p>SCSVS Level 1 - Basic Security: This level is designed for smart contracts with lower security risks. It focuses on fundamental security controls, ensuring baseline protection for any decentralized application.</p> </li> <li> <p>SCSVS Level 2 - Moderate Security: Ideal for smart contracts that handle sensitive data, financial transactions, or are part of a DeFi ecosystem. Level 2 provides a more balanced approach to security, addressing common vulnerabilities like reentrancy attacks, gas inefficiencies, and access control weaknesses.</p> </li> <li> <p>SCSVS Level 3 - High Assurance Security: This level is tailored for mission-critical smart contracts where significant financial assets, governance, or high-value transactions are at stake. Level 3 ensures extensive security measures and covers advanced protections such as formal verification, multi-signature wallets, and decentralized governance.</p> </li> </ol> <p>Each level of the SCSVS provides a detailed set of security requirements, mapping these to essential security features and practices needed to build secure smart contracts. Whether developing, auditing, or deploying smart contracts, the SCSVS offers a clear roadmap to help teams at every stage.</p>","tags":[]},{"location":"SCSVS/03-Using-SCSVS/#assumptions","title":"Assumptions","text":"<p>When utilizing the SCSVS, it's important to consider the following assumptions:</p> <ul> <li> <p>The SCSVS is not a replacement for standard secure development practices such as secure coding or following a Secure Software Development Life Cycle (SSDLC). It should complement these practices by addressing specific security needs for EVM-based smart contracts and decentralized applications.</p> </li> <li> <p>The SCSVS is not intended to replace comprehensive threat modeling or security reviews. It serves as a specialized guide to help identify and mitigate vulnerabilities unique to smart contracts. Employing the SCSVS should enhance, not replace, traditional security risk assessments and penetration tests.</p> </li> </ul> <p>While the SCSVS offers a solid framework for improving the security of smart contracts, it cannot ensure complete security on its own. It should be considered a foundational security standard, with additional protective measures added as necessary to address specific vulnerabilities and evolving threats in decentralized environments.</p>","tags":[]},{"location":"SCSVS/04-Assessment_and_Certification/","title":"Assessment and Certification","text":"","tags":[]},{"location":"SCSVS/04-Assessment_and_Certification/#owasps-stance-on-scsvs-certifications-and-trust-marks","title":"OWASP's Stance on SCSVS Certifications and Trust Marks","text":"<p>OWASP, as a vendor-neutral not-for-profit organization, does not currently certify any vendors, verifiers, or smart contracts.</p> <p>All such assurance assertions, trust marks, or certifications are not officially vetted, registered, or certified by OWASP. Therefore, organizations relying on third-party verification or certifications must carefully evaluate the trust placed in any external entity or trust mark claiming Smart Contract Security Verification Standard (SCSVS) certification.</p> <p>This should not discourage organizations from offering security verification or audit services, as long as they do not claim to provide official OWASP certification.</p>","tags":[]},{"location":"SCSVS/04-Assessment_and_Certification/#guidance-for-certifying-organizations","title":"Guidance for Certifying Organizations","text":"<p>For Smart Contract Security Verification Standard (SCSVS) compliance, an \"open book\" review is recommended, where assessors are granted access to essential resources such as smart contract developers, project documentation, source code, and authenticated blockchain interfaces (including access to the blockchain explorer, transaction logs, and testing environments). It's essential that assessors gain access to at least one account for each user role, particularly if the contract supports permissioned or role-based access.</p> <p>It is important to note that the SCSVS only covers the security requirements specific to EVM-based smart contracts and does not extend to general application security controls (e.g., web interfaces, databases, or other non-blockchain components). Any additional systems or non-blockchain elements should be verified against appropriate security standards, such as the OWASP ASVS.</p>","tags":[]},{"location":"SCSVS/04-Assessment_and_Certification/#certification-reports","title":"Certification Reports","text":"<p>Certification reports should clearly define the scope of the verification, specifying which smart contracts, components, or decentralized applications (dApps) were reviewed, and should list any excluded items from the review. The report should summarize the findings, detailing both passed and failed security controls, alongside guidance on how to remediate any failures.</p> <p>Industry-standard practices for security certification require thorough documentation of the verification process. This should include:</p> <ul> <li>Work papers: Notes and records on each step of the verification process.</li> <li>Screenshots: Evidence of security control tests, such as transaction hashes or audit results.</li> <li>Scripts: Used for testing and replication of discovered issues.</li> <li>Blockchain logs: Detailed records of the verification process including contract interactions, transactions, and gas usage.</li> </ul> <p>Automated tools alone are insufficient to verify SCSVS compliance. All verification reports must provide conclusive, manually validated evidence that demonstrates the thorough and accurate testing of all required controls. In case of disputes, documentation should include adequate evidence to confirm that each control has been appropriately tested and validated.</p>","tags":[]},{"location":"SCSVS/05-SCSVS-ARCH/","title":"S1. Architecture, Design, and Threat Modeling","text":"","tags":[]},{"location":"SCSVS/05-SCSVS-ARCH/#control-objective","title":"Control Objective","text":"<p>Establish a robust architectural foundation and design framework that incorporates threat modeling and security best practices. The goal is to proactively identify and mitigate potential vulnerabilities during the early stages of smart contract development. This ensures the system's scalability, security, and efficiency, while adhering to the principles of secure Solidity coding and deployment.</p>","tags":[]},{"location":"SCSVS/06-SCSVS-CODE/","title":"S2. Policies, Procedures, and Code Management","text":"","tags":[]},{"location":"SCSVS/06-SCSVS-CODE/#control-objective","title":"Control Objective","text":"<p>Ensure that development policies and procedures are in place to promote secure coding practices, thorough code reviews, and comprehensive testing. The aim is to prevent vulnerabilities and enhance the maintainability and clarity of smart contract code.</p>","tags":[]},{"location":"SCSVS/07-SCSVS-GOV/","title":"S3. Business Logic and Economic Security","text":"","tags":[]},{"location":"SCSVS/07-SCSVS-GOV/#control-objective","title":"Control Objective","text":"<p>Ensure that the smart contract's business logic and economic security are resilient against threats related to incentive structures, tokenomics, and logic vulnerabilities. Contracts should prevent abuse, misbehavior, or unexpected behaviors by implementing secure economic models, token handling, and transaction integrity.</p>","tags":[]},{"location":"SCSVS/08-SCSVS-AUTH/","title":"S4. Access Control and Authentication","text":"","tags":[]},{"location":"SCSVS/08-SCSVS-AUTH/#control-objective","title":"Control Objective","text":"<p>Establish robust access control and authentication mechanisms to ensure that only authorized entities can perform sensitive operations within the smart contract. This includes implementing role-based access control (RBAC), secure authorization mechanisms, and decentralized identity management.</p>","tags":[]},{"location":"SCSVS/09-SCSVS-COMM/","title":"S5. Secure Interactions and Communications","text":"","tags":[]},{"location":"SCSVS/09-SCSVS-COMM/#control-objective","title":"Control Objective","text":"<p>Establish secure interaction protocols for smart contracts to ensure safe communication between contracts, external oracles, and cross-chain integrations. This includes managing contract interactions, securing oracle integrations, handling cross-chain interactions, and ensuring the security of bridges.</p>","tags":[]},{"location":"SCSVS/10-SCSVS-CRYPTO/","title":"S6. Cryptographic Practices","text":"","tags":[]},{"location":"SCSVS/10-SCSVS-CRYPTO/#control-objective","title":"Control Objective","text":"<p>Establish secure cryptographic practices for managing keys, verifying signatures, and generating random numbers to protect the integrity and authenticity of transactions and data within smart contracts.</p>","tags":[]},{"location":"SCSVS/11-SCSVS-ORACLE/","title":"S7. Arithmetic and Logic Security","text":"","tags":[]},{"location":"SCSVS/11-SCSVS-ORACLE/#control-objective","title":"Control Objective","text":"<p>Establish secure arithmetic and logic practices to prevent vulnerabilities such as overflow/underflow and ensure the integrity of calculations within smart contracts.</p>","tags":[]},{"location":"SCSVS/12-SCSVS-BLOCK/","title":"S8. Denial of Service (DoS)","text":"","tags":[]},{"location":"SCSVS/12-SCSVS-BLOCK/#control-objective","title":"Control Objective","text":"<p>Establish practices and mechanisms to prevent Denial of Service (DoS) attacks that can disrupt contract functionality and availability.</p>","tags":[]},{"location":"SCSVS/13-SCSVS-BRIDGE/","title":"S9. Blockchain Data and State Management","text":"","tags":[]},{"location":"SCSVS/13-SCSVS-BRIDGE/#control-objective","title":"Control Objective","text":"<p>Establish practices for effective management of blockchain data and state to ensure security, efficiency, and integrity of contract interactions.</p>","tags":[]},{"location":"SCSVS/14-SCSVS-DEFI/","title":"S10. Gas Usage, Efficiency, and Limitations","text":"","tags":[]},{"location":"SCSVS/14-SCSVS-DEFI/#control-objective","title":"Control Objective","text":"<p>Establish practices for optimizing gas usage and efficiency in smart contracts to minimize costs and enhance performance.</p>","tags":[]},{"location":"SCSVS/15-SCSVS-COMP/","title":"S11. Component-Specific Security","text":"","tags":[]},{"location":"SCSVS/15-SCSVS-COMP/#control-objective","title":"Control Objective","text":"<p>Establish security practices and standards for various blockchain components to mitigate specific vulnerabilities associated with tokens, NFTs, vaults, and liquidity pools.</p>","tags":[]},{"location":"SCSVS/16-Appendix-A_Glossary/","title":"Appendix A: Glossary","text":"<ul> <li> <p>Access Control \u2013 Mechanisms that restrict access to a system, application, or data to authorized users or entities. In smart contracts, access control is crucial for ensuring that only permitted users can perform sensitive actions.</p> </li> <li> <p>Arithmetic Operations \u2013 Basic mathematical operations (addition, subtraction, multiplication, division) performed in smart contracts. Proper handling of these operations is vital to prevent overflow and underflow vulnerabilities.</p> </li> <li> <p>Audit \u2013 A systematic examination of smart contracts to evaluate their security, functionality, and compliance with specified requirements. Audits help identify vulnerabilities and ensure adherence to best practices.</p> </li> <li> <p>Bytecode \u2013 The low-level code generated from Solidity (or other high-level languages) that is executed on the Ethereum Virtual Machine (EVM). Understanding bytecode is essential for analyzing contract behavior.</p> </li> <li> <p>Denial of Service (DoS) \u2013 An attack aimed at making a smart contract or service unavailable to its intended users, often by consuming excessive resources or exploiting vulnerabilities to cause failures in execution.</p> </li> <li> <p>Fallback Function \u2013 A default function in a smart contract that is executed when a contract receives Ether without any accompanying data or when a function that doesn\u2019t exist is called. Proper design of fallback functions is important to prevent security issues.</p> </li> <li> <p>Gas \u2013 A unit that measures the computational work required to execute operations on the Ethereum blockchain. Gas fees incentivize miners and limit the complexity of transactions.</p> </li> <li> <p>Gas Limit \u2013 The maximum amount of gas a user is willing to pay for a transaction, impacting the transaction's likelihood of being included in a block.</p> </li> <li> <p>Layer 2 Solutions \u2013 Technologies built on top of existing blockchains to enhance scalability and reduce transaction costs. Examples include state channels and rollups, which alleviate congestion on the main chain.</p> </li> <li> <p>Minting \u2013 The process of creating new tokens or assets and assigning them to a specified address. This operation must be carefully managed to ensure compliance with token standards.</p> </li> <li> <p>Non-Fungible Token (NFT) \u2013 A unique digital asset that represents ownership of a specific item or piece of content, distinguished by its distinct characteristics, making it irreplaceable.</p> </li> <li> <p>Overflows and Underflows \u2013 Vulnerabilities that occur when arithmetic operations exceed the maximum or minimum value of a data type, leading to unexpected behavior. Safe math libraries help prevent these issues.</p> </li> <li> <p>Reentrancy \u2013 A vulnerability where a function makes an external call to another contract before completing its execution, potentially allowing the second contract to manipulate the state of the first contract before it finishes processing.</p> </li> <li> <p>Security Audit \u2013 A comprehensive review and evaluation of a smart contract\u2019s code to identify vulnerabilities, inefficiencies, and compliance with best practices.</p> </li> <li> <p>Smart Contract \u2013 A self-executing contract with the terms of the agreement directly written into code and deployed on a blockchain. Smart contracts automate execution without the need for intermediaries.</p> </li> <li> <p>Token Standard \u2013 Specifications that define how tokens should function on a blockchain. Common standards include ERC20 for fungible tokens, ERC721 for non-fungible tokens, and ERC1155 for multi-token standards.</p> </li> <li> <p>Transaction Confirmation \u2013 The process by which a transaction is validated and recorded on the blockchain. A transaction must be confirmed by miners to be considered final and irreversible.</p> </li> <li> <p>Vulnerability \u2013 A weakness in a smart contract that can be exploited by an attacker, leading to unauthorized access, data breaches, or financial loss.</p> </li> <li> <p>Whitelisting \u2013 A security practice where specific addresses or entities are granted permission to interact with a contract, enhancing access control and mitigating potential attacks.</p> </li> <li> <p>Zero-Knowledge Proofs \u2013 Cryptographic methods that allow one party to prove to another that they know a value without revealing the value itself. This is used to enhance privacy in blockchain transactions.</p> </li> <li> <p>Audit Trail \u2013 A chronological record that tracks the sequence of activities and changes made to a smart contract, providing transparency and accountability.</p> </li> <li> <p>ERC Standards \u2013 Ethereum Request for Comments; a series of technical documents that provide guidelines and specifications for the development of smart contracts and tokens on the Ethereum blockchain.</p> </li> <li> <p>Decentralized Finance (DeFi) \u2013 A financial ecosystem that operates without central authorities, using smart contracts on blockchains to provide financial services like lending, borrowing, and trading.</p> </li> <li> <p>Oracle \u2013 A third-party service that provides external data to smart contracts, enabling them to interact with real-world information such as prices, events, or weather data.</p> </li> <li> <p>Tokenomics \u2013 The study of the economic model and incentive structures behind cryptocurrencies and tokens, including supply, demand, and the distribution of tokens.</p> </li> <li> <p>Gas Optimization \u2013 Techniques and practices aimed at reducing the gas consumption of smart contracts, thereby lowering transaction costs and improving efficiency.</p> </li> <li> <p>Atomic Swap \u2013 A smart contract technology that enables the exchange of one cryptocurrency for another without the need for a trusted third party, ensuring security and trustlessness.</p> </li> <li> <p>Cryptographic Hash Function \u2013 A mathematical algorithm that transforms input data into a fixed-size string of characters, which is unique to each unique input. This function is crucial for ensuring data integrity in blockchain.</p> </li> <li> <p>State Machine \u2013 A model that represents the state of a smart contract and its transitions, allowing for tracking of the current state and the possible changes based on events and actions.</p> </li> <li> <p>Gas Refund \u2013 A mechanism that allows users to recover some of the gas fees spent on certain operations, particularly those that free up storage space on the blockchain.</p> </li> <li> <p>Contract Upgradeability \u2013 The ability to modify or replace a smart contract after its deployment to fix bugs or add new features, often implemented through proxy patterns.</p> </li> <li> <p>Security Vulnerability Disclosure \u2013 A responsible disclosure process where security researchers report vulnerabilities found in smart contracts to the developers, allowing them to address the issues before public knowledge.</p> </li> <li> <p>Interoperability \u2013 The capability of different blockchain networks and smart contracts to communicate and interact with each other, enabling seamless integration of services and assets across platforms.</p> </li> </ul>","tags":[]},{"location":"SCSVS/17-Appendix-B_References/","title":"Appendix B: References","text":"<p>The following OWASP projects are most likely to be useful to users/adopters of this standard:</p>","tags":[]},{"location":"SCSVS/17-Appendix-B_References/#owasp-core-projects","title":"OWASP Core Projects","text":"<ol> <li>OWASP Top 10 Project</li> <li>OWASP Smart Contract Top 10 Project</li> </ol>","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-2/","title":"SCSVS-ARCH-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-2/#s12-proxy-patterns","title":"S1.2 Proxy Patterns","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-2/#control-objective","title":"Control Objective","text":"<p>Ensure that proxy patterns and upgrade mechanisms are implemented securely and managed properly, to mitigate risks during contract upgrades, deprecations, and transitions between contract versions.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-2/#security-verification-requirements","title":"Security Verification Requirements","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-2/#s12a-upgrade-mechanisms","title":"S1.2.A Upgrade Mechanisms","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 R SWE S1.2.A1 Verify that an upgrade mechanism (e.g., proxy pattern) is implemented for the contract. \u2713 \u2713 S1.2.A2 Ensure that the upgrade process includes safeguards against unauthorized upgrades. \u2713 \u2713 S1.2.A3 Check that the upgrade mechanism is documented and reviewed for security. \u2713 \u2713 S1.2.A4 Verify that immutable variables are consistent across implementations during proxy upgrades to prevent misuse. \u2713 S1.2.A5 Verify that <code>selfdestruct</code> and <code>delegatecall</code> in implementation contracts do not introduce vulnerabilities or unexpected behaviors in a proxy setup. \u2713 S1.2.A6 Verify that UUPSUpgradeable contracts are protected against vulnerabilities that may affect uninitialized implementation contracts, ensuring secure upgrade mechanisms. \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-2/#s12b-managing-deprecation","title":"S1.2.B Managing Deprecation","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 R SWE S1.2.B1 Verify that deprecated contract versions are correctly marked and handled. \u2713 S1.2.B2 Ensure that access to deprecated versions is restricted or disabled. \u2713 S1.2.B3 Check that migration paths from deprecated versions to new versions are secure. \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-2/#s12c-transparent-vs-opaque-proxies","title":"S1.2.C Transparent vs. Opaque Proxies","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 R SWE S1.2.C1 Verify whether a transparent or opaque proxy pattern is used and its suitability for the contract. \u2713 \u2713 S1.2.C2 Ensure that the proxy pattern is correctly implemented and does not introduce vulnerabilities. \u2713 \u2713 S1.2.C3 Check that the proxy pattern\u2019s choice is documented and justified. \u2713 \u2713 S1.2.C4 Ensure that uninitialized contracts cannot be taken over by attackers and that initialization functions are secured with the correct modifiers. \u2713 S1.2.C5 Verify that <code>TransparentUpgradeableProxy</code> and similar proxy patterns handle selector clashes and non-decodable calldata correctly to maintain transparency. \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-3/","title":"SCSVS-ARCH-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-3/#s13-threat-modeling","title":"S1.3 Threat Modeling","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-3/#control-objective","title":"Control Objective","text":"<p>Identify, assess, and mitigate security threats for smart contract systems by implementing a thorough threat modeling process, ensuring that risks are minimized and protections are in place for critical contract features.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-3/#security-verification-requirements","title":"Security Verification Requirements","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-3/#s13a-identifying-threats","title":"S1.3.A Identifying Threats","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S1.3.A1 Verify that potential threats are identified and documented. \u2713 \u2713 \u2713 S1.3.A2 Ensure that the threat identification process includes input from security experts. \u2713 \u2713 S1.3.A3 Check that threats are categorized based on their impact and likelihood. \u2713 \u2713 S1.3.A4 Implement protections against front-running in governor proposal creation to prevent attackers from blocking proposals or gaining undue advantages. \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-3/#s13b-assessing-risks","title":"S1.3.B Assessing Risks","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S1.3.B1 Verify that risk assessments are performed for identified threats. \u2713 \u2713 S1.3.B2 Ensure that risks are prioritized based on their potential impact and likelihood. \u2713 \u2713 S1.3.B3 Check that risk assessment results are documented and reviewed. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ARCH-3/#s13c-implementing-mitigations","title":"S1.3.C Implementing Mitigations","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S1.3.C1 Verify that mitigations are implemented for high-priority risks. \u2713 \u2713 S1.3.C2 Ensure that mitigation strategies are documented and tested. \u2713 \u2713 S1.3.C3 Check that the effectiveness of implemented mitigations is reviewed and validated. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-1/","title":"SCSVS-AUTH-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-1/#s41-role-based-access-control-rbac","title":"S4.1 Role-Based Access Control (RBAC)","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-1/#control-objective","title":"Control Objective","text":"<p>Implement role-based access control to manage permissions and ensure that only authorized users can access specific functions. This includes validating identities, applying the least privilege principle, and ensuring appropriate access controls are in place.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-1/#s41a-multi-signature-schemes","title":"S4.1.A Multi-Signature Schemes","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S4.1.A1 Ensure that the visibility modifier for all functions is appropriate, preventing unnecessary exposure of internal functions. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-1/#s41b-identity-verification","title":"S4.1.B Identity Verification","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S4.1.B1 Validate that unexpected addresses do not result in unintended behaviors, particularly when these addresses refer to contracts within the same protocol. \u2713 \u2713 S4.1.B2 Verify that functions like ecrecover handle all potential null addresses properly to avoid vulnerabilities arising from unexpected ecrecover outputs. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-1/#s41c-least-privilege-principle","title":"S4.1.C Least Privilege Principle","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S4.1.C1 Use msg.sender instead of tx.origin for authorization to avoid potential abuse from malicious contracts; include checks like require(tx.origin == msg.sender) to ensure the sender is an EOA. \u2713 \u2713 S4.1.C2 Certain addresses might be blocked or restricted from receiving tokens (e.g., LUSD). Ensure that address restrictions are properly managed and verified. \u2713 \u2713 S4.1.C3 Ensure that Guard\u2019s hooks (e.g., checkTransaction(), checkAfterExecution()) are executed to enforce critical security checks. \u2713 \u2713 S4.1.C4 Ensure that access controls are implemented correctly to determine who can use certain functions, and avoid unauthorized changes or withdrawals. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-2/","title":"SCSVS-AUTH-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-2/#s42-authorization-mechanisms","title":"S4.2 Authorization Mechanisms","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-2/#control-objective","title":"Control Objective","text":"<p>Implement secure authorization mechanisms to safeguard critical functions and sensitive operations, ensuring only authorized entities can perform these actions.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-2/#s42a-secure-access-to-critical-functions","title":"S4.2.A Secure Access to Critical Functions","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S4.2.A1 Verify that the contract uses msg.sender for authorization instead of tx.origin to avoid vulnerabilities related to contracts that forward calls from legitimate users. \u2713 \u2713 S4.2.A2 Implement and verify appropriate access controls for functions that modify contract state or perform sensitive operations to prevent unauthorized access. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-2/#s42b-timed-permissions","title":"S4.2.B Timed Permissions","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S4.2.B1 Ensure that msg.sender validation is properly implemented when using Merkle trees to maintain security and prevent unauthorized access. \u2713 \u2713 S4.2.B2 Use whitelisting to restrict interactions to a specific set of addresses, providing additional security against malicious actors. \u2713 \u2713 S4.2.B3 Ensure that functions modifying the contract state or accessing sensitive operations have proper access controls implemented. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-3/","title":"SCSVS-AUTH-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-3/#s43-decentralized-identity","title":"S4.3 Decentralized Identity","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-3/#control-objective","title":"Control Objective","text":"<p>Implement decentralized identity solutions to ensure secure and reliable identity verification and management while maintaining user privacy.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-3/#s43a-decentralized-identifiers-dids","title":"S4.3.A Decentralized Identifiers (DIDs)","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S4.3.A1 Verify that the smart contract for handling DIDs adheres to the latest standards and best practices for decentralized identity management. \u2713 \u2713 S4.3.A2 Ensure that the DID management contract includes mechanisms to prevent unauthorized modifications and ensure the integrity of DID records. \u2713 \u2713 S4.3.A3 Check that DID documents managed by the smart contract are securely stored and can be retrieved in a decentralized manner. \u2713 \u2713 S4.3.A4 Verify that the smart contract supports reliable DID resolution and includes mechanisms for handling conflicts and updates. \u2713 \u2713 S4.3.A5 Ensure that the smart contract maintains the privacy and confidentiality of DID-related information throughout its lifecycle. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-AUTH-3/#s43b-verifiable-credentials","title":"S4.3.B Verifiable Credentials","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S4.3.B1 Verify that the smart contract manages verifiable credentials in a way that ensures their authenticity and integrity through cryptographic proofs. \u2713 \u2713 S4.3.B2 Ensure that the issuance process of verifiable credentials by the smart contract includes proper identity verification and validation procedures. \u2713 \u2713 S4.3.B3 Check that the smart contract supports cryptographic proofs to verify the validity of credentials without disclosing sensitive information. \u2713 \u2713 S4.3.B4 Verify that the smart contract includes a secure process for revoking verifiable credentials when necessary. \u2713 \u2713 S4.3.B5 Ensure that the smart contract\u2019s handling of verifiable credentials complies with relevant standards and best practices for secure credential management. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-1/","title":"SCSVS-BLOCK-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-1/#s81-gas-limits","title":"S8.1 Gas Limits","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-1/#control-objective","title":"Control Objective","text":"<p>Ensure that contract design and function implementations are efficient in gas usage to mitigate risks associated with out-of-gas errors and related vulnerabilities.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-1/#s81a-efficient-loop-and-function-design","title":"S8.1.A Efficient Loop and Function Design","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S8.1.A1 Ensure that contracts are protected against insufficient gas griefing attacks by carefully managing gas consumption in critical functions. \u2713 \u2713 S8.1.A2 Ensure that systems like the RocketDepositPool contract handle failures in functions like burn() gracefully. \u2713 \u2713 S8.1.A3 Verify that gas usage in functions and loops is efficient to avoid out-of-gas errors. \u2713 \u2713 S8.1.A4 Implement mechanisms to prevent denial of service attacks due to block gas limits, ensuring that transactions or operations do not exceed the gas limit constraints. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-1/#s81b-fallback-mechanisms","title":"S8.1.B Fallback Mechanisms","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S8.1.B1 Ensure that try/catch blocks are provided with adequate gas to avoid failures and unexpected behavior in case of errors. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-2/","title":"SCSVS-BLOCK-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-2/#s82-resilience-against-resource-exhaustion","title":"S8.2 Resilience Against Resource Exhaustion","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-2/#control-objective","title":"Control Objective","text":"<p>Implement strategies to protect contracts from resource exhaustion attacks that can lead to DoS scenarios.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-BLOCK-2/#s82a-rate-limiting","title":"S8.2.A Rate Limiting","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S8.2.A1 Avoid using blocking mechanisms that could lead to a Denial-of-Service (DoS) attack. \u2713 \u2713 S8.2.A2 Protect against potential DoS in functions like supportsERC165InterfaceUnchecked() by handling excessive data queries efficiently. \u2713 \u2713 S8.2.A3 Ensure that assertions do not lead to denial of service or unexpected contract reverts, especially in scenarios where conditions are not met. \u2713 \u2713 S8.2.A4 Verify that return values from external function calls are checked to prevent issues related to unchecked return values, which could lead to unexpected behavior. \u2713 \u2713 S8.2.A5 Ensure that contract functions are protected against denial of service due to unexpected reverts by handling all possible error conditions appropriately. \u2713 \u2713 S8.2.A6 Ensure that functions such as supportsERC165InterfaceUnchecked() in ERC165Checker.sol handle large data queries efficiently to avoid excessive resource consumption. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-1/","title":"SCSVS-BRIDGE-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-1/#s91-state-management","title":"S9.1 State Management","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-1/#control-objective","title":"Control Objective","text":"<p>Ensure efficient and secure handling of state within smart contracts to prevent data corruption and unexpected behavior.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-1/#s91a-efficient-and-secure-state-handling","title":"S9.1.A Efficient and Secure State Handling","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.1.A1 Ensure that payable functions in contracts handle all ETH passed in msg.value and provide a mechanism for withdrawal to avoid ETH being locked in the contract. \u2713 \u2713 S9.1.A2 Verify that deleting a variable of a nested structure correctly resets all nested level fields to default values to avoid unexpected behavior. \u2713 \u2713 S9.1.A3 Verify that storage structs and arrays with types shorter than 32 bytes are handled correctly, avoiding data corruption when encoded directly from storage using the experimental ABIEncoderV2. \u2713 \u2713 S9.1.A4 Verify that storage arrays containing structs or other statically-sized arrays are properly read and encoded in external function calls to prevent data corruption. \u2713 \u2713 S9.1.A5 Ensure that copying bytes arrays from memory or calldata to storage handles empty arrays correctly, avoiding data corruption when the target array's length is increased subsequently without storing new data. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-1/#s91b-state-channels","title":"S9.1.B State Channels","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.1.B1 Verify that global state updates are correctly handled when working with memory copies to ensure accurate state management. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-2/","title":"SCSVS-BRIDGE-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-2/#s92-data-privacy","title":"S9.2 Data Privacy","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-2/#control-objective","title":"Control Objective","text":"<p>Ensure that sensitive data within contracts is secured and that privacy measures are effectively implemented.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-2/#s92a-ensuring-sensitive-data-is-secure","title":"S9.2.A Ensuring Sensitive Data is Secure","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.2.A1 Ensure that private data marked in contracts is protected from unauthorized access through blockchain analysis. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-2/#s92b-zero-knowledge-proofs","title":"S9.2.B Zero-Knowledge Proofs","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.2.B1 Verify that zero-knowledge proofs are implemented to ensure privacy without revealing any underlying data. \u2713 \u2713 S9.2.B2 Validate the correctness of proof generation and verification processes to prevent any potential leaks or exploits. \u2713 \u2713 S9.2.B3 Ensure that zero-knowledge proofs are integrated seamlessly with the blockchain to maintain performance and security. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-2/#s92c-private-transactions","title":"S9.2.C Private Transactions","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.2.C1 Verify that private transaction mechanisms (e.g., zk-SNARKs, zk-STARKs) are correctly implemented to ensure confidentiality of transaction details. \u2713 \u2713 S9.2.C2 Ensure that private transactions maintain the integrity and validity of the blockchain. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-2/#s92d-confidential-contracts","title":"S9.2.D Confidential Contracts","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.2.D1 Verify that confidential contracts use cryptographic techniques to hide contract state and execution details from unauthorized parties. \u2713 \u2713 S9.2.D2 Ensure that only parties with appropriate permissions can access data within confidential contracts. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-3/","title":"SCSVS-BRIDGE-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-3/#s93-event-logging","title":"S9.3 Event Logging","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-3/#control-objective","title":"Control Objective","text":"<p>Implement transparent and secure logging practices to ensure traceability and detect unauthorized changes.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-3/#s93a-transparent-and-secure-logging-practices","title":"S9.3.A Transparent and Secure Logging Practices","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.3.A1 Verify that events are emitted properly, especially for critical changes to ensure traceability and transparency. \u2713 \u2713 S9.3.A2 Verify that the contract\u2019s event logging correctly reflects critical changes to ensure transparency and traceability. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-3/#s93b-log-analysis","title":"S9.3.B Log Analysis","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.3.B1 Implement tools and processes for analyzing event logs to detect anomalies or unauthorized changes. \u2713 \u2713 S9.3.B2 Set up alerts for unusual patterns or discrepancies in logged events. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-4/","title":"SCSVS-BRIDGE-4","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-4/#s94-decentralized-storage","title":"S9.4 Decentralized Storage","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-4/#control-objective","title":"Control Objective","text":"<p>Ensure data integrity, security, and availability for data stored in decentralized storage solutions.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-BRIDGE-4/#s94a-ipfs-arweave","title":"S9.4.A IPFS, Arweave","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S9.4.A1 Ensure that data stored on decentralized platforms like IPFS or Arweave is encrypted and access-controlled. \u2713 \u2713 S9.4.A2 Implement mechanisms for data redundancy and backup to ensure data availability. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-1/","title":"SCSVS-CODE-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-1/#s21-development-policies","title":"S2.1 Development Policies","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-1/#control-objective","title":"Control Objective","text":"<p>Establish and enforce secure coding standards and review processes to minimize vulnerabilities and ensure best practices are followed throughout the development lifecycle.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-1/#s21a-secure-coding-standards","title":"S2.1.A Secure Coding Standards","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S2.1.A1 Ensure that developers do not use outdated compiler versions and adhere to the latest compiler recommendations. \u2713 \u2713 S2.1.A2 Verify that deprecated functions are not used in the code. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-1/#s21b-code-review-processes","title":"S2.1.B Code Review Processes","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S2.1.B1 Verify that all smart contract code changes are reviewed by at least two independent developers with expertise in smart contract security before merging to the main branch. \u2713 \u2713 S2.1.B2 Ensure that code reviews of smart contracts involve automated static analysis tools specifically designed for smart contracts, and that all flagged issues are addressed or documented prior to merging. \u2713 \u2713 S2.1.B3 Check that the code review process for smart contracts includes a thorough analysis for vulnerabilities such as reentrancy attacks, integer overflows, and improper access control. \u2713 \u2713 S2.1.B4 Verify that code reviews include adherence to smart contract development standards, such as the use of safe math libraries and secure design patterns. \u2713 \u2713 S2.1.B5 Ensure that code reviews incorporate a checklist of common smart contract vulnerabilities, and that each item on the list is addressed before code is approved. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-2/","title":"SCSVS-CODE-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-2/#s22-code-clarity","title":"S2.2 Code Clarity","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-2/#control-objective","title":"Control Objective","text":"<p>Promote code clarity and maintainability through thorough documentation, logical structure, and adherence to consistent coding standards, enabling easier understanding and modification by developers.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-2/#s22a-readability-and-documentation","title":"S2.2.A Readability and Documentation","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S2.2.A1 Ensure that all smart contract functions and critical code blocks are documented with clear comments that explain their purpose and logic. \u2713 \u2713 S2.2.A2 Verify that the structure of the smart contract is logical and organized to facilitate understanding and modification by other developers. \u2713 \u2713 S2.2.A3 Check that the smart contract documentation includes a high-level overview of its functionality, usage instructions, and any dependencies on other contracts or systems. \u2713 \u2713 S2.2.A4 Ensure that smart contract code follows consistent naming conventions for variables, functions, and contract names to improve readability and maintainability. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-2/#s22b-code-linting-and-formatting-tools","title":"S2.2.B Code Linting and Formatting Tools","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S2.2.B1 Ensure that a code linting tool specific to smart contracts is integrated into the development workflow to enforce coding standards and style guidelines. \u2713 \u2713 S2.2.B2 Verify that all smart contract code passes linting checks without errors or warnings before being committed to the repository. \u2713 \u2713 S2.2.B3 Check that code formatting tools are applied to maintain consistent indentation, spacing, and line breaks in smart contract code. \u2713 \u2713 S2.2.B4 Ensure that the linting and formatting configurations are reviewed and updated regularly to reflect new best practices and emerging issues in smart contract development. \u2713 \u2713 S2.2.B5 Verify that the linting and formatting tools are compatible with the development environment and do not introduce unintended changes to the smart contract code. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-3/","title":"SCSVS-CODE-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-3/#s23-test-coverage","title":"S2.3 Test Coverage","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-3/#control-objective","title":"Control Objective","text":"<p>Ensure comprehensive test coverage for smart contracts, encompassing unit tests, integration tests, and security-specific tests, to identify vulnerabilities and maintain code quality throughout development.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-3/#s23a-unit-tests-integration-tests-automated-testing","title":"S2.3.A Unit Tests, Integration Tests, Automated Testing","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S2.3.A1 Verify that all critical functions in the smart contract have comprehensive unit tests that cover both typical and edge cases. \u2713 \u2713 S2.3.A2 Ensure that integration tests are implemented to validate the interactions between the smart contract and other contracts or external systems. \u2713 \u2713 S2.3.A3 Check that automated tests are set up to run on each code commit to detect regressions and maintain continuous quality of the smart contract. \u2713 \u2713 S2.3.A4 Verify that test coverage tools are used to monitor and achieve a high percentage of coverage for the smart contract code. \u2713 \u2713 S2.3.A5 Ensure that the testing framework supports mocking and simulating external dependencies to effectively isolate and test specific functionalities of the smart contract. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CODE-3/#s23b-security-specific-tests","title":"S2.3.B Security-Specific Tests","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S2.3.B1 Verify that the test suite for the smart contract includes security-specific tests designed to identify vulnerabilities such as reentrancy, integer overflows, and improper access controls. \u2713 \u2713 S2.3.B2 Ensure that the security tests validate proper implementation of access controls and permissions within the smart contract. \u2713 \u2713 S2.3.B3 Check that fuzz testing is conducted to uncover unexpected behaviors and potential security issues under various input scenarios. \u2713 \u2713 S2.3.B4 Verify that the smart contract's response to invalid inputs and edge cases is thoroughly tested to ensure robust security measures are in place. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-1/","title":"SCSVS-COMM-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-1/#s51-contract-interactions","title":"S5.1 Contract Interactions","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-1/#control-objective","title":"Control Objective","text":"<p>Ensure that all interactions between contracts are secure, minimizing risks associated with external calls, maintaining a minimal trusted surface, and handling errors appropriately.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-1/#s51a-secure-message-passing","title":"S5.1.A Secure Message Passing","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S5.1.A1 Ensure that calls to inherited functions from LzApp use recommended approaches (e.g., _lzSend) to avoid vulnerabilities associated with direct calls to lzEndpoint.send. \u2713 \u2713 S5.1.A2 Ensure that when interacting with external contracts, the msg.sender remains consistent to avoid security issues related to unexpected changes in sender context. \u2713 \u2713 S5.1.A3 Manage untrusted external contract calls to prevent unexpected results such as multiple withdrawals or out-of-order events. \u2713 \u2713 S5.1.A4 Missing verification of interacting pools can introduce risks. Ensure that all pools are properly verified before interaction to prevent potential security issues. \u2713 \u2713 S5.1.A5 Verify that the low-level .delegatecall() is properly managed, acknowledging that it converts the return value to a Boolean without providing the execution outcome. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-1/#s51b-minimal-trusted-surface","title":"S5.1.B Minimal Trusted Surface","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S5.1.B1 Verify that the smart contract minimizes its trusted surface by only interacting with other contracts and systems through well-defined and limited interfaces. \u2713 \u2713 S5.1.B2 Ensure that the smart contract includes checks to validate the trustworthiness and authenticity of interacting parties before executing sensitive operations. \u2713 \u2713 S5.1.B3 Check that the smart contract's interactions are designed to avoid dependencies on external data or contracts that could compromise security. \u2713 \u2713 S5.1.B4 Verify that the contract handles failures or unexpected behaviors from external interactions gracefully to avoid cascading failures. \u2713 \u2713 S5.1.B5 Ensure that interactions with other contracts are monitored and audited to detect and address any unusual or unauthorized activities. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-2/","title":"SCSVS-COMM-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-2/#s52-oracle-integrations","title":"S5.2 Oracle Integrations","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-2/#control-objective","title":"Control Objective","text":"<p>Ensure that oracle integrations provide secure, reliable, and tamper-proof data feeds while maintaining data integrity and handling failures appropriately.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-2/#s52a-secure-data-feeds","title":"S5.2.A Secure Data Feeds","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S5.2.A1 Verify that the smart contract uses oracles that provide secure and tamper-proof data feeds, including checks for data integrity and authenticity. \u2713 \u2713 S5.2.A2 Ensure that the smart contract validates the data received from oracles to prevent malicious or incorrect data from affecting contract operations. \u2713 \u2713 S5.2.A3 Check that the smart contract includes fallback mechanisms in case of oracle failure or unreliable data. \u2713 \u2713 S5.2.A4 Verify that the integration with oracles follows best practices for data security, including encryption and secure communication channels. \u2713 \u2713 S5.2.A5 Ensure that the smart contract's oracle integration is designed to handle any potential discrepancies or conflicts in data from multiple sources. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-2/#s52b-decentralized-oracles","title":"S5.2.B Decentralized Oracles","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S5.2.B1 Verify that the smart contract uses decentralized oracles to enhance data reliability and prevent single points of failure or manipulation. \u2713 \u2713 S5.2.B2 Ensure that the smart contract includes mechanisms to validate the consensus or majority opinion of decentralized oracles before taking actions based on their data. \u2713 \u2713 S5.2.B3 Check that the smart contract accounts for potential latency or delays in data from decentralized oracles to maintain operational reliability. \u2713 \u2713 S5.2.B4 Verify that the smart contract includes checks to prevent manipulation or collusion among decentralized oracles. \u2713 \u2713 S5.2.B5 Ensure that the decentralized oracle integration adheres to standards for security and reliability in multi-oracle environments. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-3/","title":"SCSVS-COMM-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-3/#s53-cross-chain-interactions","title":"S5.3 Cross-Chain Interactions","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-3/#control-objective","title":"Control Objective","text":"<p>Ensure secure handling of external calls and atomic swaps during cross-chain interactions to maintain operational reliability and prevent fraud.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-3/#s53a-handling-external-calls-securely","title":"S5.3.A Handling External Calls Securely","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S5.3.A1 Ensure that parameters for Chainlink VRF (Verifiable Random Function) are thoroughly validated to prevent the fulfillRandomWord function from returning incorrect values instead of reverting. \u2713 \u2713 S5.3.A2 Implement robust security checks for cross-chain messaging to ensure correct permissions and intended functionality. \u2713 \u2713 S5.3.A3 Verify that contracts created using the CREATE opcode handle block reorganizations securely to prevent unexpected eliminations. \u2713 \u2713 S5.3.A4 Ensure robust cross-chain messaging security checks to prevent replay attacks where signatures valid on one chain might be exploited on another. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-3/#s53b-atomic-swaps","title":"S5.3.B Atomic Swaps","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S5.3.B1 Verify that the smart contract supports atomic swaps with robust mechanisms to ensure that swaps are completed successfully or not executed at all. \u2713 \u2713 S5.3.B2 Ensure that the smart contract includes checks to validate the atomic swap conditions and prevent partial or fraudulent swaps. \u2713 \u2713 S5.3.B3 Check that the smart contract handles potential failures or disputes in atomic swaps securely and fairly. \u2713 \u2713 S5.3.B4 Verify that the atomic swap functionality is tested thoroughly to cover various scenarios and edge cases. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-4/","title":"SCSVS-COMM-4","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-4/#s54-bridges","title":"S5.4 Bridges","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-4/#control-objective","title":"Control Objective","text":"<p>Ensure the security of cross-chain transactions by implementing robust validation and verification mechanisms to prevent fraud and maintain data integrity.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMM-4/#s54a-cross-chain-transaction-security","title":"S5.4.A Cross-Chain Transaction Security","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S5.4.A1 Verify that the smart contract for cross-chain transactions includes robust mechanisms for verifying and validating transactions across different chains. \u2713 \u2713 S5.4.A2 Ensure that the smart contract prevents double-spending and replay attacks in cross-chain transactions by implementing appropriate security checks. \u2713 \u2713 S5.4.A3 Check that the cross-chain transaction contract handles communication and data integrity securely between different blockchain networks. \u2713 \u2713 S5.4.A4 Verify that the smart contract includes fallback and recovery mechanisms for handling failures or inconsistencies in cross-chain transactions. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-1/","title":"SCSVS-COMP-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-1/#s111-tokens-erc20-erc721-erc1155","title":"S11.1 Tokens (ERC20, ERC721, ERC1155)","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-1/#control-objective","title":"Control Objective","text":"<p>Ensure secure implementation and management of token standards to prevent vulnerabilities.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-1/#s111a-secure-implementation-and-management","title":"S11.1.A Secure Implementation and Management","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S11.1.A1 Verify that the totalSupply value is consistent during token minting operations, ensuring that callbacks do not result in incorrect values. \u2713 \u2713 S11.1.A2 Some tokens have multiple addresses associated with them, which can introduce vulnerabilities. Ensure all token addresses are managed and verified securely to avoid related risks. \u2713 \u2713 S11.1.A3 Verify that tokens handle zero amount transfers properly to prevent issues in integrations and operations. \u2713 \u2713 S11.1.A4 Verify that tokens handle zero amount transfers properly to prevent issues in integrations and operations. \u2713 \u2713 S11.1.A5 Some tokens revert on the transfer of a zero amount, which can cause issues in certain integrations and operations. Ensure compatibility with such tokens to avoid integration problems. \u2713 \u2713 S11.1.A6 Not all ERC20 tokens comply with the EIP20 standard; some may not return a boolean flag or revert on failure. Verify compliance with the ERC20 standard to avoid compatibility issues. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-2/","title":"SCSVS-COMP-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-2/#s112-nft-security","title":"S11.2 NFT Security","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-2/#control-objective","title":"Control Objective","text":"<p>Implement best practices for non-fungible tokens to safeguard against vulnerabilities.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-2/#s112a-best-practices-for-non-fungible-tokens","title":"S11.2.A Best Practices for Non-Fungible Tokens","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S11.2.A1 Implement standards and best practices for NFT creation, management, and transfer to prevent common vulnerabilities. \u2713 \u2713 S11.2.A2 Ensure proper metadata integrity and prevent unauthorized minting or transfers. \u2713 \u2713 S11.2.A3 Safeguard against potential exploits related to royalty payments or token burns. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-3/","title":"SCSVS-COMP-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-3/#s113-vaults","title":"S11.3 Vaults","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-3/#control-objective","title":"Control Objective","text":"<p>Ensure secure asset storage and management within vault systems.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-3/#s113a-secure-asset-storage-and-management","title":"S11.3.A Secure Asset Storage and Management","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S11.3.A1 Address potential overhead issues associated with withdrawing stETH or wstETH, including queue times and withdrawal limits, to ensure smooth operations. \u2713 \u2713 S11.3.A2 Handle conversions between stETH and wstETH carefully to avoid potential issues due to the rebasing nature of stETH. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-4/","title":"SCSVS-COMP-4","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-4/#s114-liquid-staking","title":"S11.4 Liquid Staking","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-4/#control-objective","title":"Control Objective","text":"<p>Ensure secure staking mechanisms to protect users' assets.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-4/#s114a-secure-staking-mechanisms","title":"S11.4.A Secure Staking Mechanisms","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S11.4.A1 Verify that mechanisms for detaching sfrxETH from frxETH are robust to prevent discrepancies and ensure accurate reward transfers, particularly when controlled by centralized entities. \u2713 \u2713 S11.4.A2 Monitor potential future changes in the sfrxETH/ETH rate and ensure users are adequately forewarned to mitigate risks associated with rate fluctuations. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-5/","title":"SCSVS-COMP-5","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-5/#s115-liquidity-pools-amms","title":"S11.5 Liquidity Pools (AMMs)","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-5/#control-objective","title":"Control Objective","text":"<p>Establish security measures in automated market makers.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-5/#s115a-security-in-automated-market-makers","title":"S11.5.A Security in Automated Market Makers","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S11.5.A1 [WIP/Will be removed]","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-6/","title":"SCSVS-COMP-6","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-6/#s116-uniswap-v4-hook","title":"S11.6 Uniswap V4 Hook","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-6/#control-objective","title":"Control Objective","text":"<p>Ensure secure integration and customization of Uniswap components.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-COMP-6/#s116a-secure-integration-and-customization","title":"S11.6.A Secure Integration and Customization","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S11.6.A1 Verify the correct usage of Uniswap\u2019s TickMath and FullMath libraries to ensure proper handling of unchecked arithmetic operations, adhering to version-specific Solidity considerations. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-1/","title":"SCSVS-CRYPTO-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-1/#s61-key-management","title":"S6.1 Key Management","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-1/#control-objective","title":"Control Objective","text":"<p>Ensure secure handling and storage of private keys and implement robust signature verification processes to prevent unauthorized access and actions.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-1/#s61a-secure-handling-and-storage-of-private-keys","title":"S6.1.A Secure Handling and Storage of Private Keys","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S6.1.A1 Verify that the ecrecover() function handles malformed inputs correctly and does not return invalid data. \u2713 \u2713 S6.1.A2 Ensure that signature verification mechanisms are robust against signature malleability and replay attacks, particularly by using nonces or hashed messages rather than relying solely on the signature itself. \u2713 \u2713 S6.1.A3 Verify that SignatureChecker.isValidSignatureNow handles edge cases properly and does not revert unexpectedly, considering the ABI decoding issues introduced in Solidity 0.8. \u2713 \u2713 S6.1.A4 Ensure that all signatures are checked thoroughly to prevent unauthorized transactions or actions due to weak or improperly managed signature validation. \u2713 \u2713 S6.1.A5 Validate that signature protection mechanisms are up-to-date and resistant to signature malleability attacks by avoiding outdated libraries and practices. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-1/#s61b-multi-signature-wallets","title":"S6.1.B Multi-Signature Wallets","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S6.1.B1 Verify that multi-signature wallets require a predefined number of signatures before executing any transaction. \u2713 \u2713 S6.1.B2 Ensure that the multi-signature wallet logic is resistant to replay attacks. \u2713 \u2713 S6.1.B3 Verify that the process of adding or removing signatories from the multi-signature wallet is secure and controlled. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-2/","title":"SCSVS-CRYPTO-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-2/#s62-signature-verification","title":"S6.2 Signature Verification","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-2/#control-objective","title":"Control Objective","text":"<p>Implement cryptographic techniques that ensure the secure verification of signatures and compliance with standards to maintain the integrity of authenticated transactions.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-2/#s62a-cryptographic-techniques-for-authentication","title":"S6.2.A Cryptographic Techniques for Authentication","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S6.2.A1 Ensure that cryptographic algorithms used for signature verification are secure and follow best practices. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-2/#s62b-standard-compliance-eg-eip-712","title":"S6.2.B Standard Compliance (e.g., EIP-712)","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S6.2.B1 Verify that ECDSA signature handling functions, such as ECDSA.recover and ECDSA.tryRecover, properly manage signature formats to prevent signature malleability, especially when handling both traditional 65-byte and EIP-2098 compact signatures. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-3/","title":"SCSVS-CRYPTO-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-3/#s63-secure-random-number-generation","title":"S6.3 Secure Random Number Generation","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-3/#control-objective","title":"Control Objective","text":"<p>Implement best practices for secure random number generation to ensure unpredictability and resistance against manipulation.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-CRYPTO-3/#s63a-best-practices-for-randomness","title":"S6.3.A Best Practices for Randomness","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S6.3.A1 Ensure that random number generation follows best practices and uses secure sources of entropy. \u2713 \u2713 S6.3.A2 Verify that any random number generation is resistant to manipulation and prediction. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-1/","title":"SCSVS-DEFI-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-1/#s101-optimizing-gas-usage","title":"S10.1 Optimizing Gas Usage","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-1/#control-objective","title":"Control Objective","text":"<p>Ensure gas consumption is minimized to promote cost-effective execution of smart contracts.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-1/#s101a-understanding-gas-costs-and-limits","title":"S10.1.A Understanding Gas Costs and Limits","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S10.1.A1 Implement best practices for optimizing gas consumption to ensure cost-effective and efficient contract execution. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-1/#s101b-gas-estimation-tools","title":"S10.1.B Gas Estimation Tools","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S10.1.B1 Verify that transaction confirmation numbers are chosen appropriately to mitigate risks related to chain re-orgs and ensure reliable contract operation. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-2/","title":"SCSVS-DEFI-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-2/#s102-efficient-contract-design","title":"S10.2 Efficient Contract Design","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-2/#control-objective","title":"Control Objective","text":"<p>Design contracts efficiently to enhance performance and reduce gas costs through optimal architecture.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-DEFI-2/#s102a-layer-2-solutions","title":"S10.2.A Layer 2 Solutions","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S10.2.A1 Explore and integrate Layer 2 scaling solutions (e.g., rollups, state channels) to improve transaction throughput and reduce gas costs. \u2713 \u2713 S10.2.A2 Verify the security and reliability of Layer 2 solutions before integration. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-1/","title":"SCSVS-GOV-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-1/#s31-economic-models","title":"S3.1 Economic Models","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-1/#control-objective","title":"Control Objective","text":"<p>Ensure that economic models, including incentive structures and tokenomics, are designed and implemented in a way that secures value and incentivizes proper behavior within the ecosystem. Contracts should handle fluctuating token values and avoid creating opportunities for exploitation.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-1/#s31a-incentive-structures","title":"S3.1.A Incentive Structures","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S3.1.A1 Ensure that the withdrawal process implements a pull-based approach rather than a push-based one to track accounting and allow users to pull payments. \u2713 \u2713 \u2713 S3.1.A2 The rate of cbETH to ETH can decrease, impacting users who hold or interact with cbETH. Ensure mechanisms are in place to handle fluctuations in conversion rates. \u2713 \u2713 S3.1.A3 Validators on the Ethereum 2.0 Beacon Chain can be penalized or slashed for misbehavior, which can affect the value of rETH. Ensure that these dynamics are considered in value assessments and interactions. \u2713 \u2713 S3.1.A4 The conversion rate between ETH and rETH might change over time based on the rewards accrued from staking. Ensure that these fluctuations are properly managed and captured. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-2/","title":"SCSVS-GOV-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-2/#s32-tokenomics","title":"S3.2 Tokenomics","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-2/#control-objective","title":"Control Objective","text":"<p>Ensure that tokens used within the smart contract ecosystem are securely implemented, including aspects such as value management, rebasing mechanisms, and reward systems. Contracts should prevent token vulnerabilities like double-spending, incorrect rewards, and improper fee handling.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-2/#s32a-economic-security-of-tokens-and-their-use-cases","title":"S3.2.A Economic Security of Tokens and Their Use Cases","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S3.2.A1 Ensure that Merkle trees do not contain duplicate proofs, as this can lead to vulnerabilities like double-spending. \u2713 \u2713 S3.2.A2 Verify that DeFi protocols account for tokens with negative rebase mechanisms, ensuring that value changes and potential miscalculations are properly handled and mitigated. \u2713 \u2713 S3.2.A3 Verify that reward claims are correctly implemented to ensure users receive their correct rewards. \u2713 \u2713 S3.2.A4 Verify that tokens do not have vulnerabilities such as incorrect fee application or unexpected behavior due to token transfer issues. \u2713 \u2713 S3.2.A5 Verify that all claimable addresses are included in the hashing process for Merkle tree leaves to prevent attackers from claiming funds they should not. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-3/","title":"SCSVS-GOV-3","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-3/#s33-preventing-reentrancy-and-logic-flaws","title":"S3.3 Preventing Reentrancy and Logic Flaws","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-3/#control-objective","title":"Control Objective","text":"<p>Ensure the smart contract's transaction flow and logic integrity are protected from reentrancy attacks and logic flaws. Contracts should implement robust control structures and security patterns to prevent reentrancy, handle complex flows, and ensure that state transitions are secure and symmetrical.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-3/#s33a-transaction-flow-security","title":"S3.3.A Transaction Flow Security","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S3.3.A1 Check for edge cases in loop control structures to prevent unexpected behaviors due to break or continue statements. \u2713 \u2713 S3.3.A2 Ensure that scenarios where sender and recipient are the same are considered to prevent unintended issues in smart contracts. \u2713 \u2713 S3.3.A3 Ensure that the <code>NonReentrant</code> modifier is applied before other modifiers in functions to prevent reentrancy attacks. \u2713 \u2713 S3.3.A4 Verify that the check-effect-interaction pattern is implemented to prevent reentrancy attacks. \u2713 \u2713 S3.3.A5 Ensure that function calls with arbitrary user input and low-level calls are handled securely to avoid introducing risks. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-GOV-3/#s33b-function-integrity","title":"S3.3.B Function Integrity","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SWE S3.3.B1 Ensure that functions intended to be unique per parameter set are not callable multiple times to prevent potential issues. \u2713 \u2713 S3.3.B2 Verify that state changes in functions, such as withdraw and deposit, are symmetrically handled to avoid undesired behavior due to inconsistencies. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-1/","title":"SCSVS-ORACLE-1","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-1/#s71-preventing-overflowunderflow","title":"S7.1 Preventing Overflow/Underflow","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-1/#control-objective","title":"Control Objective","text":"<p>Implement safe arithmetic practices to prevent overflow and underflow vulnerabilities that can compromise contract functionality and security.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-1/#s71a-use-of-safe-math-libraries","title":"S7.1.A Use of Safe Math Libraries","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S7.1.A1 Verify that explicit type casting does not lead to overflow or underflow issues. \u2713 \u2713 S7.1.A2 Verify that integer arithmetic operations do not exceed their bounds to prevent integer overflow or underflow vulnerabilities. \u2713 \u2713 S7.1.A3 Ensure that operations involving time units and other expressions handle potential overflows correctly. \u2713 \u2713 S7.1.A4 Verify that division by zero is correctly handled and causes a transaction revert to prevent unexpected behavior. \u2713 \u2713 S7.1.A5 Ensure that variables are managed within their bounds to prevent reverts due to exceeding limits. \u2713 \u2713 S7.1.A6 Ensure that arithmetic operations within the unchecked{} block are carefully managed to prevent unintentional overflow or underflow. \u2713 \u2713 S7.1.A7 Confirm that inline assembly operations handle division by zero and overflow/underflow according to desired behavior and revert appropriately. \u2713 \u2713 S7.1.A8 Implement checks to handle cases where operations might introduce unintended precision issues or rounding errors. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-1/#s71b-fixed-point-arithmetic","title":"S7.1.B Fixed-Point Arithmetic","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S7.1.B1 Verify that fixed-point arithmetic operations are performed safely to prevent overflow, underflow, and precision loss. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-2/","title":"SCSVS-ORACLE-2","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-2/#s72-arithmetic-integrity","title":"S7.2 Arithmetic Integrity","text":"","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-2/#control-objective","title":"Control Objective","text":"<p>Ensure that all calculations and logical operations within the smart contract are performed correctly to maintain data integrity and prevent manipulation.</p>","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-2/#s72a-secure-calculations-and-logic","title":"S7.2.A Secure Calculations and Logic","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S7.2.A1 Ensure that price or rate calculations derived from asset balances are protected from manipulation, considering attack vectors like flash loans and donations. \u2713 \u2713 S7.2.A2 Ensure that the use of structs and arrays does not lead to data corruption or incorrect values due to storage encoding issues. \u2713 \u2713 S7.2.A3 Avoid operations that could lead to unintended data type conversions or precision loss by ensuring arithmetic operations are performed correctly. \u2713 \u2713 S7.2.A4 Enforce a minimum transaction amount to prevent attackers from clogging the network with zero amount or dust transactions. \u2713 \u2713 S7.2.A5 Validate that financial operations respect associative properties, ensuring consistent outcomes whether operations are performed in aggregate or iteratively. \u2713 \u2713 S7.2.A6 Implement proper rounding direction for calculations where accounting relies on user shares to avoid inaccuracies. \u2713 \u2713 S7.2.A7 Validate that inequalities and comparisons are correctly implemented to handle edge values appropriately. \u2713 \u2713 S7.2.A8 Ensure that abi.decode adheres to the type limits to avoid reverts due to overflow of target types. \u2713 \u2713 S7.2.A9 Ensure that logical operators such as <code>==</code>, <code>!=</code>, <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code> are used correctly, especially when test coverage may be limited. \u2713 \u2713","tags":[]},{"location":"SCSVS/controls/SCSVS-ORACLE-2/#s72b-precondition-and-postcondition-checks","title":"S7.2.B Precondition and Postcondition Checks","text":"SCSVS\u00a0VR\u00a0ID Requirement L1 L2 L3 SCWE S7.2.B1 Ensure that multiplication is performed before division to maintain precision in calculations. \u2713 \u2713 S7.2.B2 Ensure that the request confirmation number is high enough to mitigate risks associated with chain re-orgs. \u2713 \u2713 S7.2.B3 Verify that off-by-one errors are avoided in loops and iterations, ensuring correct handling of list lengths and indexing. \u2713 \u2713 S7.2.B4 Verify that unsigned integers are not used to represent negative values, as this can lead to erroneous behavior. \u2713 \u2713 S7.2.B5 Verify that calculations with multiple terms handle all possible edge cases for min/max values to avoid errors. \u2713 \u2713","tags":[]},{"location":"SCWE/","title":"Smart Contract Security Weakness Enumeration (SCWE)","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p> <p> GitHub Repo</p> <p> OWASP Project Page</p> About the SCWE <p>The Smart Contract Security Weakness Enumeration (SCWE) is a list of common security and privacy weaknesses in smart contracts. It is intended to be used as a reference for developers, security researchers, and security professionals. It acts as the bridge between the SCSVS and the SCSTG.</p> <p> </p> <p>For its definition we draw inspiration from the Common Weakness Enumeration (CWE), which is a community-developed list of common software security weaknesses. The SCWE is intended to be a complementary list to the CWE, focusing specifically on security weaknesses in smart contracts.</p> <p>A weakness is a security or privacy issue that can be introduced into a smart contracts. Weaknesses are categorized by the SCSVS categories and controls. For example, a weakness related to the use of insecure random number generators is categorized under the <code>SCSVS-CODE-1</code> control.</p> <p>Each weakness contains the following information:</p> <ul> <li>Overview: A brief description of the weakness.</li> <li>Impact: The potential impact of the weakness on the security or privacy of the application.</li> <li>Modes of Introduction: The ways in which the weakness can be introduced into an application.</li> <li>Mitigations: Recommendations for mitigating the weakness.</li> </ul> <p>\"Weakness vs Vulnerability\": It is important to note that a weakness is not a vulnerability, but it can lead to the introduction of vulnerabilities. According to the CWE, a weakness is a condition in a software, firmware, hardware, or service component that, under certain circumstances, could contribute to the introduction of vulnerabilities. Whereas a vulnerability is a flaw in a software, firmware, hardware, or service component resulting from a weakness that can be exploited, causing a negative impact to the confidentiality, integrity, or availability of an impacted component or components.</p> Open Call for New SCWE Submissions <p>Want to contribute a new SCWE entry?</p> <ul> <li>Open an issue in our GitHub repository with your proposed SCWE-XXX identifier and a brief description.</li> <li>After approval and metadata assignment, submit a Pull Request with your new SCWE entry.</li> <li>See the full contribution process here.</li> <li>See this sample issue and this sample PR for examples of a valid submission.</li> </ul> <p>Thank you for helping us improve the security of smart contracts!</p> SCWE ID Title SCSVS CG ID SCSVS SCG IDs L1 L2 Status SCWE-031  Insecure use of Block Variables SCSVS-BLOCK SCSVS-BLOCK-2 profile:L1 newstatus:new SCWE-073  Message Call with Hardcoded Gas Amount SCSVS-BLOCK SCSVS-BLOCK-1 profile:L1 newstatus:new SCWE-024  Weak Randomness Sources SCSVS-BLOCK SCSVS-BLOCK-1 profile:L1 newstatus:new SCWE-065  Block Values as a Proxy for Time SCSVS-BLOCK SCSVS-BLOCK-2 profile:L1 newstatus:new SCWE-057  Write to Arbitrary Storage Location SCSVS-COMP SCSVS-COMP-2 profile:L1 newstatus:new SCWE-083  Failure to Handle Edge Cases SCSVS-COMP SCSVS-COMP-2 profile:L1 newstatus:new SCWE-004  Uncaught Exceptions SCSVS-ARCH SCSVS-ARCH-2 profile:L1 newstatus:new SCWE-080  Incorrect Type Conversion SCSVS-ARCH SCSVS-ARCH-2 profile:L1 newstatus:new SCWE-002  Excessive Contract Complexity SCSVS-ARCH SCSVS-ARCH-1 profile:L1 newstatus:new SCWE-001  Improper Contract Architecture SCSVS-ARCH SCSVS-ARCH-1 profile:L1 newstatus:new SCWE-070  Incorrect Constructor Name SCSVS-ARCH SCSVS-ARCH-1 profile:L1 newstatus:new SCWE-064  Incorrect Inheritance Order SCSVS-ARCH SCSVS-ARCH-2 profile:L1 newstatus:new SCWE-051  Improper Use of CREATE2 for Contract Deployment SCSVS-ARCH SCSVS-ARCH-2 profile:L1 newstatus:new SCWE-006  Inconsistent Inheritance Hierarchy SCSVS-ARCH SCSVS-ARCH-3 profile:L1 newstatus:new SCWE-052  Transaction Order Dependence SCSVS-ARCH SCSVS-ARCH-3 profile:L1 newstatus:new SCWE-003  Lack of Modularity SCSVS-ARCH SCSVS-ARCH-1 profile:L1 newstatus:new SCWE-005  Insecure Upgradeable Proxy Design SCSVS-ARCH SCSVS-ARCH-2 profile:L1 newstatus:new SCWE-071  Uninitialized Storage Pointer SCSVS-ARCH SCSVS-ARCH-1 profile:L1 newstatus:new SCWE-081  Improper Handling of Nonce SCSVS-GOV SCSVS-GOV-2 profile:L1 newstatus:new SCWE-015  Poor Governance Documentation SCSVS-GOV SCSVS-GOV-3 profile:L1 newstatus:new SCWE-079  Insecure Use of Transfer and Send SCSVS-GOV SCSVS-GOV-3 profile:L1 newstatus:new SCWE-012  Lack of Multisig Governance SCSVS-GOV SCSVS-GOV-1 profile:L1 newstatus:new SCWE-037  Insufficient Protection Against Front-Running SCSVS-GOV SCSVS-GOV-3 profile:L1 newstatus:new SCWE-075  Incorrect Ether Balance Tracking SCSVS-GOV SCSVS-GOV-3 profile:L1 newstatus:new SCWE-043  Insecure Use of Fallback Functions SCSVS-GOV SCSVS-GOV-3 profile:L1 newstatus:new SCWE-078  Improper Handling of Ether Transfers SCSVS-GOV SCSVS-GOV-3 profile:L1 newstatus:new SCWE-044  Insecure Use of Storage SCSVS-GOV SCSVS-GOV-1 profile:L1 newstatus:new SCWE-059  Insufficient Gas Griefing SCSVS-DEFI SCSVS-DEFI-2 profile:L1 newstatus:new SCWE-036  Inadequate Gas Limit Handling SCSVS-DEFI SCSVS-DEFI-1 profile:L1 newstatus:new SCWE-082  Lack of Proper Gas Management SCSVS-DEFI SCSVS-DEFI-1 profile:L1 newstatus:new SCWE-077  Lack of Rate Limiting SCSVS-DEFI SCSVS-DEFI-2 profile:L1 newstatus:new SCWE-058  DoS with Block Gas Limit SCSVS-DEFI SCSVS-DEFI-1 profile:L1 newstatus:new SCWE-021  Unsecured Data Transmission SCSVS-COMM SCSVS-COMM-1 profile:L1 newstatus:new SCWE-023  Lack of Communication Authenticity SCSVS-COMM SCSVS-COMM-1 profile:L1 newstatus:new SCWE-042  Insecure Use of External Calls SCSVS-COMM SCSVS-COMM-2 profile:L1 newstatus:new SCWE-063  Insecure Event Emission SCSVS-COMM SCSVS-COMM-2 profile:L1 newstatus:new SCWE-035  Insecure Delegatecall Usage SCSVS-COMM SCSVS-COMM-1 profile:L1 newstatus:new SCWE-022  Message Replay Vulnerabilities SCSVS-COMM SCSVS-COMM-1 profile:L1 newstatus:new SCWE-029  Lack of Decentralized Oracle Sources SCSVS-ORACLE SCSVS-ORACLE-1 profile:L1 newstatus:new SCWE-086  Missing Validation of Oracle Response Fields (Stale or Incomplete Data) SCSVS-ORACLE SCSVS-ORACLE-1 profile:L1 newstatus:new SCWE-028  Price Oracle Manipulation SCSVS-ORACLE SCSVS-ORACLE-1 profile:L1 newstatus:new SCWE-030  Insecure Oracle Data Updates SCSVS-ORACLE SCSVS-ORACLE-1 profile:L1 newstatus:new SCWE-088  Improper Decimal Normalization in Price-Based Calculations SCSVS-ORACLE SCSVS-ORACLE-1 profile:L1 newstatus:new SCWE-085  Misuse of Oracle Min/Max Price Band Without Validation SCSVS-ORACLE SCSVS-ORACLE-1 profile:L1 newstatus:new SCWE-032  Dependency on Block Gas Limit SCSVS-BRIDGE SCSVS-BRIDGE-2 profile:L1 newstatus:new SCWE-033  Chain Split Risks SCSVS-BRIDGE SCSVS-BRIDGE-1 profile:L1 newstatus:new SCWE-087  Missing Payload Size Validation in Cross-Chain Messaging (Denial of Service/Stuck Funds) SCSVS-BRIDGE SCSVS-BRIDGE-2 profile:L1 newstatus:new SCWE-034  Insecure Cross-Chain Messaging SCSVS-BRIDGE SCSVS-BRIDGE-2 profile:L1 newstatus:new SCWE-016  Insufficient Authorization Checks SCSVS-AUTH SCSVS-AUTH-2 profile:L1 newstatus:new SCWE-038  Insecure Use of Selfdestruct SCSVS-AUTH SCSVS-AUTH-1 profile:L1 newstatus:new SCWE-050  Unprotected SELFDESTRUCT Instruction SCSVS-AUTH SCSVS-AUTH-2 profile:L1 newstatus:new SCWE-020  Absence of Time-Locked Functions SCSVS-AUTH SCSVS-AUTH-2 profile:L1 newstatus:new SCWE-017  Privileged Role Mismanagement SCSVS-AUTH SCSVS-AUTH-1 profile:L1 newstatus:new SCWE-019  Insecure Signature Verification SCSVS-AUTH SCSVS-AUTH-2 profile:L1 newstatus:new SCWE-018  Use of tx.origin for Authorization SCSVS-AUTH SCSVS-AUTH-1 profile:L1 newstatus:new SCWE-045  Insecure Use of Modifiers SCSVS-AUTH SCSVS-AUTH-2 profile:L1 newstatus:new SCWE-049  Unprotected Ether Withdrawal SCSVS-AUTH SCSVS-AUTH-2 profile:L1 newstatus:new SCWE-026  Insufficient Hash Verification SCSVS-CRYPTO SCSVS-CRYPTO-2 profile:L1 newstatus:new SCWE-027  Vulnerable Cryptographic Algorithms SCSVS-CRYPTO SCSVS-CRYPTO-2 profile:L1 newstatus:new SCWE-025  Improper Cryptographic Key Management SCSVS-CRYPTO SCSVS-CRYPTO-1 profile:L1 newstatus:new SCWE-056  Lack of Proper Signature Verification SCSVS-CRYPTO SCSVS-CRYPTO-1 profile:L1 newstatus:new SCWE-055  Missing Protection against Signature Replay Attacks SCSVS-CRYPTO SCSVS-CRYPTO-1 profile:L1 newstatus:new SCWE-084  Insecure Use of blockhash SCSVS-CRYPTO SCSVS-CRYPTO-2 profile:L1 newstatus:new SCWE-074  Hash Collisions with Multiple Variable Length Arguments SCSVS-CRYPTO SCSVS-CRYPTO-2 profile:L1 newstatus:new SCWE-054  Signature Malleability SCSVS-CRYPTO SCSVS-CRYPTO-2 profile:L1 newstatus:new SCWE-046  Reentrancy Attacks SCSVS-CODE SCSVS-CODE-2 profile:L1 newstatus:new SCWE-047  Integer Overflows and Underflows SCSVS-CODE SCSVS-CODE-2 profile:L1 newstatus:new SCWE-013  Unauthorized Parameter Changes SCSVS-GOV SCSVS-GOV-2 profile:L1 newstatus:new SCWE-092  Missing Disable Initializer in Constructor for Proxy Contracts SCSVS-CODE SCSVS-CODE-1 profile:L1 profile:L2 newstatus:new SCWE-007  Presence of Unused Variables SCSVS-CODE SCSVS-CODE-2 profile:L1 newstatus:new SCWE-010  Shadowing Variables and Functions SCSVS-CODE SCSVS-CODE-2 profile:L1 newstatus:new SCWE-060  Floating Pragma SCSVS-CODE SCSVS-CODE-1 profile:L1 newstatus:new SCWE-090  Missing Slippage Protection in Automated Token Swaps SCSVS-CODE SCSVS-CODE-1 profile:L1 newstatus:new SCWE-014  Lack of Emergency Stop Mechanism SCSVS-GOV SCSVS-GOV-3 profile:L1 newstatus:new SCWE-053  Improper Deletion of Mappings SCSVS-CODE SCSVS-CODE-1 profile:L1 newstatus:new SCWE-072  Use of Deprecated Solidity Functions SCSVS-CODE SCSVS-CODE-1 profile:L1 newstatus:new SCWE-069  Shadowing State Variables SCSVS-CODE SCSVS-CODE-2 profile:L1 newstatus:new SCWE-066  Incorrect Handling of Bitwise Operations SCSVS-CODE SCSVS-CODE-2 profile:L1 newstatus:new SCWE-091  Lack of Zero Value Check in Token Transfers SCSVS-CODE SCSVS-CODE-1 profile:L1 newstatus:new SCWE-040  Incorrect Storage Packing SCSVS-CODE SCSVS-CODE-1 profile:L1 newstatus:new SCWE-061  Outdated Compiler Version SCSVS-CODE SCSVS-CODE-2 profile:L1 newstatus:new SCWE-067  Assert Violation SCSVS-CODE SCSVS-CODE-2 profile:L1 newstatus:new SCWE-009  Deprecated Variable and Function Usage SCSVS-CODE SCSVS-CODE-2 profile:L1 newstatus:new SCWE-089  Vulnerable &amp; Outdated Libraries SCSVS-CODE SCSVS-CODE-1 profile:L1 newstatus:new SCWE-041  Unsafe Downcasting SCSVS-CODE SCSVS-CODE-1 profile:L1 newstatus:new SCWE-068  State Variable Default Visibility SCSVS-CODE SCSVS-CODE-1 profile:L1 newstatus:new SCWE-076  Right-To-Left-Override Control Character (U+202E) SCSVS-CODE SCSVS-CODE-2 profile:L1 newstatus:new SCWE-062  Dead Code SCSVS-CODE SCSVS-CODE-1 profile:L1 newstatus:new SCWE-039  Insecure Use of Inline Assembly SCSVS-CODE SCSVS-CODE-2 profile:L1 newstatus:new SCWE-048  Unchecked Call Return Value SCSVS-CODE SCSVS-CODE-1 profile:L1 newstatus:new SCWE-008  Hardcoded Constants SCSVS-CODE SCSVS-CODE-2 profile:L1 newstatus:new SCWE-011  Insecure ABI Encoding and Decoding SCSVS-ARCH SCSVS-ARCH-3 profile:L1 newstatus:new <p></p>","tags":[]},{"location":"SCWE/SCSVS-ARCH/SCWE-001/","title":"SCWE-001: Improper Contract Architecture","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-001/#relationships","title":"Relationships","text":"<ul> <li>CWE-1008: Architectural Concepts   https://cwe.mitre.org/data/definitions/1008.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-001/#description","title":"Description","text":"<p>Improper contract architecture refers to the flawed design of a smart contract\u2019s structure, which compromises its security, scalability, and maintainability. This often occurs due to monolithic designs, inefficient inheritance structures, and poor separation of concerns. Such flaws create challenges in managing, upgrading, and auditing the contract. Key issues associated with improper architecture include:</p> <ul> <li>Difficulty in upgrading the contract without introducing risks.</li> <li>Increased complexity leading to hidden attack surfaces.</li> <li>Lack of flexibility in contract logic, making it hard to isolate bugs or exploits.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-001/#remediation","title":"Remediation","text":"<ul> <li>Modular design: Break down contracts into smaller, more manageable modules to ensure a clean separation of concerns.</li> <li>Proxy pattern implementation: Use proxies to allow contract upgrades while preserving contract state.</li> <li>Separate logic and state: Keep business logic and data storage separate to improve scalability and maintainability.</li> <li>Periodic code review and refactoring: Regularly assess the architecture and refactor to maintain efficiency and security.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-001/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-001/#improper-contract-architecture","title":"Improper Contract Architecture","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract MonolithicContract {\n    uint public balance;\n    address public owner;\n\n    mapping(address =&gt; uint) public allowances;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function deposit(uint value) public {\n        balance += value;\n    }\n\n    function withdraw(uint value) public {\n        require(balance &gt;= value, \"Insufficient funds\");\n        balance -= value;\n        payable(msg.sender).transfer(value);\n    }\n\n    function transfer(address to, uint value) public {\n        require(balance &gt;= value, \"Insufficient funds\");\n        balance -= value;\n        payable(to).transfer(value);\n    }\n\n    function approve(address spender, uint value) public {\n        allowances[spender] = value;\n    }\n\n    function transferFrom(address from, address to, uint value) public {\n        require(allowances[from] &gt;= value, \"Allowance exceeded\");\n        allowances[from] -= value;\n        payable(to).transfer(value);\n    }\n\n    function upgradeLogic() public {\n        require(msg.sender == owner, \"Not authorized\");\n        // Upgrading logic is impossible without deploying a new contract.\n    }\n}\n</code></pre> <p>Problem: The contract has a monolithic design, tightly coupling storage, business logic, and access control. This makes upgrading or fixing specific parts difficult.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-001/#improved-modular-contract-architecture","title":"Improved Modular Contract Architecture","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract Deposit {\n    uint public balance;\n\n    function deposit() public {\n        // Logic for deposit\n    }\n}\n\ncontract Withdraw {\n    uint public balance;\n\n    function withdraw() public {\n        // Logic for withdrawal\n    }\n}\n\ncontract Transfer {\n    uint public balance;\n\n    function transfer() public {\n        // Logic for transfer\n    }\n}\n</code></pre> <p>Solution: Separate storage from logic using proxy patterns. Now the contract logic can be updated without touching storage!</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-002/","title":"SCWE-002: Excessive Contract Complexity","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-002/#relationships","title":"Relationships","text":"<ul> <li>CWE-710: Improper Adherence to Coding Standards https://cwe.mitre.org/data/definitions/710.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-002/#description","title":"Description","text":"<p>Excessive contract complexity refers to situations where the design or implementation of a smart contract becomes overly complicated, making it difficult to understand, audit, and maintain. Such complexity increases the likelihood of introducing bugs and vulnerabilities that may not be apparent during development or testing. It often arises from:</p> <ul> <li>Overuse of complex inheritance structures or external libraries.</li> <li>Too many functions, interdependencies, and conditions within the contract.</li> <li>Unnecessarily convoluted logic that could be simplified.</li> </ul> <p>The more complex the code, the higher the chance that mistakes are made, especially if future developers or auditors need to interact with the contract. Complexity can lead to hidden vulnerabilities that may be exploited over time.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-002/#remediation","title":"Remediation","text":"<ul> <li>Refactor and simplify the code: Break down complex functions into smaller, easier-to-understand components.</li> <li>Limit inheritance depth: Use inheritance judiciously and prefer composition over deep inheritance chains.</li> <li>Use clear and descriptive names: Functions, variables, and events should have self-explanatory names that indicate their purpose.</li> <li>Avoid redundant logic: Consolidate repeated logic into reusable functions or libraries.</li> <li>Ensure modularity: Split the contract into manageable modules that focus on specific tasks, improving readability and maintainability.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-002/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-002/#excessive-complexity","title":"Excessive Complexity","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract ComplexContract {\n    uint public balance;\n    address public owner;\n\n    function ComplexFunction1(uint value) public {\n        // Complex logic with many conditions\n        if (value &gt; 10) {\n            // do something\n        }\n        // Multiple nested functions and too many conditions\n        for (uint i = 0; i &lt; value; i++) {\n            if (i % 2 == 0) {\n                // nested loop\n            }\n        }\n    }\n\n    function ComplexFunction2(address addr) public {\n        // Complex logic with external dependencies\n        SomeLibrary.someFunction(addr);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-002/#simplified-version","title":"Simplified Version","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract SimpleContract {\n    uint public balance;\n    address public owner;\n\n    function deposit(uint value) public {\n        balance += value;\n    }\n\n    function withdraw(uint value) public {\n        require(balance &gt;= value, \"Insufficient funds\");\n        balance -= value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-003/","title":"SCWE-003: Lack of Modularity","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-003/#relationships","title":"Relationships","text":"<ul> <li>CWE-1047: Modules with Circular Dependencies   https://cwe.mitre.org/data/definitions/1047.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-003/#description","title":"Description","text":"<p>Lack of modularity refers to a design flaw where a system's components are not sufficiently separated into independent, reusable modules. This deficiency leads to tightly coupled code, making the system difficult to understand, maintain, and extend. In the context of smart contracts, this manifests as monolithic contracts where all functionalities are bundled together, increasing complexity and the potential for errors.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-003/#remediation","title":"Remediation","text":"<ul> <li>Modular Design: Break down the contract into smaller, focused modules that handle specific responsibilities.</li> <li>Use of Libraries: Leverage existing, well-tested libraries to handle common functionalities, reducing the need for custom code.</li> <li>Simplify Logic: Avoid unnecessary complexity by streamlining the contract's logic and removing redundant code.</li> <li>Regular Audits: Conduct periodic code reviews and audits to identify and address areas of excessive complexity.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-003/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-003/#example-of-lack-of-modularity","title":"Example of Lack of Modularity:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract TightlyCoupledContract {\n    mapping(address =&gt; uint) public balances;\n    mapping(address =&gt; mapping(address =&gt; uint)) public allowances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient funds\");\n        balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n    }\n\n    function transfer(address to, uint amount) public {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient funds\");\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n    }\n\n    function approve(address spender, uint amount) public {\n        allowances[msg.sender][spender] = amount;\n    }\n\n    function transferFrom(address from, address to, uint amount) public {\n        require(allowances[from][msg.sender] &gt;= amount, \"Allowance exceeded\");\n        allowances[from][msg.sender] -= amount;\n        balances[from] -= amount;\n        balances[to] += amount;\n    }\n}\n</code></pre> <p>Problem: Instead of separating concerns into independent, reusable modules, everything is handled within one contract.</p> <p>Why is this lack of modularity?</p> <ul> <li>Single contract handling multiple responsibilities (balance management, approvals, transfers).</li> <li>Code is not reusable: If another contract needs balance functions, it must copy-paste this logic.</li> <li>Testing is harder: Changing transfer() might break withdraw(), as they're tightly coupled.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-003/#refactored-with-modular-design","title":"Refactored with Modular Design:","text":"<pre><code>pragma solidity ^0.8.0;\n\nlibrary BalanceLibrary {\n    struct Data {\n        mapping(address =&gt; uint) balances;\n    }\n\n    function deposit(Data storage self, address user, uint amount) internal {\n        self.balances[user] += amount;\n    }\n\n    function withdraw(Data storage self, address user, uint amount) internal {\n        require(self.balances[user] &gt;= amount, \"Insufficient funds\");\n        self.balances[user] -= amount;\n        payable(user).transfer(amount);\n    }\n}\n\nlibrary AllowanceLibrary {\n    struct Data {\n        mapping(address =&gt; mapping(address =&gt; uint)) allowances;\n    }\n\n    function approve(Data storage self, address owner, address spender, uint amount) internal {\n        self.allowances[owner][spender] = amount;\n    }\n\n    function transferFrom(\n        Data storage self,\n        BalanceLibrary.Data storage balances,\n        address from,\n        address to,\n        uint amount\n    ) internal {\n        require(self.allowances[from][msg.sender] &gt;= amount, \"Allowance exceeded\");\n        require(balances.balances[from] &gt;= amount, \"Insufficient funds\");\n\n        self.allowances[from][msg.sender] -= amount;\n        balances.balances[from] -= amount;\n        balances.balances[to] += amount;\n    }\n}\n\ncontract ModularContract {\n    using BalanceLibrary for BalanceLibrary.Data;\n    using AllowanceLibrary for AllowanceLibrary.Data;\n\n    BalanceLibrary.Data private balances;\n    AllowanceLibrary.Data private allowances;\n\n    function deposit() public payable {\n        balances.deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint amount) public {\n        balances.withdraw(msg.sender, amount);\n    }\n\n    function approve(address spender, uint amount) public {\n        allowances.approve(msg.sender, spender, amount);\n    }\n\n    function transferFrom(address from, address to, uint amount) public {\n        allowances.transferFrom(balances, from, to, amount);\n    }\n}\n</code></pre> <p>Solution: Use libraries for shared functionality and separate contract concerns. Now, storage is separated, reusable libraries are used, and responsibilities are divided!</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/","title":"SCWE-004: Uncaught Exceptions","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#relationships","title":"Relationships","text":"<ul> <li>CWE-703: Improper Check or Handling of Exceptional Conditions https://cwe.mitre.org/data/definitions/703.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#description","title":"Description","text":"<p>Uncaught exceptions occur when a smart contract fails to properly handle errors, leading to unintended behaviors, lost funds, or denial of service (DoS). In Solidity, low-level calls such as <code>call()</code>, <code>delegatecall()</code>, and <code>send()</code> return a boolean instead of reverting automatically, requiring explicit checks. Ignoring return values or using <code>assert()</code> instead of <code>require()</code> can result in vulnerabilities that attackers can exploit.</p> <p>Common issues with uncaught exceptions: - Ignoring return values of <code>call()</code>, <code>delegatecall()</code>, <code>send()</code> - Unchecked external contract calls - Incorrect use of <code>assert()</code> instead of <code>require()</code> - Failure to catch errors in <code>try/catch</code> blocks</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#remediation","title":"Remediation","text":"<ul> <li>Check Return Values: Always verify the return values of low-level calls to ensure execution succeeded.</li> <li>Use <code>require()</code> for Input Validation: <code>require()</code> should be used for checking user input, while <code>assert()</code> should only be used for invariants.</li> <li>Implement Try/Catch: Use <code>try/catch</code> when interacting with external contracts to prevent silent failures.</li> <li>Use Safe Libraries: Utilize OpenZeppelin\u2019s <code>SafeERC20</code> for secure token transfers.</li> <li>Minimize External Dependencies: Avoid relying on external contract behavior unless necessary.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#example-1-uncaught-exception","title":"Example 1: Uncaught Exception:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract UncheckedCall {\n    function execute(address target, bytes memory data) public payable {\n        target.call{value: msg.value}(data); // \u274c No success check\n    }\n}\n</code></pre> <p>In the above example, <code>call()</code> returns a boolean indicating success, but it is ignored, which can lead to silent failures.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#refactored-to-handle-exceptions-properly","title":"Refactored to Handle Exceptions Properly:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SafeCall {\n    function execute(address target, bytes memory data) public payable {\n        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);\n        require(success, \"Call execution failed\"); // \u2705 Handle failure\n    }\n}\n</code></pre> <p>In this improved version, the contract checks whether <code>call()</code> was successful, preventing execution from continuing on failure.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#example-2-bad-practice-using-assert-instead-of-require","title":"Example 2: Bad Practice (Using assert() Instead of require())","text":"<ul> <li>Problem: Using assert() for input validation instead of require().</li> </ul> <pre><code>pragma solidity ^0.8.0;\n\ncontract WrongAssertion {\n    function withdraw(uint256 amount) public {\n        assert(amount &gt; 0); // \u274c Assert should not be used for input validation\n        // Withdraw logic here\n    }\n}\n</code></pre> <p>Why is this vulnerable? - <code>assert()</code> is meant for invariants, not input validation. - If <code>assert()</code> fails, it consumes all remaining gas and does not return gas to the caller.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#better-practice-fixing-input-validation","title":"Better Practice (Fixing Input Validation)","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract CorrectValidation {\n    function withdraw(uint256 amount) public {\n        require(amount &gt; 0, \"Invalid amount\"); // \u2705 Proper validation\n        // Withdraw logic here\n    }\n}\n</code></pre> - Now, a proper <code>require()</code> statement prevents execution if amount is invalid.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#example-3-bad-practice-failure-to-catch-errors-in-trycatch","title":"Example 3: Bad Practice (Failure to Catch Errors in Try/Catch)","text":"<ul> <li>Problem: Not using try/catch for external contract calls.</li> </ul> <pre><code>pragma solidity ^0.8.0;\n\ninterface ExternalContract {\n    function riskyFunction() external;\n}\n\ncontract NoErrorHandling {\n    function callExternal(address contractAddr) public {\n        ExternalContract(contractAddr).riskyFunction(); // \u274c No error handling\n    }\n}\n</code></pre> <p>Why is this vulnerable? - If riskyFunction() fails, the transaction completely reverts. - There is no way to recover or take alternative action.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-004/#better-practice-using-trycatch-for-external-calls","title":"Better Practice (Using Try/Catch for External Calls)","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ninterface ExternalContract {\n    function riskyFunction() external;\n}\n\ncontract SafeExternalCall {\n    function callExternal(address contractAddr) public {\n        try ExternalContract(contractAddr).riskyFunction() {\n            // \u2705 Success case\n        } catch {\n            revert(\"External call failed\"); // \u2705 Catch and handle failure\n        }\n    }\n}\n</code></pre> - Now, errors are properly caught, and alternative actions can be taken.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-005/","title":"SCWE-005: Insecure Upgradeable Proxy Design","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-005/#relationships","title":"Relationships","text":"<ul> <li>CWE-668: Exposure of Resource to Wrong Sphere   https://cwe.mitre.org/data/definitions/668.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-005/#description","title":"Description","text":"<p>Insecure upgradeable proxy designs occur when a smart contract implements an upgradeable proxy pattern without properly securing or validating upgrades. This may allow unauthorized actors to change the contract\u2019s logic, possibly introducing malicious behavior. It often happens when the upgrade functionality lacks proper access controls or when there is no timelock to delay the upgrade, giving malicious actors an opportunity to exploit the contract.</p> <p>This vulnerability can lead to critical failures, including the redirection of contract calls to malicious logic or unauthorized updates that compromise the integrity of the contract.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-005/#remediation","title":"Remediation","text":"<ul> <li>Access Control: Ensure only trusted parties (e.g., contract owners, multisig wallets) can perform upgrades.</li> <li>Timelock Mechanism: Implement a timelock to delay upgrades and provide transparency.</li> <li>Transparent Proxy Pattern: Use patterns that prevent unauthorized contract logic changes, such as the Transparent Proxy Pattern.</li> <li>Audit Proxy Logic Regularly: Conduct regular audits to ensure that the upgrade mechanism is secure and follows best practices.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-005/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-005/#vulnerable-proxy-contract","title":"Vulnerable Proxy Contract","text":"<p><pre><code>pragma solidity ^0.4.0;\n\ncontract VulnerableProxy {\n    address public implementation;\n    address public owner;\n\n    function setImplementation(address _implementation) public {\n        require(msg.sender == owner, \"Only owner can set implementation\");\n        implementation = _implementation;\n    }\n\n    function () public payable {\n        address _impl = implementation;\n        require(_impl != address(0), \"Implementation address is zero\");\n        assembly {\n            let result := delegatecall(gas, _impl, add(msg.data, 0x20), mload(msg.data), 0, 0)\n            let size := returndatasize\n            let ptr := mload(0x40)\n            return(ptr, size)\n        }\n    }\n}\n</code></pre> In this example, the <code>VulnerableProxy</code> contract allows the owner to update the implementation contract. If the owner is compromised, they can point the proxy to a malicious implementation, allowing the attacker to control the contract's logic.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-005/#fixed-proxy-contract-with-secure-upgrade-mechanism","title":"Fixed Proxy Contract with Secure Upgrade Mechanism","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract SecureProxy {\n    address public implementation;\n    address public owner;\n    uint public lastUpgradeTime;\n    uint public upgradeDelay = 1 days;  // 24 hours delay before upgrade\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can perform this action\");\n        _;\n    }\n\n    modifier upgradeable() {\n        require(now &gt;= lastUpgradeTime + upgradeDelay, \"Upgrade not allowed yet\");\n        _;\n    }\n\n    function setImplementation(address _implementation) public onlyOwner upgradeable {\n        implementation = _implementation;\n        lastUpgradeTime = now; // Update the last upgrade time\n    }\n\n    function () public payable {\n        address _impl = implementation;\n        require(_impl != address(0), \"Implementation address is zero\");\n        assembly {\n            let result := delegatecall(gas, _impl, add(msg.data, 0x20), mload(msg.data), 0, 0)\n            let size := returndatasize\n            let ptr := mload(0x40)\n            return(ptr, size)\n        }\n    }\n}\n</code></pre> <p>In the fixed <code>SecureProxy</code> contract, the following changes have been made:</p> <ul> <li>Access Control: The <code>onlyOwner</code> modifier ensures that only the contract owner can update the proxy\u2019s implementation.</li> <li>Timelock Mechanism: The <code>upgradeable</code> modifier adds a delay (set to 1 day in this example) to prevent rapid contract upgrades. The contract cannot be upgraded until the specified time has passed since the last upgrade.</li> <li>Secure Upgrade Logic: The proxy logic is updated only after passing the necessary access control and timelock checks.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-006/","title":"SCWE-006: Inconsistent Inheritance Hierarchy","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-006/#relationships","title":"Relationships","text":"<ul> <li>CWE-710: Improper Adherence to Coding Standards   https://cwe.mitre.org/data/definitions/710.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-006/#description","title":"Description","text":"<p>Inconsistent inheritance hierarchies occur when a contract inherits from multiple contracts or libraries in an inconsistent or contradictory way. This leads to unexpected behavior or errors due to conflicting function implementations, state variables, or access controls. A proper and consistent inheritance structure is essential for clear logic and predictable contract execution.</p> <p>Some common issues in inheritance hierarchies include: - Ambiguous function overrides. - Conflicting variable definitions. - Misuse of multiple inheritance, which can lead to the diamond problem.</p> <p>Inconsistent inheritance can significantly compromise a contract\u2019s functionality and security, especially when multiple contracts or libraries with similar function names are used.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-006/#remediation","title":"Remediation","text":"<ul> <li>Clear Inheritance Structure: Ensure that the inheritance hierarchy is logically structured and does not have overlapping functionalities or conflicting state variables.</li> <li>Use Explicit Overrides: Clearly override functions when necessary to avoid ambiguity, and ensure there is no unintentional function masking.</li> <li>Favor Single Inheritance or Controlled Multiple Inheritance: Avoid overly complex inheritance structures; if multiple inheritance is necessary, consider using design patterns like the Diamond Problem Resolver (i.e., using interfaces or abstract contracts).</li> <li>Regular Audits: Periodically audit the inheritance structure to identify any inconsistencies early on.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-006/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-006/#vulnerable-contract-with-inconsistent-inheritance","title":"Vulnerable Contract with Inconsistent Inheritance","text":"<p><pre><code>pragma solidity ^0.4.0;\n\ncontract ParentA {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n\ncontract ParentB {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value * 2;\n    }\n}\n\ncontract Child is ParentA, ParentB {\n    function setValue(uint _value) public {\n        // Ambiguity: which `setValue` should be called?\n        ParentA.setValue(_value);\n    }\n}\n</code></pre> In the above example, the <code>Child</code> contract inherits from both <code>ParentA</code> and <code>ParentB</code>. Both parent contracts define the <code>setValue</code> function. There is no clear indication of which function should be called, leading to ambiguity and potential bugs or undesired behavior.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-006/#fixed-contract-with-consistent-inheritance","title":"Fixed Contract with Consistent Inheritance","text":"<p><pre><code>pragma solidity ^0.4.0;\n\ncontract ParentA {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n\ncontract ParentB {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value * 2;\n    }\n}\n\ncontract Child is ParentA {\n    // Clear function override, only inherits from one parent\n    function setValue(uint _value) public {\n        ParentA.setValue(_value);\n    }\n}\n</code></pre> In the fixed version of the contract, the <code>Child</code> contract only inherits from one parent (<code>ParentA</code>), which resolves the ambiguity. If both <code>ParentA</code> and <code>ParentB</code> were needed, explicit overriding or more careful contract design would be required to ensure the correct functionality.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-051/","title":"SCWE-051: Improper Use of CREATE2 for Contract Deployment","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-051/#relationships","title":"Relationships","text":"<ul> <li>CWE-706: Use of Incorrectly-Resolved Name or Reference https://cwe.mitre.org/data/definitions/706.html </li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-051/#description","title":"Description","text":"<p>The <code>CREATE2</code> opcode allows for deterministic contract deployment, meaning the contract's address can be precomputed before deployment. However, improper handling of the salt parameter, constructor arguments, or contract bytecode can lead to vulnerabilities such as address predictability, re-deployment attacks, and malicious contract substitution. If an attacker can influence the salt or code, they may deploy a contract at a known address before the legitimate one, leading to security risks.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-051/#remediation","title":"Remediation","text":"<p>To prevent misuse of <code>CREATE2</code>: - Use unpredictable and unique salt values (e.g., incorporating nonces, sender addresses, or randomness). - Ensure the deployed contract logic remains consistent to prevent re-deployment attacks. - Hash important contract parameters into the salt to prevent unintended address collisions.  </p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-051/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Factory {\n    function deploy(bytes32 salt, bytes memory bytecode) public {\n        address deployed;\n        assembly {\n            deployed := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n    }\n}\n</code></pre> <p>Why is this vulnerable?</p> <ul> <li>If <code>salt</code> is predictable (e.g., user-supplied or a static value), an attacker can precompute and front-run the deployment.</li> <li>The same contract address can be re-used by deploying different bytecode, leading to logic changes at a fixed address.</li> <li>No validation ensures that the deployed contract is safe or expected.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-051/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract SecureFactory {\n    function deploy(bytes32 salt, bytes memory bytecode) public returns (address) {\n        require(bytecode.length &gt; 0, \"Bytecode cannot be empty\");\n\n        // Ensure the salt includes sender information to prevent front-running\n        bytes32 secureSalt = keccak256(abi.encodePacked(msg.sender, salt));\n\n        address deployed;\n        assembly {\n            deployed := create2(0, add(bytecode, 0x20), mload(bytecode), secureSalt)\n        }\n\n        require(deployed != address(0), \"Deployment failed\");\n        return deployed;\n    }\n}\n</code></pre> <p>Why is this safe? - Uses <code>keccak256(abi.encodePacked(msg.sender, salt))</code> to make the salt unique per sender. - Ensures the contract bytecode is non-empty before deploying. - Validates that the deployed contract is nonzero, ensuring a successful deployment.</p> <p>By securing CREATE2 deployments, developers can prevent predictable contract addresses, front-running risks, and contract replacement vulnerabilities.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-052/","title":"SCWE-052: Transaction Order Dependence","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-052/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html </li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-052/#description","title":"Description","text":"<p>Transaction Order Dependence (TOD) occurs when the outcome of a contract's execution depends on the order of transactions. Attackers can exploit this issue by submitting transactions in a specific order, manipulating the contract's state and gaining an unfair advantage, such as front-running or back-running other transactions. This can lead to unexpected behavior and resource consumption.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-052/#remediation","title":"Remediation","text":"<p>To mitigate TOD vulnerabilities, ensure that the contract's logic does not depend on transaction order. Use techniques like commit-reveal schemes or randomization to prevent attackers from predicting the transaction order and exploiting it.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-052/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract TODExample {\n    address public winner;\n\n    function bid() public payable {\n        require(msg.value &gt; 1 ether, \"Bid too low\");\n        winner = msg.sender;  // Dependent on transaction order\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-052/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract FixedTODExample {\n    address public winner;\n    uint public highestBid;\n\n    function bid() public payable {\n        require(msg.value &gt; highestBid, \"Bid too low\");\n        highestBid = msg.value;\n        winner = msg.sender;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-ARCH/SCWE-064/","title":"SCWE-064: Incorrect Inheritance Order","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-064/#relationships","title":"Relationships","text":"<ul> <li>CWE-1001: Variable Shadowing https://cwe.mitre.org/data/definitions/1001.html </li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-064/#description","title":"Description","text":"<p>Incorrect inheritance order in Solidity can lead to unintended behavior, especially when multiple base contracts define similar variables or functions. Solidity\u2019s linearization of the inheritance order can result in one contract unintentionally overriding or shadowing variables or functions defined in a parent contract, leading to confusion, errors, and potential vulnerabilities.</p> <p>In Solidity, the order of inheritance matters. If the inheritance hierarchy is not properly structured, the wrong version of a variable or function may be called, causing bugs or security issues.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-064/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, carefully review and order the inheritance structure. Ensure that parent contracts are inherited in a logical sequence and that any variables or functions are not unintentionally shadowed or overridden. Consider following a clear and consistent inheritance pattern.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-064/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract BaseA {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n\ncontract BaseB {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value + 1;  // Different implementation\n    }\n}\n\ncontract Child is BaseB, BaseA {\n    function setValue(uint _value) public {\n        value = _value + 2;  // Shadows value from BaseA or BaseB\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-064/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract BaseA {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n\ncontract BaseB {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value + 1;  // Different implementation\n    }\n}\n\ncontract Child is BaseA, BaseB {\n    function setValue(uint _value) public {\n        value = _value + 2;  // Calls setValue from BaseA or BaseB intentionally\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-070/","title":"SCWE-070: Incorrect Constructor Name","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-070/#relationships","title":"Relationships","text":"<ul> <li>CWE-1001: Variable Shadowing https://cwe.mitre.org/data/definitions/1001.html </li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-070/#description","title":"Description","text":"<p>In Solidity, the constructor is a special function used to initialize a contract's state variables when it is deployed. If a constructor is incorrectly named, it will not function as expected, leading to issues such as failing to initialize state variables or triggering unexpected behavior. The constructor must have the exact name of the contract and no return type.</p> <p>If the constructor name is not correct, it will not be executed as intended, and the contract may not behave as expected, potentially leaving it in an uninitialized or inconsistent state.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-070/#remediation","title":"Remediation","text":"<p>Ensure that the constructor has the correct name, which must match the contract name and contain no return type. In newer versions of Solidity (0.4.22 and later), the constructor keyword is used instead of the contract name for constructor functions.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-070/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    uint public value;\n\n    // Incorrect constructor name (for Solidity &lt;0.4.22)\n    function Example() public {  // Constructor name must match the contract name in older Solidity versions\n        value = 10;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-070/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Example {\n    uint public value;\n\n    // Correct constructor definition (Solidity &gt;=0.4.22)\n    constructor() public {  // Use \"constructor\" instead of the contract name\n        value = 10;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-071/","title":"SCWE-071: Uninitialized Storage Pointer","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-071/#relationships","title":"Relationships","text":"<ul> <li>CWE-457: Use of Uninitialized Variable https://cwe.mitre.org/data/definitions/457.html </li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-071/#description","title":"Description","text":"<p>An uninitialized storage pointer in Solidity refers to a variable that has been declared but not assigned a value before being used. This can result in unpredictable behavior, as the variable might point to unintended locations in the contract's storage, potentially exposing sensitive data or allowing attackers to exploit the uninitialized pointer. This is a critical issue because Solidity does not automatically initialize storage variables, leaving them with default values that may be unsafe.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-071/#remediation","title":"Remediation","text":"<p>Always initialize storage pointers to avoid potential vulnerabilities. Ensure that all variables, especially storage pointers, are properly assigned a value before being used. This prevents accessing uninitialized or garbage data from the contract\u2019s storage.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-071/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    uint[] public data;\n\n    // Uninitialized storage pointer, could lead to unexpected behavior\n    function addData(uint _value) public {\n        data.push(_value);\n        uint[] storage uninitializedPointer;  // Pointer is uninitialized\n        uninitializedPointer.push(10);  // Accessing uninitialized storage pointer\n    }\n}\n</code></pre> <p>Why is this vulnerable? - <code>uninitializedPointer</code> is a storage pointer but is not assigned a reference to valid storage. - Writing to <code>uninitializedPointer.push(10);</code> could overwrite unintended storage locations.</p> <p>Potential outcomes: - Corrupting storage layout (e.g., overwriting contract variables). - Unexpected behaviors due to storage reallocation.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-071/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>  contract Example {\n      uint[] public data;\n\n      function addData(uint _value) public {\n          data.push(_value);\n          uint[] storage initializedPointer = data;  // \u2705 Properly initialized storage pointer\n          initializedPointer.push(10);  // \u2705 Safely interacts with the intended storage\n      }\n  }\n</code></pre> <p>Why is this safe? - <code>initializedPointer</code> explicitly references <code>data</code>, ensuring that it does not point to an arbitrary storage slot. - Prevents unintended overwrites of contract state. - Ensures expected behavior and protects contract integrity.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-1"]},{"location":"SCWE/SCSVS-ARCH/SCWE-080/","title":"SCWE-080: Incorrect Type Conversion","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-080/#relationships","title":"Relationships","text":"<ul> <li>CWE-704: Incorrect Type Conversion or Cast https://cwe.mitre.org/data/definitions/704.html </li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-080/#description","title":"Description","text":"<p>Incorrect type conversion occurs when a value is cast or implicitly converted between incompatible types, potentially leading to precision loss, unexpected behavior, or security vulnerabilities. Solidity allows certain implicit conversions (e.g., from <code>uint256</code> to <code>uint8</code>), which can lead to silent truncation of data. Additionally, casting between types like <code>address</code> and <code>uint</code> can lead to unexpected security risks.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-080/#remediation","title":"Remediation","text":"<ul> <li>Avoid unsafe downcasts from larger to smaller types unless explicitly required.  </li> <li>Always validate the range before converting between numerical types.  </li> <li>Use explicit conversion functions where applicable, ensuring proper handling of edge cases.  </li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-080/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<p><pre><code>contract Example {\n    function unsafeDowncast(uint256 value) public pure returns (uint8) {\n        return uint8(value);  // \u274c Truncates value if &gt; 255\n    }\n\n    function unsafeAddressToUint(address addr) public pure returns (uint256) {\n        return uint256(uint160(addr));  // \u274c May lead to unexpected behaviors\n    }\n}\n</code></pre> Why is this vulnerable?</p> <ul> <li><code>uint8(value)</code> will silently truncate values above 255, leading to unintended loss of data.</li> <li><code>uint256(uint160(addr))</code> might be used incorrectly in arithmetic operations, potentially allowing address manipulation.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-ARCH/SCWE-080/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>contract SecureExample {\n    function safeDowncast(uint256 value) public pure returns (uint8) {\n        require(value &lt;= type(uint8).max, \"Value exceeds uint8 range\");  // \u2705 Ensure valid range\n        return uint8(value);\n    }\n\n    function safeAddressToUint(address addr) public pure returns (uint160) {\n        return uint160(addr);  // \u2705 Restrict conversion to valid 160-bit range\n    }\n}\n</code></pre> Why is this safe?</p> <ul> <li>Ensures that values do not exceed the allowed range before downcasting.</li> <li>Re- stricts type conversion to avoid security risks from improper arithmetic operations.</li> <li>Prevents silent data loss that could lead to unintended contract behavior.</li> </ul> <p>By enforcing safe type conversions, developers can ensure contract logic remains reliable and free from unexpected truncation issues.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-016/","title":"SCWE-016: Insufficient Authorization Checks","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-016/#relationships","title":"Relationships","text":"<ul> <li>CWE-862: Missing Authorization   https://cwe.mitre.org/data/definitions/862.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-016/#description","title":"Description","text":"<p>Insufficient authorization occurs when the contract does not verify whether a user has the appropriate permissions to perform specific actions. This vulnerability arises when there are missing or improperly implemented authorization checks, allowing unauthorized users to access functions they should not have access to.</p> <p>Common causes of insufficient authorization include: - Missing access control modifiers or incorrect configuration. - Failure to validate roles before granting access to sensitive functions. - Poor handling of user permissions, which could lead to privilege escalation.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-016/#remediation","title":"Remediation","text":"<ul> <li>Implement role-based access control (RBAC): Define roles such as <code>admin</code>, <code>user</code>, etc., and assign permissions accordingly to ensure only authorized users can call restricted functions.</li> <li>Use access control modifiers: Protect sensitive functions with appropriate modifiers (e.g., <code>onlyOwner</code>, <code>onlyAdmin</code>) to restrict access.</li> <li>Principle of least privilege: Ensure each user only has access to the minimal set of actions they need to perform their role.</li> <li>Thorough testing: Test for authorization vulnerabilities to ensure all restricted functions are properly secured.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-016/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-016/#insufficient-authorization-example","title":"Insufficient Authorization Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract InsufficientAuthorization {\n    uint public balance;\n\n    function withdraw(uint amount) public {\n        // No checks for user roles, any address can withdraw funds\n        balance -= amount;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-016/#fixed-authorization-example","title":"Fixed Authorization Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract FixedAuthorization {\n    uint public balance;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not authorized\");\n        _;\n    }\n\n    function withdraw(uint amount) public onlyOwner {\n        balance -= amount;\n    }\n}\n</code></pre> In the fixed example, the <code>onlyOwner</code> modifier ensures that only the contract owner can withdraw funds, thus preventing unauthorized users from performing sensitive operations like withdrawing assets.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-017/","title":"SCWE-017: Privileged Role Mismanagement","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-017/#relationships","title":"Relationships","text":"<ul> <li>CWE-269: Improper Privilege Management https://cwe.mitre.org/data/definitions/269.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-017/#description","title":"Description","text":"<p>Privileged role mismanagement occurs when a smart contract incorrectly assigns roles or permissions, granting excessive privileges to certain users. This can lead to users obtaining permissions beyond what is necessary for their intended function, creating a potential for privilege escalation or unauthorized actions. In the context of smart contracts, improper privilege management can lead to critical vulnerabilities such as unauthorized contract changes, malicious interactions, or loss of funds.</p> <p>Common causes include: - Insufficient checks for users attempting to access privileged functions. - Roles being dynamically assigned without validation. - Inadequate access control mechanisms for sensitive contract functions.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-017/#remediation","title":"Remediation","text":"<ul> <li>Role-based access control (RBAC): Implement strict role checks using modifiers to ensure that users can only perform actions that correspond to their assigned roles.</li> <li>Principle of least privilege: Limit the privileges of each role to the bare minimum needed to perform their task.</li> <li>Use of trusted or immutable sources: Ensure that privileged roles cannot be arbitrarily changed by unauthorized users or during attacks.</li> <li>Periodic reviews and audits: Regularly review roles and permissions to ensure they are correctly assigned and maintained.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-017/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-017/#privileged-role-mismanagement-example","title":"Privileged Role Mismanagement Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract PrivilegedRoleMismanagement {\n    address public admin;\n    uint public balance;\n\n    function setAdmin(address _admin) public {\n        admin = _admin;\n    }\n\n    function withdraw(uint amount) public {\n        require(msg.sender == admin, \"Only admin can withdraw\");\n        balance -= amount;\n    }\n}\n</code></pre> <p>In the above example, there is no check for the address assigning the <code>admin</code> role, and it can be changed by anyone, including malicious actors.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-017/#fixed-privileged-role-management","title":"Fixed Privileged Role Management","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract FixedRoleManagement {\n    address public owner;\n    uint public balance;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not authorized\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setOwner(address _owner) public onlyOwner {\n        owner = _owner;\n    }\n\n    function withdraw(uint amount) public onlyOwner {\n        balance -= amount;\n    }\n}\n</code></pre> In the fixed version, the <code>onlyOwner</code> modifier is used to ensure that only the owner can perform sensitive actions such as transferring ownership or withdrawing funds. This helps mitigate the risk of privilege mismanagement by enforcing access control at the contract level.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-018/","title":"SCWE-018: Use of tx.origin for Authorization","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-018/#relationships","title":"Relationships","text":"<ul> <li>CWE-346: Origin Validation Error https://cwe.mitre.org/data/definitions/346.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-018/#description","title":"Description","text":"<p>The use of <code>tx.origin</code> for authorization is a security vulnerability in which a smart contract checks the origin of the transaction to determine if a user is authorized to perform an action. This approach is flawed because <code>tx.origin</code> can be exploited by an attacker through a chain of transactions, allowing unauthorized users to interact with the contract. An attacker could trick the contract into performing an action on behalf of the victim by utilizing another contract in the transaction chain.</p> <p>Key Issues: - Allows unauthorized transactions by using the <code>tx.origin</code> variable instead of <code>msg.sender</code>. - Vulnerable to phishing and reentrancy attacks, where attackers can use contracts to impersonate the victim. - Mismanagement of roles and improper transaction flow handling.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-018/#remediation","title":"Remediation","text":"<ul> <li>Use <code>msg.sender</code> instead of <code>tx.origin</code>: Always rely on <code>msg.sender</code> for authentication and authorization, as it correctly represents the immediate sender of the current call.</li> <li>Strict validation checks: Ensure that authorization checks are done on the direct sender of the transaction, i.e., <code>msg.sender</code>, and not the originator.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-018/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-018/#vulnerable-contract-using-txorigin-for-authorization","title":"Vulnerable Contract (Using <code>tx.origin</code> for Authorization)","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract Vulnerable {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function restrictedAction() public {\n        require(tx.origin == owner, \"Only the owner can perform this action\");\n        // Action code here\n    }\n}\n</code></pre> In the vulnerable contract, the authorization check uses <code>tx.origin</code> to validate the caller. This is a problem because if the contract is called via another contract, <code>tx.origin</code> will return the original transaction sender (not the immediate caller), which opens up the contract to attacks such as phishing. The attacker can create a contract that interacts with the vulnerable contract on behalf of the victim.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-018/#fixed-contract-using-msgsender-for-authorization","title":"Fixed Contract (Using msg.sender for Authorization)","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract Secure {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function restrictedAction() public {\n        require(msg.sender == owner, \"Only the owner can perform this action\");\n        // Action code here\n    }\n}\n</code></pre> In the fixed contract, <code>msg.sender</code> is used instead of <code>tx.origin</code>. This ensures that the contract checks the immediate sender of the call, which prevents attacks where malicious contracts impersonate the victim.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-019/","title":"SCWE-019: Insecure Signature Verification","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-019/#relationships","title":"Relationships","text":"<ul> <li>CWE-347: Improper Verification of Cryptographic Signature   https://cwe.mitre.org/data/definitions/347.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-019/#description","title":"Description","text":"<p>Insecure signature verification occurs when a contract improperly verifies a cryptographic signature or fails to securely validate signatures, allowing attackers to forge or manipulate them. This vulnerability can allow unauthorized transactions or the bypassing of important security mechanisms, potentially leading to fraud, unauthorized access, or other attacks.</p> <p>Common causes of insecure signature verification include: - Not validating the signer's address. - Using weak or outdated cryptographic libraries. - Failing to check signature validity before processing actions. - Incorrectly handling the signature format.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-019/#remediation","title":"Remediation","text":"<ul> <li>Verify signatures properly: Always verify that the signature matches the intended signer by using the <code>ecrecover</code> function for Ethereum addresses and comparing the result to the expected signer address.</li> <li>Use strong cryptographic methods: Ensure the use of robust cryptographic techniques and libraries. Avoid using outdated or weak algorithms.</li> <li>Use secure signature formats: Make sure that signature formats are validated properly (e.g., ensure proper handling of <code>v</code>, <code>r</code>, <code>s</code> values in Ethereum signatures).</li> <li>Implement checks before acting on the signature: Always perform checks for valid signature and relevant parameters before executing any logic that could be influenced by the signature.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-019/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-019/#insecure-signature-verification","title":"Insecure Signature Verification","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureSignatureExample {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    // Insecure signature verification: does not properly validate the signature\n    function executeTransaction(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public {\n        address signer = ecrecover(hash, v, r, s);  // Signature verification\n        if (signer == owner) {\n            // Execute some sensitive action\n        }\n    }\n}\n</code></pre> In the insecure version, the contract checks if the signature corresponds to the owner but does not properly validate or handle potential issues with the signature, such as its format or correctness.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-019/#fixed-signature-verification","title":"Fixed Signature Verification","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract SecureSignatureExample {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    // Secure signature verification: properly checks signature and signer\n    function executeTransaction(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public {\n        address signer = ecrecover(hash, v, r, s);\n        require(signer == owner, \"Invalid signature\");  // Ensure valid signature before proceeding\n        // Execute some sensitive action\n    }\n}\n</code></pre> In the fixed version, we use the <code>require()</code> function to ensure the signature matches the owner's address, thereby improving security by preventing unauthorized access or actions.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-020/","title":"SCWE-020: Absence of Time-Locked Functions","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-020/#relationships","title":"Relationships","text":"<ul> <li>CWE-840: Business Logic Errors   https://cwe.mitre.org/data/definitions/840.html</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-020/#description","title":"Description","text":"<p>Absence of time-locked functions occurs when smart contracts do not implement mechanisms to delay certain critical functions or actions based on time conditions. This can result in the contract allowing actions that should be restricted or postponed for a certain period, such as emergency fund withdrawals or sensitive administrative actions. Without time-locking mechanisms, malicious actors or faulty logic could trigger these actions at the wrong time, leading to undesired outcomes.</p> <p>Time-locking is commonly used in scenarios like: - Delaying admin or owner functions to prevent immediate misuse. - Ensuring withdrawal or fund transfer happens only after a predefined delay. - Enabling emergency actions only after a certain time or under specific conditions.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-020/#remediation","title":"Remediation","text":"<ul> <li>Implement time-locked functions: Ensure that critical functions, especially those related to fund transfers or administrative actions, are protected by a time lock, delaying their execution until an appropriate time has passed.</li> <li>Use block timestamps: Leverage block timestamps or block numbers to control the execution of functions.</li> <li>Limit emergency access: If implementing emergency mechanisms, ensure that there are time delays before they can be invoked, to reduce the chance of misuse.</li> <li>Review time-based logic regularly: Verify the correctness of time-based logic to ensure that the system behaves as intended.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-020/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-020/#absence-of-time-locked-function","title":"Absence of Time-Locked Function","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract NoTimeLock {\n    address public owner;\n    uint public funds;\n\n    constructor() public {\n        owner = msg.sender;\n        funds = 1000;\n    }\n\n    // Critical function without time-lock\n    function withdrawFunds(uint amount) public {\n        require(msg.sender == owner, \"Not the owner\");\n        funds -= amount;\n    }\n}\n</code></pre> In this example, the contract lacks any time-lock mechanism, allowing the owner to withdraw funds at any time, which could be dangerous if mishandled. </p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-020/#time-locked-function-implementation","title":"Time-Locked Function Implementation","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract TimeLockExample {\n    address public owner;\n    uint public funds;\n    uint public lastWithdrawalTime;\n    uint public withdrawalDelay = 1 weeks;\n\n    constructor() public {\n        owner = msg.sender;\n        funds = 1000;\n        lastWithdrawalTime = now;\n    }\n\n    // Critical function with time-lock\n    function withdrawFunds(uint amount) public {\n        require(msg.sender == owner, \"Not the owner\");\n        require(now &gt;= lastWithdrawalTime + withdrawalDelay, \"Time lock not expired\");\n\n        lastWithdrawalTime = now;\n        funds -= amount;\n    }\n}\n</code></pre> In the fixed version, a time-lock mechanism is implemented, ensuring that the owner can only withdraw funds after a certain delay (e.g., one week). This provides an added layer of security, particularly in cases where emergency withdrawals or administrative actions are necessary but should not be immediate.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-038/","title":"SCWE-038: Insecure Use of Selfdestruct","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-038/#relationships","title":"Relationships","text":"<ul> <li>CWE-732: Incorrect Permission Assignment for Critical Resource CWE-732 Link</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-038/#description","title":"Description","text":"<p>Insecure use of selfdestruct refers to vulnerabilities that arise when the <code>selfdestruct</code> function is used without proper safeguards. This can lead to: - Unauthorized destruction of the contract. - Loss of funds or data. - Exploitation of vulnerabilities in contract logic.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-038/#remediation","title":"Remediation","text":"<ul> <li>Restrict access: Ensure only authorized addresses can call <code>selfdestruct</code>.</li> <li>Implement circuit breakers: Add mechanisms to halt operations in case of suspicious activity.</li> <li>Test thoroughly: Conduct extensive testing to ensure <code>selfdestruct</code> is used securely.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-038/#examples","title":"Examples","text":"<ul> <li> <p>Insecure Selfdestruct Usage <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureSelfdestruct {\n    function destroy() public {\n        selfdestruct(payable(msg.sender)); // No access control\n    }\n}\n</code></pre></p> </li> <li> <p>Secure Selfdestruct Usage <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureSelfdestruct {\n    address public admin;\n\n    constructor(address _admin) {\n        admin = _admin;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Unauthorized\");\n        _;\n    }\n\n    function destroy() public onlyAdmin {\n        selfdestruct(payable(admin)); // Restricted to admin\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-1"]},{"location":"SCWE/SCSVS-AUTH/SCWE-045/","title":"SCWE-045: Insecure Use of Modifiers","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-045/#relationships","title":"Relationships","text":"<ul> <li>CWE-732: Incorrect Permission Assignment for Critical Resource CWE-732 Link</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-045/#description","title":"Description","text":"<p>Insecure use of modifiers refers to vulnerabilities that arise when modifiers are used improperly. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of vulnerabilities in contract logic.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-045/#remediation","title":"Remediation","text":"<ul> <li>Restrict access: Ensure only authorized addresses can use the modifier.</li> <li>Validate inputs: Ensure all inputs to the modifier are properly validated.</li> <li>Test thoroughly: Conduct extensive testing to ensure modifiers are secure.</li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-045/#examples","title":"Examples","text":"<ul> <li>Insecure Modifier Usage (With Storage Bug) <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureModifier {\n    address public admin;\n\n    constructor(address _admin) {\n        admin = _admin; // \u274c Storage bug: Allows setting admin to zero address.\n    }\n\n    modifier onlyAdmin() {\n        require(admin == address(0), \"Unauthorized\"); // \u274c Wrong condition, only works if admin is zero!\n        _;\n    }\n\n    function updateAdmin(address newAdmin) public onlyAdmin {\n        admin = newAdmin; // \u274c Can set admin to zero address, breaking access control.\n    }\n\n    function updateBalance(uint newBalance) public onlyAdmin {\n        // Update balance\n    }\n}\n</code></pre></li> </ul> <p>Why is this Insecure? - Wrong Condition in <code>onlyAdmin()</code>     - <code>require(admin == address(0), \"Unauthorized\");</code> only allows function execution when admin is zero.     - This means no valid admin can ever execute admin functions!     - If admin is ever non-zero, all <code>onlyAdmin</code> functions become unusable.</p> <ul> <li> <p>Loss of Control</p> <ul> <li>If admin is accidentally set to <code>address(0)</code>, anyone can now execute admin functions, breaking security</li> </ul> </li> <li> <p>Secure Modifier Usage <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureModifier {\n    address public admin;\n\n    constructor(address _admin) {\n        require(_admin != address(0), \"Invalid admin address\"); // \u2705 Proper validation\n        admin = _admin;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Unauthorized\"); // \u2705 Correctly restricts access\n        _;\n    }\n\n    function updateAdmin(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0), \"New admin cannot be zero address\"); // \u2705 Prevents admin loss\n        admin = newAdmin;\n    }\n\n    function updateBalance(uint newBalance) public onlyAdmin {\n        // Update balance securely\n    }\n}\n</code></pre></p> </li> </ul> <p>Why is this Secure? - Proper access control in <code>onlyAdmin()</code>     - <code>require(msg.sender == admin, \"Unauthorized\");</code> ensures only the correct admin can execute admin functions.         - Prevents privilege escalation - <code>updateAdmin()</code> prevents setting <code>admin = address(0)</code>, avoiding unintended loss of access.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-049/","title":"SCWE-049: Unprotected Ether Withdrawal","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-049/#relationships","title":"Relationships","text":"<ul> <li>CWE-732: Incorrect Permission Assignment for Critical Resource https://cwe.mitre.org/data/definitions/732.html </li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-049/#description","title":"Description","text":"<p>Unprotected Ether withdrawal occurs when a smart contract allows withdrawal of Ether (ETH) without sufficient access control or proper authorization mechanisms. This vulnerability exposes the contract to unauthorized or malicious users, enabling them to drain funds without any checks on the withdrawal request.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-049/#remediation","title":"Remediation","text":"<p>To prevent this vulnerability, implement strong access control mechanisms like the <code>onlyOwner</code> modifier or a more flexible role-based access control (RBAC) system. Ensure that only authorized users (e.g., the contract owner or specific users) can initiate Ether withdrawals. Always verify user permissions before allowing access to critical contract functions.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-049/#impact","title":"Impact","text":"<p>An attacker can exploit this vulnerability to withdraw Ether from the contract, leading to potential financial loss. This could result in a total loss of funds if no protective measures are in place, exposing the contract and its users to significant risks.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-049/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract EtherWallet {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function withdraw(uint amount) public {\n        payable(msg.sender).transfer(amount);  // No access control\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-049/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract EtherWallet {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function withdraw(uint amount) public onlyOwner {\n        payable(msg.sender).transfer(amount);  // Access control added\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-050/","title":"SCWE-050: Unprotected SELFDESTRUCT Instruction","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-050/#relationships","title":"Relationships","text":"<ul> <li>CWE-732: Incorrect Permission Assignment for Critical Resource https://cwe.mitre.org/data/definitions/732.html </li> </ul>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-050/#description","title":"Description","text":"<p>The <code>SELFDESTRUCT</code> instruction in Ethereum allows a contract to destroy itself and send its remaining Ether balance to a specified address. If this instruction is not properly protected with access controls, an attacker could trigger it, causing the contract to self-destruct and possibly transferring all the funds to an unauthorized address. This can result in the total loss of funds or disruption of contract functionality.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-050/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, it is crucial to protect the <code>SELFDESTRUCT</code> instruction with proper access control mechanisms. Only authorized users, such as the contract owner or admin, should be allowed to call the <code>SELFDESTRUCT</code> function. Consider using modifiers like <code>onlyOwner</code> or a role-based access control system to enforce permission checks before allowing this critical operation.</p>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-050/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Destructible {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Unprotected SELFDESTRUCT allowing anyone to call it\n    function destruct() public {\n        selfdestruct(payable(msg.sender));  // No access control\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-AUTH/SCWE-050/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Destructible {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Only the owner can call SELFDESTRUCT\n    function destruct() public onlyOwner {\n        selfdestruct(payable(msg.sender));  // Access control added\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-AUTH","SCSVS-AUTH-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-024/","title":"SCWE-024: Weak Randomness Sources","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-024/#relationships","title":"Relationships","text":"<ul> <li>CWE-336: Predictable Random Number Generator CWE-336 Link</li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-024/#description","title":"Description","text":"<p>Weak randomness sources refer to the use of predictable or insecure sources of randomness, such as block timestamps or block hashes. This can lead to: - Exploitation of the contract's logic. - Loss of funds or data. - Reduced trust in the contract's security.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-024/#remediation","title":"Remediation","text":"<ul> <li>Use secure randomness: Leverage secure randomness sources like Chainlink VRF.</li> <li>Avoid block variables: Do not rely on block timestamps or hashes for randomness.</li> <li>Test thoroughly: Conduct extensive testing to ensure randomness is secure.</li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-024/#examples","title":"Examples","text":"<ul> <li> <p>Weak Randomness <pre><code>pragma solidity ^0.8.0;\n\ncontract WeakRandomness {\n    function generateRandomNumber() public view returns (uint) {\n        return uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty))); // Insecure randomness\n    }\n}\n</code></pre></p> </li> <li> <p>Secure Randomness <pre><code>pragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\n\ncontract SecureRandomness is VRFConsumerBase {\n    bytes32 internal keyHash;\n    uint256 internal fee;\n    uint256 public randomResult;\n\n    constructor(address vrfCoordinator, address linkToken, bytes32 _keyHash, uint256 _fee)\n        VRFConsumerBase(vrfCoordinator, linkToken) {\n        keyHash = _keyHash;\n        fee = _fee;\n    }\n\n    function getRandomNumber() public returns (bytes32 requestId) {\n        require(LINK.balanceOf(address(this)) &gt;= fee, \"Not enough LINK\");\n        return requestRandomness(keyHash, fee);\n    }\n\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n        randomResult = randomness;\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/","title":"SCWE-031: Insecure use of Block Variables","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#relationships","title":"Relationships","text":"<ul> <li>CWE-682: Incorrect Calculation https://cwe.mitre.org/data/definitions/682.html</li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#description","title":"Description","text":"<p>In blockchain networks like Ethereum, block variables <code>(block.timestamp, block.number, block.difficulty, etc.)</code> provide information about the current state of the blockchain. However, these values are not fully deterministic and can be manipulated by miners, leading to vulnerabilities in smart contracts.</p> <p>Block timestamps are not guaranteed to be accurate or consistent, and miners can influence them within a certain range. This can cause issues when contracts depend on precise timing for critical functionality, such as token distribution, access control, or other time-sensitive events.</p> <p>Potential issues that arise from insecure timestamp usage include:</p> <ul> <li>Timestamp Manipulation: Miners can slightly alter <code>block.timestamp</code> to influence time-sensitive logic (e.g., auctions, token distributions, staking rewards).</li> <li>Predictable Randomness: Using <code>block.number</code> or <code>block.difficulty</code> as a source of randomness allows attackers to predict and manipulate outcomes.</li> <li>Exploitable Access Control: Contracts that rely on block timestamps for permissions or actions may be bypassed if timestamps are adjusted.</li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#remediation","title":"Remediation","text":"<ul> <li>Avoid timestamp-based conditions: Where possible, use block numbers instead of timestamps. Block numbers are more reliable and less subject to manipulation.</li> <li>Use Oracles: For time-sensitive contracts, consider using trusted oracles to provide external time data.</li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#insecure-block-timestamp-usage-timestamp-based-deadlines","title":"Insecure Block Timestamp Usage- Timestamp-Based Deadlines","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract TimestampExample {\n    uint public deadline;\n\n    function setDeadline(uint _deadline) public {\n        deadline = _deadline;\n    }\n\n    function checkDeadline() public view returns (string) {\n        if (now &gt; deadline) {\n            return \"Deadline passed\";\n        } else {\n            return \"Deadline not passed\";\n        }\n    }\n}\n</code></pre> <p>In the above example, the <code>now</code> keyword retrieves the block's timestamp to compare with the deadline. This creates a potential vulnerability as miners can manipulate the block timestamp within a predefined window.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#fixed-block-timestamp-usage","title":"Fixed Block Timestamp Usage","text":"<p><pre><code>pragma solidity ^0.4.0;\n\ncontract SafeTimestampExample {\n    uint public deadline;\n    uint public blockNumber;\n\n    function setDeadline(uint _deadline) public {\n        deadline = _deadline;\n        blockNumber = block.number;\n    }\n\n    function checkDeadline() public view returns (string) {\n        if (block.number &gt; blockNumber + 1000) { // Assuming a reasonable number of blocks for a deadline\n            return \"Deadline passed\";\n        } else {\n            return \"Deadline not passed\";\n        }\n    }\n}\n</code></pre> In this fixed version, the contract uses <code>block.number</code> instead of <code>now</code>. This makes the contract less susceptible to timestamp manipulation, as block numbers are more reliable and consistent.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#insecure-lottery-using-blocktimestamp","title":"Insecure Lottery Using block.timestamp","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureLottery {\n    address[] public players;\n\n    function enter() public payable {\n        require(msg.value &gt; 0.01 ether, \"Minimum ETH required\");\n\n        players.push(msg.sender);\n    }\n\n    function pickWinner() public {\n        uint index = uint(block.timestamp) % players.length; // Insecure: Predictable outcome\n        payable(players[index]).transfer(address(this).balance);\n    }\n}\n</code></pre> Issue: - Predictability: Since <code>block.timestamp</code> is manipulable within a small range, miners can influence the winner selection. - Attack Vector: A miner could reorder transactions to ensure a specific outcome</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-031/#secure-alternative","title":"Secure Alternative","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract SecureLottery {\n    address[] public players;\n\n    function enter() public payable {\n        require(msg.value &gt; 0.01 ether, \"Minimum ETH required\");\n        players.push(msg.sender);\n    }\n\n    function pickWinner() public {\n        require(players.length &gt; 0, \"No players joined\");\n        uint index = uint(keccak256(abi.encodePacked(block.prevrandao, msg.sender, players.length))) % players.length;\n        payable(players[index]).transfer(address(this).balance);\n    }\n}\n</code></pre> Fixes: - Uses block.prevrandao (EIP-4399) as an unpredictable source of randomness. - Adds entropy from msg.sender and players.length to prevent miner manipulation</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-065/","title":"SCWE-065: Block Values as a Proxy for Time","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-065/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation https://cwe.mitre.org/data/definitions/20.html </li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-065/#description","title":"Description","text":"<p>Using block values (such as <code>block.timestamp</code>, <code>block.number</code>, or <code>block.difficulty</code>) as a proxy for time in Ethereum smart contracts can be problematic. Block values are determined by miners and can be manipulated within certain limits, making them unreliable for time-sensitive logic. Relying on these values for critical decisions like deadlines or expiration dates can result in unexpected behaviors, such as manipulations by miners or unintended contract states.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-065/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, avoid using block values as a direct proxy for time-based logic. Instead, consider using external oracles that provide reliable and tamper-proof time data or incorporate additional checks to prevent miner manipulation. Where necessary, combine block values with other data points to reduce the risk of exploitation.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-065/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract TimeSensitive {\n    uint public deadline;\n\n    constructor(uint _deadline) {\n        deadline = _deadline;\n    }\n\n    function hasExpired() public view returns (bool) {\n        return block.timestamp &gt; deadline;  // Relies on block.timestamp\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-065/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract TimeSensitive {\n    uint public deadline;\n    address public oracle;\n\n    constructor(uint _deadline, address _oracle) {\n        deadline = _deadline;\n        oracle = _oracle;\n    }\n\n    function hasExpired() public view returns (bool) {\n        // Use a trusted oracle for time verification\n        uint currentTime = Oracle(oracle).getCurrentTime();\n        return currentTime &gt; deadline;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-2"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-073/","title":"SCWE-073: Message Call with Hardcoded Gas Amount","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-073/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html </li> </ul>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-073/#description","title":"Description","text":"<p>In Solidity, calling external contracts with a hardcoded gas value can lead to various issues, such as running out of gas or allowing a malicious contract to manipulate gas consumption. Hardcoding the gas amount is inflexible and may lead to resource exhaustion or cause the transaction to fail when the gas limit is insufficient for the operation.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-073/#remediation","title":"Remediation","text":"<p>Instead of hardcoding gas values, it is better to allow the gas to be automatically determined or adjust the gas dynamically depending on the needs of the transaction. This ensures that the transaction can complete successfully while avoiding unnecessary resource consumption.</p>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-073/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    address public target;\n\n    function callTarget() public {\n        // Hardcoding the gas value for the message call\n        target.call{gas: 100000}(\"\");  // Vulnerable to resource consumption issues\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BLOCK/SCWE-073/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Example {\n    address public target;\n\n    function callTarget() public {\n        // Let Solidity handle gas consumption dynamically\n        target.call(\"\");  // Gas amount handled by the EVM dynamically\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-BLOCK","SCSVS-BLOCK-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-032/","title":"SCWE-032: Dependency on Block Gas Limit","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-032/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption CWE-400 Link</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-032/#description","title":"Description","text":"<p>Dependency on block gas limit refers to the reliance on the Ethereum block gas limit for contract operations, which can lead to: - Failed transactions if gas limits are exceeded. - Exploitation of vulnerabilities in gas-intensive operations. - Loss of funds or data.</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-032/#remediation","title":"Remediation","text":"<ul> <li>Optimize gas usage: Minimize gas consumption in contract operations.</li> <li>Avoid unbounded loops: Ensure loops have a fixed upper limit.</li> <li>Test thoroughly: Conduct extensive testing to ensure operations stay within gas limits.</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-032/#examples","title":"Examples","text":"<ul> <li>Gas-Intensive Operation- Storing Large Dynamic Data <pre><code>pragma solidity ^0.8.0;\n\ncontract GasIntensive {\n    uint[] public largeArray;\n\n    function appendData(uint[] memory data) public {\n        for (uint i = 0; i &lt; data.length; i++) {\n            largeArray.push(data[i]); // Storing a large dataset in a single transaction\n        }\n    }\n}\n</code></pre></li> <li>This contract appends large arrays in a single transaction, which fails when the block gas limit is exceeded.</li> <li> <p>Attackers could exploit this by forcing high gas consumption and causing DoS attacks (e.g., filling storage inefficiently).</p> </li> <li> <p>Optimized Gas Usage- Chunk Processing &amp; Gas Efficiency <pre><code>pragma solidity ^0.8.0;\n\ncontract GasOptimized {\n    uint[] public largeArray;\n\n    function appendData(uint[] memory data, uint start, uint end) public {\n        require(end &lt;= data.length, \"Invalid range\");\n        for (uint i = start; i &lt; end; i++) {\n            largeArray.push(data[i]); // Process in controlled batches\n        }\n    }\n}\n</code></pre></p> </li> </ul> <p>Why is this better? - The start and end parameters allow batch processing instead of handling everything in a single call. - Prevents hitting the block gas limit by splitting work across multiple transactions.</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-033/","title":"SCWE-033: Chain Split Risks","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-033/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-033/#description","title":"Description","text":"<p>Chain split risks refer to vulnerabilities that arise when a blockchain splits into multiple chains, such as during a hard fork. This can lead to: - Confusion or inconsistencies in contract logic. - Loss of funds or data. - Exploitation of vulnerabilities in cross-chain operations.</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-033/#remediation","title":"Remediation","text":"<ul> <li>Handle chain splits: Implement logic to handle potential chain splits.</li> <li>Use chain identifiers: Include chain identifiers in cross-chain communications.</li> <li>Test thoroughly: Conduct extensive testing to ensure contract logic is robust.</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-033/#examples","title":"Examples","text":"<ul> <li> <p>Vulnerable to Chain Splits <pre><code>pragma solidity ^0.8.0;\n\ncontract ChainSplitVulnerable {\n    function processTransaction(bytes memory data) public {\n        // Process transaction without chain split handling\n    }\n}\n</code></pre></p> </li> <li> <p>Protected Against Chain Splits <pre><code>pragma solidity ^0.8.0;\n\ncontract ChainSplitProtected {\n    uint public chainId;\n\n    constructor(uint _chainId) {\n        chainId = _chainId;\n    }\n\n    function processTransaction(bytes memory data, uint transactionChainId) public {\n        require(transactionChainId == chainId, \"Invalid chain ID\");\n        // Process transaction\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-1"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-034/","title":"SCWE-034: Insecure Cross-Chain Messaging","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-034/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-034/#description","title":"Description","text":"<p>Insecure cross-chain messaging refers to vulnerabilities that arise when communicating between different blockchains. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of vulnerabilities in cross-chain logic.</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-034/#remediation","title":"Remediation","text":"<ul> <li>Validate messages: Ensure all cross-chain messages are properly validated.</li> <li>Use secure protocols: Leverage secure cross-chain communication protocols.</li> <li>Test thoroughly: Conduct extensive testing to ensure cross-chain logic is secure.</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-034/#examples","title":"Examples","text":"<ul> <li>Insecure Cross-Chain Messaging <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureCrossChain {\n    event MessageProcessed(bytes message);\n\n    function processMessage(bytes memory message) public {\n        // \u274c No validation of the sender (anyone can call this function!)\n        // \u274c No signature verification (attackers can inject fake messages!)\n        // \ud83d\udea8 No relayer authorization\n        // \ud83d\udea8 No replay protection\n        emit MessageProcessed(message);\n    }\n}\n</code></pre> \ud83d\udd34 Issue: The function accepts messages without validation, allowing unauthorized transactions.</li> </ul> <p>Unauthorized Relayers (Anyone Can Call!) - Issue: The function allows any msg.sender to call processMessage(), meaning an attacker can send arbitrary messages. - Impact: Attackers can forge transactions, trigger unintended actions, or drain funds if the function is connected to cross-chain asset transfers.</p> <p>No Signature Verification (Fake Messages) - Issue: The contract doesn\u2019t verify the authenticity of the message. - Impact: Attackers can inject fake messages and trick the contract into executing unauthorized actions.</p> <p>Replay Attacks - Issue: The contract doesn\u2019t track processed messages. - Impact: The same message can be replayed multiple times, leading to repeated execution of sensitive operations.</p> <ul> <li>Secure Cross-Chain Messaging <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureCrossChain {\n    mapping(address =&gt; bool) public trustedRelayers;\n    mapping(bytes32 =&gt; bool) public processedMessages;\n\n    event MessageProcessed(bytes32 indexed messageHash, address indexed sender);\n    event RelayerUpdated(address relayer, bool status);\n\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    constructor(address[] memory initialRelayers) {\n        owner = msg.sender;\n        for (uint i = 0; i &lt; initialRelayers.length; i++) {\n            trustedRelayers[initialRelayers[i]] = true;\n        }\n    }\n\n    function setRelayer(address relayer, bool status) external onlyOwner {\n        trustedRelayers[relayer] = status;\n        emit RelayerUpdated(relayer, status);\n    }\n\n    function processMessage(\n        bytes memory message, \n        uint8 v, bytes32 r, bytes32 s\n    ) public {\n        require(trustedRelayers[msg.sender], \"Unauthorized relayer\");\n\n        bytes32 messageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(message)));\n        address signer = ecrecover(messageHash, v, r, s);\n        require(signer != address(0), \"Invalid signature\");\n\n        require(!processedMessages[messageHash], \"Message already processed\");\n        processedMessages[messageHash] = true;\n\n        emit MessageProcessed(messageHash, signer);\n\n        // \u2705 Securely process the message\n    }\n}\n</code></pre></li> </ul> <p>Fix: Implements signature verification, relayer validation, and replay protection. Why is this better? \u2705 Verifies Signatures Properly: Uses ecrecover() with Ethereum Signed Message hashing. \u2705 Admin Can Manage Relayers: Allows dynamic relayer updates via setRelayer(). \u2705 Prevents Replay Attacks: Tracks processed messages in processedMessages mapping. \u2705 Ensures Message Authenticity: Only validly signed messages are accepted.</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-087/","title":"SCWE-087: Missing Payload Size Validation in Cross-Chain Messaging (Denial of Service/Stuck Funds)","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-087/#relationships","title":"Relationships","text":"<ul> <li>CWE-1284: Improper Validation of Specified Quantity in Input CWE-1284 Link</li> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-087/#description","title":"Description","text":"<p>This weakness arises when smart contracts performing cross-chain messaging fail to validate the size of payloads before emitting or sending them. In protocols using relayer-based messaging (e.g., LayerZero, Wormhole), data is typically encoded and emitted as a payload on the source chain, then relayed and decoded on the destination chain. If the encoded payload exceeds the maximum allowed size (often 10,000 bytes or similar, depending on the bridge/messaging protocol), the message transmission or decoding can revert\u2014often because the large payload causes out-of-gas consumption during processing or fails explicit size checks. In lock-mint architectures, this can lead to permanent loss of user funds due to inability to unlock or mint assets on the destination chain.</p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-087/#impact","title":"Impact","text":"<ul> <li>Denial of Service: Oversized payloads will revert during cross-chain transmission, preventing legitimate state updates or token minting/unlocking on the destination chain.</li> <li>Stuck or Lost Funds: In bridges using lock-and-mint or burn-and-mint designs, users\u2019 assets may be locked on the source chain with no way to release or claim them on the destination due to repeated transaction failure.</li> <li>Operational Risk: Malicious or unintentional submission of oversized payloads can be used to disrupt bridge operations, preventing protocol liveness or causing critical business logic to be inaccessible.</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-087/#remediation","title":"Remediation","text":"<ul> <li>Enforce maximum payload size validation on both source and destination chains.</li> <li>Perform defensive coding around payload encoding and decoding to catch out-of-gas or out-of-bound errors.</li> <li>Consider fallback or reversion handling strategies to safely refund or unlock funds when such failures occur.</li> </ul>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-BRIDGE/SCWE-087/#examples","title":"Examples","text":"<p>\ud83e\uddea  Example: User-Supplied Merkle Proof in <code>lockTokens()</code></p> <p>\u274c Vulnerable Code (No Payload Size Validation) <pre><code>// SourceChain.sol\nevent Locked(address indexed user, uint256 amount, bytes payload);\nfunction lockTokens(uint256 amount, bytes calldata merkleProof) external {\n    require(amount &gt; 0, \"Invalid amount\");\n    // Lock tokens (ERC20 transferFrom)\n    require(token.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n    // Encode user, amount, timestamp, and the supplied Merkle proof\n    bytes memory payload = abi.encode(msg.sender, amount, block.timestamp, merkleProof);\n    // \u26a0\ufe0f No payload size validation!\n    emit Locked(msg.sender, amount, payload);\n}\n</code></pre> Destination Chain: Decode and Mint <pre><code>// DestinationChain.sol\nfunction mintFromPayload(bytes calldata payload) external {\n    // Will revert if payload is too large for decode!\n    (address user, uint256 amount, uint256 timestamp, bytes memory merkleProof) =\n        abi.decode(payload, (address, uint256, uint256, bytes));\n    // Verification of Merkle proof, then mint tokens\n    _mint(user, amount);\n}\n</code></pre> \u2705  Safe Code (With Payload Size Validation) <pre><code>// SourceChain.sol\nevent Locked(address indexed user, uint256 amount, bytes payload);\nfunction lockTokens(uint256 amount, bytes calldata merkleProof) external {\n    require(amount &gt; 0, \"Invalid amount\");\n    // Lock tokens (ERC20 transferFrom)\n    require(token.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n    // Encode user, amount, timestamp, and the supplied Merkle proof\n    bytes memory payload = abi.encode(msg.sender, amount, block.timestamp, merkleProof);\n    // Check payload size\n    require(payload.length &lt;= 10_000, \"Payload exceeds max allowed size\");\n    emit Locked(msg.sender, amount, payload);\n}\n</code></pre> Destination Chain: Decode and Mint (Optional Double Check) <pre><code>// DestinationChain.sol\nfunction mintFromPayload(bytes calldata payload) external {\n    require(payload.length &lt;= 10_000, \"Payload too large\");\n    (address user, uint256 amount, uint256 timestamp, bytes memory merkleProof) =\n        abi.decode(payload, (address, uint256, uint256, bytes));\n    // Proceed with Merkle proof verification and minting\n    _mint(user, amount);\n}\n</code></pre></p>","tags":["scwe","L1","SCSVS-BRIDGE","SCSVS-BRIDGE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-007/","title":"SCWE-007: Presence of Unused Variables","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-007/#relationships","title":"Relationships","text":"<ul> <li>CWE-563: Assignment to Variable with No Effect   https://cwe.mitre.org/data/definitions/563.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-007/#description","title":"Description","text":"<p>The presence of unused variables in smart contracts refers to variables that are declared but never utilized in the contract logic. These variables consume storage or memory space unnecessarily, potentially wasting gas when deployed or executed. This situation often arises due to incomplete code, forgotten variables, or code that was intended for future use but never implemented. The presence of such variables increases the attack surface by making it harder to understand the contract and opens up potential vulnerabilities.</p> <p>Some common risks include: - Wasted gas due to storage and memory consumption. - Increased complexity and difficulty in understanding contract behavior. - Potential confusion for auditors or future developers working on the contract.</p> <p>Unused variables can also hide logic errors or indicate that parts of the contract are not functioning as intended.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-007/#remediation","title":"Remediation","text":"<ul> <li>Remove Unused Variables: Ensure that any variables that are not required for the contract\u2019s functionality are removed.</li> <li>Code Review and Refactoring: Regularly review and refactor the code to eliminate dead or unnecessary variables.</li> <li>Automated Static Analysis Tools: Use static analysis tools to detect unused variables and other unnecessary code patterns.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-007/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-007/#contract-with-unused-variables","title":"Contract with Unused Variables","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract UnusedVariables {\n    uint public balance;\n    uint public unusedVariable; // This variable is not used anywhere\n\n    function deposit(uint amount) public {\n        balance += amount;\n    }\n\n    function withdraw(uint amount) public {\n        balance -= amount;\n    }\n}\n</code></pre> <p>In the example above, the <code>unusedVariable</code> is declared but never used within the contract. This is a waste of storage space and can confuse anyone reading or auditing the code.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-007/#fixed-code-with-unused-variables-removed","title":"Fixed Code with Unused Variables Removed","text":"<p><pre><code>pragma solidity ^0.4.0;\n\ncontract FixedUnusedVariables {\n    uint public balance;\n\n    function deposit(uint amount) public {\n        balance += amount;\n    }\n\n    function withdraw(uint amount) public {\n        balance -= amount;\n    }\n}\n</code></pre> The improved contract removes the unnecessary <code>unusedVariable</code>, reducing the complexity and improving gas efficiency.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-008/","title":"SCWE-008: Hardcoded Constants","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-008/#relationships","title":"Relationships","text":"<ul> <li>CWE-547: Use of Hard-coded, Security-relevant Constants   https://cwe.mitre.org/data/definitions/547.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-008/#description","title":"Description","text":"<p>Hardcoded constants refer to values that are embedded directly into the code and cannot be easily changed without modifying the code itself. These constants may include critical parameters, addresses, or settings that could be subject to change based on external factors or evolving needs. Hardcoding these values in the code introduces several issues:</p> <ul> <li>Lack of flexibility: Once the contract is deployed, these hardcoded values cannot be changed without deploying a new version, leading to inefficiency and reduced adaptability.</li> <li>Security risks: Hardcoded values may expose sensitive information or create vulnerabilities if they are not properly protected.</li> <li>Upgrade challenges: Contracts with hardcoded constants cannot easily evolve to support new functionality or parameters without requiring costly redeployment.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-008/#remediation","title":"Remediation","text":"<ul> <li>Use variables instead of constants: Instead of hardcoding values, define them as variables that can be updated through administrative actions.</li> <li>Implement upgradeable contract patterns: Use proxy contracts or other patterns that support upgrades to allow flexibility in modifying constants.</li> <li>External configuration: Use off-chain storage for configuration values that can be updated without needing to deploy new contract versions.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-008/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-008/#contract-with-hardcoded-constants","title":"Contract with Hardcoded Constants","text":"<p><pre><code>pragma solidity ^0.4.0;\n\ncontract HardcodedConstants {\n    address public owner = 0x1234567890abcdef1234567890abcdef12345678; // Hardcoded address\n    uint public maxSupply = 1000000; // Hardcoded supply limit\n\n    function setOwner(address newOwner) public {\n        owner = newOwner;\n    }\n\n    function setMaxSupply(uint newMaxSupply) public {\n        maxSupply = newMaxSupply;\n    }\n}\n</code></pre> In this example, the <code>owner</code> address and <code>maxSupply</code> are hardcoded values that cannot be changed without redeploying the contract. This reduces flexibility and creates potential security risks.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-008/#improved-contract-with-external-configuration","title":"Improved Contract with External Configuration","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract ConfigurableContract {\n    address public owner;\n    uint public maxSupply;\n\n    constructor(address initialOwner, uint initialMaxSupply) public {\n        owner = initialOwner;\n        maxSupply = initialMaxSupply;\n    }\n\n    function setOwner(address newOwner) public {\n        owner = newOwner;\n    }\n\n    function setMaxSupply(uint newMaxSupply) public {\n        maxSupply = newMaxSupply;\n    }\n}\n</code></pre> <p>In this improved example, the <code>owner</code> address and <code>maxSupply</code> are configurable through the constructor, allowing for more flexibility without the need for redeployment.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-009/","title":"SCWE-009: Deprecated Variable and Function Usage","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-009/#relationships","title":"Relationships","text":"<ul> <li>CWE-477: Use of Obsolete Function   https://cwe.mitre.org/data/definitions/477.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-009/#description","title":"Description","text":"<p>The use of deprecated variables and functions refers to employing code elements that are no longer recommended for use, either due to obsolescence, security concerns, or the introduction of better alternatives. Using such elements can cause issues, including reduced compatibility, poor maintainability, and security vulnerabilities. Specific concerns related to deprecated usage are:</p> <ul> <li>Security risks: Deprecated functions may have known vulnerabilities or might not be patched.</li> <li>Compatibility issues: Newer compiler versions and environments may not support deprecated code.</li> <li>Maintenance difficulties: Continuing to use deprecated code increases the complexity of codebase management and prevents clean upgrades.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-009/#remediation","title":"Remediation","text":"<ul> <li>Replace deprecated functions: Always use the recommended and supported alternatives in the latest compiler versions.</li> <li>Update dependencies: If relying on libraries that use deprecated elements, upgrade to versions that support current standards.</li> <li>Monitor for deprecation warnings: Stay informed about deprecated functions in the Solidity language or external libraries and refactor the code when necessary.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-009/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-009/#contract-with-deprecated-function-usage","title":"Contract with Deprecated Function Usage","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract DeprecatedUsage {\n    address public owner;\n    uint public balance;\n\n    // Deprecated function, example using older Solidity versions\n    function sendTransaction(address recipient, uint amount) public {\n        recipient.transfer(amount);\n    }\n}\n</code></pre> <p>In this example, the <code>transfer</code> function in Solidity's older versions is deprecated. Continuing to use such functions can cause issues with future compiler versions.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-009/#improved-contract-without-deprecated-usage","title":"Improved Contract without Deprecated Usage","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract UpdatedUsage {\n    address public owner;\n    uint public balance;\n\n    // Replaced with safer, modern methods\n    function sendTransaction(address recipient, uint amount) public {\n        payable(recipient).transfer(amount);\n    }\n}\n</code></pre> In this improved example, the contract uses the latest version of Solidity (0.8.0), which has better support and security features. The <code>transfer</code> method is also updated to be more compatible with the latest Solidity practices.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/","title":"SCWE-010: Shadowing Variables and Functions","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/#relationships","title":"Relationships","text":"<ul> <li>CWE-1109: Use of Same Variable for Multiple Purposes CWE-1109   Description: This weakness occurs when a variable is used for multiple purposes in a way that causes confusion, bugs, or unintentional side effects. In the context of smart contracts, shadowing variables leads to such misuse, as it causes ambiguity between different scopes.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/#description","title":"Description","text":"<p>Shadowing variables or functions is a scenario where a local variable or function shares the same name as one in a larger or outer scope. This can cause ambiguity and lead to unexpected behavior or bugs, as the inner variable or function hides the outer one. This problem is especially tricky in Solidity due to its inheritance model, where a child contract might unintentionally override parent contract variables or functions.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/#key-issues","title":"Key issues:","text":"<ul> <li>Ambiguity: The developer might not be aware that a variable or function is being hidden.</li> <li>Unintentional logic errors: It may lead to the wrong variable being accessed, or the wrong function being called.</li> <li>Difficulty in debugging: Shadowing makes the code harder to understand and trace, especially in complex contracts or when inheritance is involved.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/#remediation","title":"Remediation","text":"<ul> <li>Use unique and descriptive names: Always use unique names for variables and functions to avoid shadowing. Use clear, descriptive names for contract variables and functions.</li> <li>Avoid redeclaring variables in nested scopes: Ensure that variables or functions in inner scopes don\u2019t conflict with those in outer scopes.</li> <li>Static analysis tools: Use static analysis tools to detect and warn about shadowing issues.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/#example-of-shadowing-variables-and-functions","title":"Example of Shadowing Variables and Functions","text":"<p><pre><code>pragma solidity ^0.4.0;\n\ncontract ShadowingExample {\n    uint public balance;\n\n    // This function shadows the 'balance' variable\n    function deposit(uint balance) public {\n        // Local variable 'balance' now shadows the contract's balance variable\n        balance += balance;  // This operation affects the local 'balance', not the contract's state variable\n    }\n}\n\ncontract Test {\n    ShadowingExample example;\n\n    constructor() public {\n        example = new ShadowingExample();\n    }\n\n    function testDeposit() public {\n        example.deposit(100);  // Calling the deposit function on the example contract\n    }\n}\n</code></pre> In the above example, the parameter <code>balance</code> in the <code>deposit</code> function shadows the contract\u2019s state variable <code>balance</code>. This causes confusion, and the operation <code>balance += balance</code>; modifies the local variable instead of the contract state variable, leading to unexpected behavior.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-010/#fixed-code","title":"Fixed Code","text":"<p><pre><code>pragma solidity ^0.4.0;\n\ncontract ShadowingExample {\n    uint public balance;\n\n    // The parameter is renamed to avoid shadowing the state variable 'balance'\n    function deposit(uint amount) public {\n        balance += amount;  // Correctly updates the contract's state variable\n    }\n}\n\ncontract Test {\n    ShadowingExample example;\n\n    constructor() public {\n        example = new ShadowingExample();\n    }\n\n    function testDeposit() public {\n        example.deposit(100);  // Calling the deposit function on the example contract\n    }\n}\n</code></pre> In the optimized version, the function parameter is renamed from <code>balance</code> to <code>amount</code> to avoid shadowing the state variable. This clears up the ambiguity and ensures the function operates on the contract's state variable, not the local variable.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-011/","title":"SCWE-011: Insecure ABI Encoding and Decoding","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-011/#relationships","title":"Relationships","text":"<ul> <li>CWE-116: Improper Encoding or Escaping of Output    https://cwe.mitre.org/data/definitions/116.html</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-011/#description","title":"Description","text":"<p>Insecure ABI encoding and decoding occur when a smart contract improperly handles data serialization and deserialization, leading to vulnerabilities such as data corruption, type confusion, or reentrancy attacks. Solidity provides ABI encoding functions like <code>abi.encode()</code>, <code>abi.encodePacked()</code>, and <code>abi.decode()</code>, but improper usage can cause unexpected behavior.</p> <p>Common issues with insecure ABI handling: - Collision Risks in <code>abi.encodePacked()</code>: Multiple concatenated parameters can lead to ambiguous encoding, making it vulnerable to hash collisions. - Unchecked Decoding: Improper use of <code>abi.decode()</code> can result in unintended memory corruption or type confusion. - Lack of Input Validation: Encoding user inputs without verification can introduce security flaws. - Mismatched Data Types: Decoding an incorrectly encoded data structure can lead to invalid memory access.</p>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-011/#remediation","title":"Remediation","text":"<ul> <li>Use <code>abi.encode()</code> Instead of <code>abi.encodePacked()</code> for Hashing: Prevent collision risks by ensuring unique encoding.</li> <li>Validate Data Before Decoding: Ensure the encoded data conforms to the expected structure before decoding.</li> <li>Match Encoding and Decoding Types: Always use the correct type structure when decoding to avoid unintended behavior.</li> <li>Avoid Direct ABI Decoding of External Calls: Use strict validation mechanisms when handling data from external contracts.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-011/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-011/#example-of-insecure-abi-encoding","title":"Example of Insecure ABI Encoding:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureABI {\n    function hashValues(string memory str, uint256 num) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(str, num)); // \u274c Collision risk\n    }\n}\n</code></pre> <ul> <li>In this example, <code>abi.encodePacked()</code> creates a collision risk because different input combinations can produce the same hash.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-011/#refactored-to-secure-abi-encoding","title":"Refactored to Secure ABI Encoding:","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract SecureABI {\n    function hashValues(string memory str, uint256 num) public pure returns (bytes32) {\n        return keccak256(abi.encode(str, num)); // \u2705 Unique encoding, no collision\n    }\n}\n</code></pre> <ul> <li>In this improved version, <code>abi.encode()</code> ensures a unique encoding structure, preventing hash collision attacks.</li> </ul>","tags":["scwe","L1","SCSVS-ARCH","SCSVS-ARCH-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-013/","title":"SCWE-013: Unauthorized Parameter Changes","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-013/#relationships","title":"Relationships","text":"<ul> <li>CWE-233: Improper Handling of Parameters    https://cwe.mitre.org/data/definitions/233.html</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-013/#description","title":"Description","text":"<p>Unauthorized parameter changes occur when privileged smart contract parameters\u2014such as fees, governance rules, withdrawal limits, or security configurations\u2014can be modified by a single entity or an unauthorized user. This can lead to unexpected behavior, security risks, or financial loss if an attacker gains access to the privileged account.</p> <p>Key risks associated with unauthorized parameter changes: - Single Point of Control: A centralized owner can unilaterally alter critical parameters, leading to governance concerns. - Malicious Modifications: Attackers who exploit an access control flaw may change key parameters, resulting in stolen funds or manipulated contract logic. - Lack of Transparency: Hidden or undocumented parameter changes can mislead users and investors, reducing trust. - Impact on DeFi Protocols: Unauthorized changes to liquidity pool fees, interest rates, or reward mechanisms can disrupt incentives and harm protocol users.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-013/#remediation","title":"Remediation","text":"<ul> <li>Use Role-Based Access Control (RBAC): Assign granular roles and restrict who can modify key parameters.</li> <li>Multisig Approval for Parameter Changes: Require governance approval (e.g., Gnosis Safe) before making critical updates.</li> <li>Timelocks for Parameter Changes: Introduce time delays on modifications to allow community review and prevent instant malicious changes.</li> <li>On-Chain Governance for DAOs: Utilize decentralized governance mechanisms where stakeholders vote on parameter updates.</li> <li>Emit Events for Transparency: Log all parameter changes on-chain to ensure visibility and auditability.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-013/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-013/#example-of-a-contract-with-unauthorized-parameter-changes-centralized-control","title":"Example of a Contract With Unauthorized Parameter Changes (Centralized Control)","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract RiskyContract {\n    address public owner;\n    uint256 public feeRate;\n\n    constructor() {\n        owner = msg.sender;\n        feeRate = 5; // Default fee rate\n    }\n\n    function updateFeeRate(uint256 newRate) public {\n        require(msg.sender == owner, \"Only owner can update fee rate\");\n        feeRate = newRate; // \u274c Single entity can modify a critical parameter at any time\n    }\n}\n</code></pre> <ul> <li>In this example, the owner can unilaterally change the fee rate, which poses a security risk.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-013/#refactored-to-require-multisig-and-timelocks","title":"Refactored to Require Multisig and Timelocks","text":"<pre><code>pragma solidity ^0.8.0;\n\ninterface ITimelock {\n    function queueTransaction(address target, uint256 value, bytes calldata data, uint256 eta) external;\n    function executeTransaction(address target, uint256 value, bytes calldata data, uint256 eta) external;\n}\n\ncontract SecureGovernance {\n    ITimelock public timelock;\n    uint256 public feeRate;\n\n    constructor(address _timelock) {\n        timelock = ITimelock(_timelock);\n        feeRate = 5; // Default fee rate\n    }\n\n    function updateFeeRate(uint256 newRate) public {\n        bytes memory data = abi.encodeWithSignature(\"setFeeRate(uint256)\", newRate);\n        timelock.queueTransaction(address(this), 0, data, block.timestamp + 2 days); // \u2705 Adds delay before execution\n    }\n\n    function setFeeRate(uint256 newRate) public {\n        require(msg.sender == address(timelock), \"Only timelock can execute\");\n        feeRate = newRate;\n    }\n}\n</code></pre> <p>This improved version: - Uses a Timelock contract to delay parameter changes, preventing instant unauthorized updates. - Restricts execution to an approved governance mechanism, preventing a single actor from making direct changes.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-014/","title":"SCWE-014: Lack of Emergency Stop Mechanism","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-014/#relationships","title":"Relationships","text":"<ul> <li>CWE-693: Protection Mechanism Failure CWE-693</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-014/#description","title":"Description","text":"<p>A Lack of Emergency Stop Mechanism refers to the absence of a built-in feature in a smart contract that allows for halting or pausing critical operations during emergencies. This mechanism is essential for mitigating risks like a discovered vulnerability, unexpected behavior, or a malicious attack. Without this safeguard, the contract may continue executing malicious actions or suffer irreversible damage. The ability to stop critical functions provides an important recovery measure in scenarios where an exploit is detected or control needs to be regained.</p> <p>Key risks: - Continuous execution of harmful or malicious actions without control. - Difficulty in recovering from unexpected failures. - Increased vulnerability to hacks or exploitation.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-014/#remediation","title":"Remediation","text":"<ul> <li>Implement a pausable contract pattern: Use the <code>Pausable</code> contract from the OpenZeppelin library to implement a mechanism that allows authorized users (e.g., the owner or a governance entity) to pause and unpause certain critical contract functions.</li> <li>Limit emergency stop to critical functions: Ensure that only critical functions can be paused to minimize the impact on the rest of the system's operation.</li> <li>Implement role-based access control: Use a role-based mechanism to control who has the ability to pause or unpause functions, reducing the risk of unauthorized access.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-014/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-014/#lack-of-emergency-stop-mechanism-example","title":"Lack of Emergency Stop Mechanism Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract NoEmergencyStop {\n    address public owner;\n    uint public criticalValue;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // This function is critical and lacks an emergency stop mechanism\n    function updateCriticalValue(uint newValue) public {\n        require(msg.sender == owner, \"Only the owner can update this value\");\n        criticalValue = newValue;\n    }\n}\n</code></pre> In the <code>NoEmergencyStop</code> contract, there is no way to stop or pause critical operations, which makes it vulnerable to continued exploitation if an issue arises.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-014/#fixed-emergency-stop-mechanism-example","title":"Fixed: Emergency Stop Mechanism Example","text":"<p><pre><code>pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\ncontract EmergencyStopExample is Pausable {\n    address public owner;\n    uint public criticalValue;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Critical function that can be paused in case of emergency\n    function updateCriticalValue(uint newValue) public whenNotPaused {\n        require(msg.sender == owner, \"Only the owner can update this value\");\n        criticalValue = newValue;\n    }\n\n    // Emergency stop function to pause the contract\n    function emergencyStop() public {\n        require(msg.sender == owner, \"Only the owner can stop the contract\");\n        _pause();  // Pauses the contract\n    }\n\n    // Emergency restart function to unpause the contract\n    function resumeOperations() public {\n        require(msg.sender == owner, \"Only the owner can resume the contract\");\n        _unpause();  // Resumes the contract\n    }\n}\n</code></pre> The <code>EmergencyStopExample</code> contract implements the <code>Pausable</code> pattern, which allows the contract owner to pause and unpause critical functions using the <code>emergencyStop</code> and <code>resumeOperations</code> functions. This ensures that if a vulnerability is discovered or a critical issue occurs, the contract can be halted temporarily to prevent further damage.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-CODE/SCWE-039/","title":"SCWE-039: Insecure Use of Inline Assembly","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-039/#relationships","title":"Relationships","text":"<ul> <li>CWE-704: Incorrect Type Conversion or Cast CWE-704 Link</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-039/#description","title":"Description","text":"<p>Insecure use of inline assembly refers to vulnerabilities that arise when low-level assembly code is used improperly. This can lead to: - Incorrect type conversions or casts. - Exploitation of vulnerabilities in low-level operations. - Loss of funds or data.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-039/#remediation","title":"Remediation","text":"<ul> <li>Avoid inline assembly: Use high-level Solidity code whenever possible.</li> <li>Validate inputs: Ensure all inputs to assembly code are properly validated.</li> <li>Test thoroughly: Conduct extensive testing to ensure assembly code is secure.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-039/#examples","title":"Examples","text":"<ul> <li>Insecure Inline Assembly- Unsafe Type Casting Leads to Exploitable Overflow <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureAssembly {\n    function unsafeCast(uint256 value) public pure returns (uint8) {\n        uint8 result;\n        assembly {\n            result := value // Unsafe cast, truncating high bits\n        }\n        return result;\n    }\n}\n</code></pre> \u26a0\ufe0f Why is this Vulnerable?</li> <li>Casting a large uint256 into uint8 without bounds checking causes integer truncation.</li> <li>If value = 257, it becomes 1 (256 is lost).</li> <li> <p>Attackers can bypass security checks if truncation affects authentication or balance checks.</p> </li> <li> <p>Secure High-Level Code- Restricted Use of Assembly with Input Validation <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureAssembly {\n    function safeCast(uint256 value) public pure returns (uint8) {\n        require(value &lt;= type(uint8).max, \"Value too large\"); // Prevent truncation\n        return uint8(value);\n    }\n}\n</code></pre> Fixes</p> </li> <li>Bounds checking (require) prevents unintended truncation.</li> <li>Uses inline assembly only when absolutely necessary.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-040/","title":"SCWE-040: Incorrect Storage Packing","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-040/#relationships","title":"Relationships","text":"<ul> <li>CWE-805: Buffer Access with Incorrect Length Value https://cwe.mitre.org/data/definitions/805.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-040/#description","title":"Description","text":"<p>Incorrect storage packing in Solidity occurs when storage variables are not efficiently packed within a single storage slot, leading to unnecessary gas consumption. Solidity automatically stores variables in 32-byte (256-bit) slots, and inefficient ordering of data types can lead to wasted space. Contracts that fail to optimize storage packing may incur higher gas costs during deployments and transactions.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-040/#remediation","title":"Remediation","text":"<p>To optimize storage packing: - Group smaller data types together (e.g., <code>uint8</code>, <code>bool</code>) to fit within a single 32-byte slot. - Avoid leaving gaps between variables of different sizes. - Order state variables efficiently to minimize wasted storage slots.  </p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-040/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract InefficientStorage {\n    uint256 a;  // Occupies full 32-byte slot\n    bool b;     // Occupies another 32-byte slot (wasteful)\n    uint8 c;    // Uses a new 32-byte slot instead of sharing\n    uint256 d;  // Uses its own slot, leading to extra gas costs\n}\n</code></pre> <p>Why is this vulnerable? - Each variable unnecessarily occupies a separate storage slot, increasing gas costs. - The <code>bool</code> and <code>uint8</code> could be packed into the same 32-byte slot, reducing wasted storage space.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-040/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>contract OptimizedStorage {\n    uint256 a;   // Occupies one full 32-byte slot\n    uint256 d;   // Placed next to 'a' to use another full slot\n    bool b;      // Packed within the same slot as 'c'\n    uint8 c;     // Fits within the same slot as 'b'\n}\n</code></pre> Why is this safe? - <code>bool</code> and <code>uint8</code> share the same storage slot, reducing unnecessary storage use. - <code>uint256</code> variables are placed together to minimize fragmentation. - Optimized storage layout leads to lower gas costs for contract execution.</p> <p>By correctly ordering state variables and utilizing Solidity\u2019s storage packing rules, developers can significantly reduce gas fees and improve contract efficiency.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-041/","title":"SCWE-041: Unsafe Downcasting","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-041/#relationships","title":"Relationships","text":"<ul> <li>CWE-681: Incorrect Conversion between Numeric Types https://cwe.mitre.org/data/definitions/681.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-041/#description","title":"Description","text":"<p>Unsafe downcasting occurs when a larger integer type is implicitly or explicitly converted to a smaller type, leading to precision loss, unintended value changes, or integer overflows. Solidity does not automatically check for overflow when performing explicit type conversions, making it possible to unintentionally truncate values.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-041/#remediation","title":"Remediation","text":"<p>To prevent unsafe downcasting: - Always validate that the value fits within the target data type before casting. - Use safe mathematical libraries like OpenZeppelin's <code>SafeCast</code> to ensure proper conversions. - Avoid unnecessary downcasting unless explicitly needed for gas optimization.  </p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-041/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract UnsafeDowncasting {\n    function truncateValue(uint256 largeNumber) public pure returns (uint8) {\n        return uint8(largeNumber);  // \u26a0\ufe0f Potential data loss if largeNumber &gt; 255\n    }\n}\n</code></pre> <p>Why is this vulnerable? - If <code>largeNumber &gt; 255</code>, the higher bits will be truncated, resulting in unexpected values. - No validation ensures that <code>largeNumber</code> fits within <code>uint8</code>, leading to silent failures.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-041/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract SafeDowncasting {\n    using SafeCast for uint256;\n\n    function safeTruncateValue(uint256 largeNumber) public pure returns (uint8) {\n        return largeNumber.toUint8();  // \u2705 Ensures safe conversion\n    }\n}\n</code></pre> Why is this safe?</p> <ul> <li>Uses OpenZeppelin\u2019s <code>SafeCast</code> library to enforce safe downcasting.</li> <li>If <code>largeNumber</code> exceeds <code>uint8</code> limits, the transaction will revert instead of silently truncating.</li> <li>Prevents unexpected behavior and potential security vulnerabilities.</li> </ul> <p>By properly handling type conversions, developers can avoid integer truncation issues and maintain data integrity in smart contracts.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-046/","title":"SCWE-046: Reentrancy Attacks","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-046/#relationships","title":"Relationships","text":"<ul> <li>CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition https://cwe.mitre.org/data/definitions/367.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-046/#description","title":"Description","text":"<p>Reentrancy attacks occur when a contract allows untrusted external calls during execution without properly updating state variables or implementing protections. This enables attackers to repeatedly call functions and manipulate the contract\u2019s state before execution completes. Common issues include:</p> <ul> <li>Making external calls before updating state variables.  </li> <li>Lack of mechanisms to prevent repeated or recursive calls.  </li> <li>Improper handling of external interactions. </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-046/#remediation","title":"Remediation","text":"<ul> <li>Update state first: Modify critical state variables before any external calls.  </li> <li>Implement reentrancy guards: Use tools like <code>nonReentrant</code> modifiers to block recursive calls. </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-046/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-046/#vulnerable-contract-example-reentrancy","title":"Vulnerable Contract Example (Reentrancy)","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract Vulnerable {\n    mapping(address =&gt; uint) public balances;\n\n    function withdraw(uint _amount) public {\n        require(balances[msg.sender] &gt;= _amount);\n        msg.sender.call.value(_amount)(); // Vulnerable external call\n        balances[msg.sender] -= _amount;\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-046/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract Secure is ReentrancyGuard {\n    mapping(address =&gt; uint) public balances;\n\n    function withdraw(uint _amount) public nonReentrant {\n        require(balances[msg.sender] &gt;= _amount, \"Insufficient balance\");\n        balances[msg.sender] -= _amount;\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-047/","title":"SCWE-047: Integer Overflows and Underflows","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-047/#relationships","title":"Relationships","text":"<ul> <li>CWE-190: Integer Overflow or Wraparound https://cwe.mitre.org/data/definitions/190.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-047/#description","title":"Description","text":"<p>Integer overflows and underflows occur when arithmetic operations exceed the bounds of the integer data type, causing the value to \"wrap around\" to an unexpected number.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-047/#remediation","title":"Remediation","text":"<ul> <li>Use Solidity 0.8.0 or later: Leverage the compiler\u2019s built-in overflow and underflow checks.  </li> <li>Apply SafeMath libraries: Use libraries like OpenZeppelin\u2019s <code>SafeMath</code> for versions before 0.8.0.  </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-047/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-047/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract Vulnerable {\n    uint8 public totalSupply;\n\n    function addTokens(uint8 _value) public {\n        totalSupply += _value; // May overflow\n    }\n\n    function subtractTokens(uint8 _value) public {\n        totalSupply -= _value; // May underflow\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-047/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.6.0;\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Secure {\n    using SafeMath for uint8;\n    uint8 public totalSupply;\n\n    function addTokens(uint8 _value) public {\n        totalSupply = totalSupply.add(_value);\n    }\n\n    function subtractTokens(uint8 _value) public {\n        totalSupply = totalSupply.sub(_value);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-048/","title":"SCWE-048: Unchecked Call Return Value","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-048/#relationships","title":"Relationships","text":"<ul> <li>CWE-252: Unchecked Return Value   https://cwe.mitre.org/data/definitions/252.html</li> <li>CWE-390: Detection of Error Condition Without Action   https://cwe.mitre.org/data/definitions/390.html</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-048/#description","title":"Description","text":"<p>Unchecked call return value vulnerabilities occur when a contract fails to validate the success or failure of low-level calls, such as <code>call</code>, <code>delegatecall</code>, and <code>staticcall</code>. Ignoring the return values of these calls can result in undetected errors, allowing malicious or unintended actions to succeed silently.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-048/#remediation","title":"Remediation","text":"<ul> <li>Check return values: Always verify the success of low-level calls.  </li> <li>Use higher-level abstractions: Prefer method calls or, if you are confident that 2300 gas are sufficient for the recipient to handle the transfer, <code>transfer</code> over <code>call</code>, as they revert on failure. </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-048/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-048/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract UncheckedCall {\n    function sendEther(address _recipient) public payable {\n        _recipient.call{value: msg.value}(\"\"); // Unchecked call, no error handling\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-048/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract CheckedCall {\n    function sendEther(address payable _recipient) public payable {\n        (bool success, ) = _recipient.call{value: msg.value}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-053/","title":"SCWE-053: Improper Deletion of Mappings","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-053/#relationships","title":"Relationships","text":"<ul> <li>CWE-459: Incomplete Cleanup https://cwe.mitre.org/data/definitions/459.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-053/#description","title":"Description","text":"<p>In Solidity, mappings (<code>mapping(address =&gt; uint256)</code>) do not store key-value pairs in a way that allows them to be iterated over or deleted in a straightforward manner. Deleting a mapping variable does not remove its entries; it only resets the reference to the mapping, leaving stale data accessible if another variable references the same mapping. Improper deletion of mappings can lead to storage inconsistencies, potential access control issues, and unintended behavior.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-053/#remediation","title":"Remediation","text":"<ul> <li>Instead of using <code>delete mappingVariable;</code>, explicitly set each key\u2019s value to zero where necessary.  </li> <li>Consider additional data structures (e.g., arrays or linked lists) to track mapping keys if deletion is required.  </li> <li>Ensure mapping deletions do not leave residual data that can be accessed unexpectedly.  </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-053/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<p><pre><code>contract Example {\n    mapping(address =&gt; uint256) public balances;\n\n    function addBalance(address user, uint256 amount) public {\n        balances[user] = amount;\n    }\n\n    function resetBalances() public {\n        delete balances;  // \u274c This does not clear individual key-value pairs!\n    }\n}\n</code></pre> Why is this vulnerable?</p> <ul> <li><code>delete balances;</code> only resets the storage reference but does not remove key-value pairs.</li> <li>If another contract or function still references <code>balances</code>, the data remains accessible.</li> <li>Unexpected behavior may arise where users assume balances have been erased but can still access the old data.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-053/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract SecureExample {\n    mapping(address =&gt; uint256) public balances;\n    address[] private users;\n\n    function addBalance(address user, uint256 amount) public {\n        if (balances[user] == 0) {\n            users.push(user);\n        }\n        balances[user] = amount;\n    }\n\n    function resetBalances() public {\n        for (uint256 i = 0; i &lt; users.length; i++) {\n            balances[users[i]] = 0;  // \u2705 Explicitly clears each entry\n        }\n        delete users;  // \u2705 Resets the tracking array\n    }\n}\n</code></pre> <p>Why is this safe? - Tracks users in an array to allow explicit deletion of each mapping entry. - Ensures all key-value pairs are properly reset instead of just deleting the mapping reference. - Prevents residual data from being accessed unintentionally.</p> <p>By properly handling mapping deletions, developers can avoid unintended data persistence and ensure accurate contract state management.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-060/","title":"SCWE-060: Floating Pragma","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-060/#relationships","title":"Relationships","text":"<ul> <li>CWE-703: Improper Check for Unusual or Exceptional Conditions https://cwe.mitre.org/data/definitions/703.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-060/#description","title":"Description","text":"<p>The use of floating pramas (e.g., <code>^0.8.0</code>) in smart contract development can lead to unexpected issues when new versions of the Solidity compiler are released. Floating versions allow the contract to automatically use newer versions of the compiler within the specified range, which may introduce breaking changes, unexpected bugs, or security vulnerabilities. To avoid this, it is important to specify fixed versions to ensure the contract works reliably and consistently across different environments.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-060/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, always specify a fixed compiler version in the contract to avoid using floating pramas. This ensures that the contract is compiled using a known and tested version of the compiler, preventing unexpected behavior from new, untested releases.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-060/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity ^0.8.0;  // Floating version allows for any 0.8.x version\n\ncontract Vulnerable {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-060/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity 0.8.4;  // Fixed version ensures no unexpected updates\n\ncontract Fixed {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-061/","title":"SCWE-061: Outdated Compiler Version","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-061/#relationships","title":"Relationships","text":"<ul> <li>CWE-1103: Use of Outdated or Insecure Software https://cwe.mitre.org/data/definitions/1103.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-061/#description","title":"Description","text":"<p>Using an outdated compiler version can expose a smart contract to vulnerabilities that have already been patched in newer versions. Compiler versions often include security fixes, optimizations, and new features that are crucial for the safety and performance of contracts.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-061/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, always use the most up-to-date stable version of the Solidity compiler. Ensure that your development environment is regularly updated to incorporate the latest security patches, optimizations, and features provided by newer versions of the compiler.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-061/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>pragma solidity 0.4.24;  // Outdated compiler version\n\ncontract Vulnerable {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-061/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>pragma solidity 0.8.4;  // Updated compiler version for better security and performance\n\ncontract Fixed {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-062/","title":"SCWE-062: Dead Code","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-062/#relationships","title":"Relationships","text":"<ul> <li>CWE-561: Dead Code https://cwe.mitre.org/data/definitions/561.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-062/#description","title":"Description","text":"<p>Code with no effects or Dead Code- refers to segments of a smart contract that are never executed or do not alter the contract's state or output. This can lead to unnecessary gas consumption, complicate the contract\u2019s logic, and potentially confuse developers. Dead code often appears as leftover code from previous iterations or functions that are no longer in use but have not been removed. Removing such code improves contract efficiency and readability.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-062/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, ensure that all functions, variables, and logic in the smart contract have a purpose and contribute to the contract\u2019s behavior. Unused code should be removed to reduce complexity, save gas, and improve maintainability.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-062/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Vulnerable {\n    uint public value;\n\n    // Dead code, never called or used\n    function unusedFunction() public {\n        uint x = 5;\n        uint y = 10;\n        uint result = x + y;\n    }\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-062/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Fixed {\n    uint public value;\n\n    function setValue(uint _value) public {\n        value = _value;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-066/","title":"SCWE-066: Incorrect Handling of Bitwise Operations","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-066/#relationships","title":"Relationships","text":"<ul> <li>CWE-682: Incorrect Calculation https://cwe.mitre.org/data/definitions/682.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-066/#description","title":"Description","text":"<p>Bitwise operations (e.g., <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>) can be efficient alternatives to arithmetic operations but are prone to errors if not used correctly. Misusing bitwise shifts can cause unintended value changes, integer overflows, or precision loss. Solidity lacks native overflow checks for bitwise shifts, making incorrect handling particularly dangerous in financial calculations or cryptographic functions.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-066/#remediation","title":"Remediation","text":"<ul> <li>Ensure bitwise shifts do not exceed the size of the data type (e.g., shifting a <code>uint8</code> left by 8+ bits).  </li> <li>Validate input ranges before performing shifts to prevent overflow or precision loss.  </li> <li>Avoid unnecessary bitwise operations in financial calculations unless explicitly needed.  </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-066/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<p><pre><code>contract Example {\n    function shiftLeft(uint8 input) public pure returns (uint8) {\n        return input &lt;&lt; 8;  // \u274c Shifting beyond `uint8` capacity leads to zero\n    }\n\n    function bitwiseAnd(uint8 a, uint8 b) public pure returns (uint8) {\n        return a &amp; b;  // \u274c Without proper validation, this could lead to unintended masking\n    }\n}\n</code></pre> Why is this vulnerable?</p> <ul> <li><code>input &lt;&lt; 8</code> shifts a <code>uint8</code> completely out of range, resulting in a value of <code>0</code>.</li> <li><code>a &amp; b</code> can unintentionally mask critical bits if inputs are not properly validated.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-066/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract SecureExample {\n    function safeShiftLeft(uint8 input) public pure returns (uint8) {\n        require(input &lt; 32, \"Shift too large\");  // \u2705 Validate shift range\n        return input &lt;&lt; 2;  // \u2705 Safe shift within `uint8` bounds\n    }\n\n    function safeBitwiseAnd(uint8 a, uint8 b) public pure returns (uint8) {\n        require(a &gt; 0 &amp;&amp; b &gt; 0, \"Invalid input\");  // \u2705 Ensure inputs are meaningful\n        return a &amp; b;\n    }\n}\n</code></pre> <p>Why is this safe?</p> <ul> <li>Restricts shift values to prevent unexpected overflows.</li> <li>Ensures bitwise operations do not unintentionally modify values in an unintended way.</li> <li>Protects contract logic from potential manipulation through poorly validated inputs.</li> </ul> <p>By correctly handling bitwise operations, developers can avoid unintended computation errors and ensure mathematical correctness in smart contracts.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-067/","title":"SCWE-067: Assert Violation","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-067/#relationships","title":"Relationships","text":"<ul> <li>CWE-754: Improper Check for Unusual or Exceptional Conditions https://cwe.mitre.org/data/definitions/754.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-067/#description","title":"Description","text":"<p>In Ethereum smart contracts, assertions (<code>assert</code>) are commonly used for internal consistency checks and to prevent erroneous states. However, if not used correctly, they can lead to unexpected behavior. When an <code>assert</code> statement fails, it reverts the entire transaction, and all changes made in the transaction are reverted. This can be problematic if it is used for conditions that can be expected during normal contract execution.</p> <p>Using <code>assert</code> for conditions that can occur under normal circumstances (e.g., user inputs or contract logic) may cause unnecessary reverts and loss of gas. It\u2019s important to reserve <code>assert</code> for critical errors, such as invariants and internal state checks that should never fail.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-067/#remediation","title":"Remediation","text":"<p>To avoid unnecessary assertion failures, use <code>require</code> for input validation and conditions that can reasonably fail. <code>assert</code> should only be used for internal error detection and state validation that should never happen, as it signals a critical issue if violated.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-067/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Vulnerable {\n    uint public balance;\n\n    constructor() {\n        balance = 100;\n    }\n\n    function withdraw(uint amount) public {\n        assert(balance &gt;= amount);  // Assert violation on user input\n        balance -= amount;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-067/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Secure {\n    uint public balance;\n\n    constructor() {\n        balance = 100;\n    }\n\n    function withdraw(uint amount) public {\n        require(balance &gt;= amount, \"Insufficient balance\");  // Use require for expected conditions\n        balance -= amount;\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-068/","title":"SCWE-068: State Variable Default Visibility","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-068/#relationships","title":"Relationships","text":"<ul> <li>CWE-704: Incorrect Type Conversion or Cast https://cwe.mitre.org/data/definitions/704.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-068/#description","title":"Description","text":"<p>In Solidity, state variables have a default visibility of <code>internal</code>, which means they can only be accessed within the contract or derived contracts. However, developers might unintentionally leave state variables with incorrect or unspecified visibility, leading to unintended access. In some cases, this could allow external contracts or users to interact with the variable, potentially leading to security vulnerabilities, such as unauthorized access or manipulation of the contract's state.</p> <p>It is essential to explicitly define the visibility of state variables to ensure they behave as intended and are protected from unintended access.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-068/#remediation","title":"Remediation","text":"<p>Always explicitly specify the visibility of state variables. The possible visibility options are: - <code>public</code>: Accessible by anyone, both externally and internally. - <code>internal</code>: Accessible only within the contract or derived contracts (default). - <code>private</code>: Accessible only within the contract.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-068/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Vulnerable {\n    uint publicBalance;  // Default visibility is internal, but it is still publicly accessible\n\n    constructor() {\n        publicBalance = 100;\n    }\n\n    function updateBalance(uint amount) public {\n        publicBalance = amount;  // Access to internal variable, but external access is possible\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-068/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Secure {\n    uint private balance;  // Explicitly set visibility to private\n\n    constructor() {\n        balance = 100;\n    }\n\n    function updateBalance(uint amount) public {\n        balance = amount;  // No external access to the variable\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-069/","title":"SCWE-069: Shadowing State Variables","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-069/#relationships","title":"Relationships","text":"<ul> <li>CWE-1001: Variable Shadowing https://cwe.mitre.org/data/definitions/1001.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-069/#description","title":"Description","text":"<p>Shadowing occurs when a state variable in a derived contract uses the same name as one in the base contract. This can lead to confusion and unexpected behavior, as the derived contract will hide the state variable from the base contract, potentially causing errors in contract logic or making it harder to maintain and audit the code.</p> <p>It is essential to avoid naming state variables in derived contracts the same as those in base contracts to ensure that the intended state is correctly accessed and modified.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-069/#remediation","title":"Remediation","text":"<p>To avoid state variable shadowing, use unique names for state variables in derived contracts or explicitly refer to the base contract variable using <code>super</code>. This will ensure that the correct state variable is accessed and manipulated as intended.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-069/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Base {\n    uint public balance;\n\n    constructor() {\n        balance = 100;\n    }\n}\n\ncontract Derived is Base {\n    uint public balance;  // Shadows state variable from Base contract\n\n    function updateBalance(uint amount) public {\n        balance = amount;  // Refers to Derived's balance, not Base's balance\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-069/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Base {\n    uint public balance;\n\n    constructor() {\n        balance = 100;\n    }\n}\n\ncontract Derived is Base {\n    uint public newBalance;  // Unique name for Derived contract\n\n    function updateBalance(uint amount) public {\n        newBalance = amount;  // Updates Derived's balance without shadowing\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-072/","title":"SCWE-072: Use of Deprecated Solidity Functions","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-072/#relationships","title":"Relationships","text":"<ul> <li>CWE-676: Use of a Dangerous Function https://cwe.mitre.org/data/definitions/676.html </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-072/#description","title":"Description","text":"<p>Some Solidity functions and features have been deprecated over time due to security risks, inefficiencies, or better alternatives being introduced in newer versions of Solidity. Using deprecated functions can expose contracts to known vulnerabilities and potential attacks. Examples include <code>suicide()</code>, which was replaced by <code>selfdestruct()</code>, and <code>sha3()</code>, which was replaced by <code>keccak256()</code>.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-072/#remediation","title":"Remediation","text":"<p>Always check the Solidity documentation to ensure that the functions you're using are not deprecated. If a function is deprecated, replace it with its recommended alternative to maintain the contract\u2019s security and ensure compatibility with future Solidity versions.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-072/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    function oldFunction() public {\n        // Using deprecated function `suicide`\n        suicide(msg.sender);  // Deprecated, should be replaced with `selfdestruct`\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-072/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Example {\n    function oldFunction() public {\n        // Correctly using the recommended alternative `selfdestruct`\n        selfdestruct(payable(msg.sender));  // Replacing deprecated `suicide` with `selfdestruct`\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-076/","title":"SCWE-076: Right-To-Left-Override Control Character (U+202E)","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-076/#relationships","title":"Relationships","text":"<ul> <li>CWE-451: User Interface (UI) Misrepresentation of Critical Information CWE-451 Link</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-076/#description","title":"Description","text":"<p>The Right-To-Left-Override (RTLO) control character (U+202E) can be used to manipulate the display order of text, creating misleading or deceptive visual representations in source code. Malicious actors can exploit this to: - Mask malicious logic or misrepresent code intent. - Introduce security-critical bugs that are difficult to detect visually. - Deceive auditors, developers, or end-users by obscuring real functionality.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-076/#remediation","title":"Remediation","text":"<ul> <li>Disallow U+202E in source code: Ensure RTLO and similar Unicode direction control characters are explicitly banned in smart contracts.</li> <li>Static analysis tools: Use static analysis to detect and prevent Unicode control characters in contract source code.</li> <li>Education and awareness: Educate developers about the risks associated with Unicode control characters in smart contract development.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-076/#examples","title":"Examples","text":"<ul> <li> <p>Code with RTLO Character <pre><code>pragma solidity ^0.8.0;\n\ncontract MaliciousExample {\n    function performAction() public {\n        // The following line contains an RTLO character to misrepresent the logic visually\n        executeLogic(/* attacker logic\u202e/*desrever ro*/victim logic */);\n    }\n\n    function executeLogic(bytes memory logic) internal {\n        // Process logic here\n    }\n}\n</code></pre></p> </li> <li> <p>Code Without RTLO Character <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureExample {\n    function performAction(bytes memory logic) public {\n        // Properly documented and clear function calls\n        executeLogic(logic);\n    }\n\n    function executeLogic(bytes memory logic) internal {\n        // Process logic here\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-2"]},{"location":"SCWE/SCSVS-CODE/SCWE-089/","title":"SCWE-089: Vulnerable & Outdated Libraries","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-089/#relationships","title":"Relationships","text":"<ul> <li>CWE-1104: Use of Unmaintained Third Party Components CWE-1104 Link</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-089/#description","title":"Description","text":"<p>Smart contracts that depend on outdated or vulnerable third\u2011party libraries inherit their security flaws. Attackers can exploit known issues in widely used libraries (e.g., reentrancy, integer overflow, or access control bypasses), especially if the library is no longer maintained or patched. Common risks include: - Exploitation of known vulnerabilities in older OpenZeppelin versions or other dependencies. - Inheriting insecure logic or deprecated patterns from unmaintained libraries. - Increased attack surface due to indirect dependencies.  </p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-089/#remediation","title":"Remediation","text":"<ul> <li>Version pinning: Always specify exact, up\u2011to\u2011date versions of dependencies in <code>package.json</code>, <code>foundry.toml</code>, or <code>hardhat.config.js</code>.  </li> <li>Regular audits: Periodically review library versions for known vulnerabilities and upgrade accordingly.  </li> <li>Vendor management: Rely on reputable, actively maintained libraries (e.g., OpenZeppelin). Avoid custom forks unless fully audited.  </li> <li>Automated scanning: Use dependency scanners (e.g., <code>npm audit</code>, <code>snyk</code>, <code>slither-check-oz</code>) to detect outdated or vulnerable libraries.  </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-089/#examples","title":"Examples","text":"<ul> <li> <p>Outdated Dependency Example (<code>package.json</code>) <pre><code>{\n  \"dependencies\": {\n    \"@openzeppelin/contracts\": \"^2.3.0\",\n    \"truffle\": \"^5.0.0\"\n  },\n  \"notes\": \"Insecure: OpenZeppelin v2.3.0 contains outdated ERC777 and SafeMath implementations.\"\n}\n</code></pre></p> </li> <li> <p>Updated Dependency Example (<code>package.json</code>) <pre><code>{\n  \"dependencies\": {\n    \"@openzeppelin/contracts\": \"^5.0.0\",\n    \"hardhat\": \"^2.22.0\"\n  },\n  \"notes\": \"Secure: Latest OpenZeppelin release with modern ERC20, patched ERC777, and Solidity 0.8+ overflow checks.\"\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-090/","title":"SCWE-090: Missing Slippage Protection in Automated Token Swaps","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-090/#relationships","title":"Relationships","text":"<ul> <li>CWE-20:  Improper Input Validation    CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-090/#description","title":"Description","text":"<p>This weakness occurs when smart contracts execute token swaps through DEX routers (e.g., Uniswap, PancakeSwap, SushiSwap) with the amountOutMin parameter set to 0 or a hardcoded static value. This disables slippage protection and allows trades to execute regardless of adverse price movement. As a result, users or protocols may receive significantly fewer tokens than expected, especially under high volatility, front-running, or sandwich attack conditions.</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-090/#remediation","title":"Remediation","text":"<ul> <li>Always validate amountOutMin based on live price quotes (e.g., using on-chain oracles or pre-trade estimates).</li> <li>Allow users to configure slippage tolerance (0.5%, 1%, etc.), and enforce it in contract logic.</li> <li>Never hardcode 0 or static values for amountOutMin.</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-090/#examples","title":"Examples","text":"<ul> <li> <p>Vulnerable Code (Missing Slippage Protection) <pre><code>function swapTokens(address tokenIn, address tokenOut, uint256 amountIn) external {\n    IERC20(tokenIn).approve(address(uniswapRouter), amountIn);\n\n    address ;\n    path[0] = tokenIn;\n    path[1] = tokenOut;\n\n    // \u274c amountOutMin is set to 0 \u2192 no protection against slippage\n    uniswapRouter.swapExactTokensForTokens(\n        amountIn,\n        0, // Vulnerable: accepts any output amount\n        path,\n        msg.sender,\n        block.timestamp\n    );\n} \n</code></pre></p> </li> <li> <p>Safe Code (With Slippage Protection) <pre><code>function swapTokensWithSlippage(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 minAmountOut\n) external {\n    IERC20(tokenIn).approve(address(uniswapRouter), amountIn);\n\n    address ;\n    path[0] = tokenIn;\n    path[1] = tokenOut;\n\n    // \u2705 Enforces user-provided slippage tolerance\n    uniswapRouter.swapExactTokensForTokens(\n        amountIn,\n        minAmountOut, // Safe: requires a minimum output\n        path,\n        msg.sender,\n        block.timestamp\n    );\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-091/","title":"SCWE-091: Lack of Zero Value Check in Token Transfers","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-091/#relationships","title":"Relationships","text":"<ul> <li>CWE-754: Improper Check for Unusual or Exceptional Conditions CWE-754 Link</li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-091/#description","title":"Description","text":"<p>This weakness occurs when smart contracts perform ERC20 token transfers without first validating that the transfer amount is greater than zero. While most ERC20 tokens allow zero\u2011value transfers, some implementations (e.g., LEND and others) revert when the amount is zero. This inconsistency can cause unexpected reverts in production, disrupt execution flow, and prevent critical contract logic from completing successfully. Common risks include: - Unexpected revert when interacting with non\u2011standard ERC20 tokens that disallow zero\u2011value operations. - Potential denial\u2011of\u2011service conditions if an attacker or integration repeatedly triggers zero\u2011value transfers. - Broken integrations when protocols assume uniform ERC20 behavior across diverse tokens.  </p>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-091/#remediation","title":"Remediation","text":"<ul> <li>Validate transfer amounts: Ensure <code>amount &gt; 0</code> before calling <code>transfer</code>/<code>transferFrom</code>.  </li> <li>Treat zero as a no\u2011op if acceptable: Early\u2011return when <code>amount == 0</code> rather than calling token methods.  </li> <li>Use robust token wrappers: Centralize token operations (e.g., via OpenZeppelin <code>SafeERC20</code>) and standardize zero\u2011value handling.  </li> <li>Integration testing: Include zero\u2011value cases for all integrated tokens (especially known non\u2011standard tokens like LEND).  </li> <li>Input sanitization: Validate and sanitize externally supplied amounts prior to token interactions.  </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-091/#examples","title":"Examples","text":"<ul> <li> <p>Vulnerable Code (No Zero Value Check) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract ExampleContract {\n    using SafeERC20 for IERC20;\n    IERC20 public inToken;\n    address public vault;\n\n    function transferTokens(uint256 feeTokenAmount) external {\n        // No validation \u2192 may revert with some ERC20 tokens\n        inToken.safeTransfer(vault, feeTokenAmount);\n    }\n}\n</code></pre></p> </li> <li> <p>Safe Code (With Zero Value Check) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract ExampleContract {\n    using SafeERC20 for IERC20;\n    IERC20 public inToken;\n    address public vault;\n\n    function transferTokens(uint256 feeTokenAmount) external {\n        require(feeTokenAmount &gt; 0, \"Amount must be greater than zero\");\n        inToken.safeTransfer(vault, feeTokenAmount);\n    }\n}\n</code></pre></p> </li> <li> <p>Alternative Safe Pattern (No\u2011op on Zero) <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract ExampleContract {\n    using SafeERC20 for IERC20;\n    IERC20 public inToken;\n    address public vault;\n\n    function transferTokens(uint256 feeTokenAmount) external {\n        if (feeTokenAmount == 0) {\n            return; // Skip calling token methods to avoid non-standard reverts\n        }\n        inToken.safeTransfer(vault, feeTokenAmount);\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-092/","title":"SCWE-092: Missing Disable Initializer in Constructor for Proxy Contracts","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","L2","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-092/#relationships","title":"Relationships","text":"<ul> <li>CWE-665: Improper Initialization</li> </ul>","tags":["scwe","L1","L2","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-092/#description","title":"Description","text":"<p>This weakness occurs when upgradeable proxy contracts (e.g., UUPS or Transparent Proxy patterns) do not include a call to <code>_disableInitializers()</code> inside their constructor. Without this safeguard, malicious actors may invoke the <code>initialize()</code> function directly on the implementation contract. This can lead to takeover of admin roles, unauthorized ownership assignment, or malicious configuration of protocol-critical parameters.  </p> <p>This mistake is frequently observed in contracts built with OpenZeppelin Upgradeable libraries where developers forget to disable initializers in the implementation contract\u2019s constructor.  </p>","tags":["scwe","L1","L2","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-092/#impact","title":"Impact","text":"<p>Failure to disable initializers in proxy contracts is a recurring and high-severity weakness. It enables attackers to: - Become the owner/admin of an uninitialized logic contract. - Hijack upgradeability or governance control. - Set malicious parameters (fees, treasury addresses, token supply logic, etc.).  </p> <p>This weakness has caused multiple security incidents in production DeFi and NFT projects where attackers initialized orphaned implementation contracts and drained funds.  </p> <p>Its importance stems from: - Widespread use of upgradeable contracts in DeFi and DAOs. - Frequent developer oversight when using proxy patterns. - High impact \u2014 loss of protocol ownership, funds, and governance control.  </p>","tags":["scwe","L1","L2","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-092/#remediation","title":"Remediation","text":"<ul> <li>Always call <code>_disableInitializers()</code> in the constructor of implementation contracts.  </li> <li>Review all upgradeable contracts to ensure the implementation cannot be directly initialized.  </li> <li>Use OpenZeppelin\u2019s recommended pattern and annotations (e.g., <code>@custom:oz-upgrades-unsafe-allow constructor</code>) when disabling initializers.  </li> </ul>","tags":["scwe","L1","L2","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-CODE/SCWE-092/#examples","title":"Examples","text":"<ul> <li>\u274c Vulnerable Code <pre><code>// Implementation contract for a UUPS Proxy\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract Vault is Initializable {\n    address public owner;\n\n    function initialize(address _owner) public initializer {\n        owner = _owner;\n    }\n}\n</code></pre></li> </ul> <p>\u26a0\ufe0f Issue: - The constructor does not call <code>_disableInitializers()</code>. - Attackers can directly call <code>initialize()</code> on the implementation contract (not through the proxy) and take over ownership.  </p> <ul> <li>\u2705 Safe Code <pre><code>// Secure implementation contract for a UUPS Proxy\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract Vault is Initializable {\n    address public owner;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers(); // Prevents initialize() from being called on implementation\n    }\n\n    function initialize(address _owner) public initializer {\n        owner = _owner;\n    }\n}\n</code></pre></li> </ul> <p>\u2705 Fix: - Adding <code>_disableInitializers()</code> in the constructor ensures the logic (implementation) contract cannot be initialized directly. - Only the proxy can call <code>initialize()</code> safely during deployment.  </p>","tags":["scwe","L1","L2","SCSVS-CODE","SCSVS-CODE-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-021/","title":"SCWE-021: Unsecured Data Transmission","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-021/#relationships","title":"Relationships","text":"<ul> <li>CWE-319: Cleartext Transmission of Sensitive Information CWE-319 Link</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-021/#description","title":"Description","text":"<p>Unsecured data transmission refers to the transmission of sensitive information, such as private keys or user data, without encryption. This can lead to: - Interception of sensitive data by malicious actors. - Exploitation of vulnerabilities in the contract. - Loss of funds or data.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-021/#remediation","title":"Remediation","text":"<ul> <li>Use encryption: Encrypt sensitive data before transmission.</li> <li>Leverage secure protocols: Use HTTPS or other secure communication protocols.</li> <li>Avoid transmitting sensitive data: Minimize the transmission of sensitive data whenever possible.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-021/#examples","title":"Examples","text":"<ul> <li> <p>Unsecured Data Transmission <pre><code>pragma solidity ^0.8.0;\n\ncontract UnsecuredData {\n    function transmitData(bytes memory data) public {\n        // Transmit data without encryption\n    }\n}\n</code></pre></p> </li> <li> <p>Secured Data Transmission <pre><code>pragma solidity ^0.8.0;\n\ncontract SecuredData {\n    function transmitData(bytes memory encryptedData) public {\n        // Transmit encrypted data\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-022/","title":"SCWE-022: Message Replay Vulnerabilities","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-022/#relationships","title":"Relationships","text":"<ul> <li>CWE-294: Authentication Bypass by Capture-replay CWE-294 Link</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-022/#description","title":"Description","text":"<p>Message replay vulnerabilities occur when an attacker can reuse a valid message or transaction to perform unauthorized actions. This can lead to: - Unauthorized access to sensitive functions. - Loss of funds or data. - Exploitation of the contract's logic.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-022/#remediation","title":"Remediation","text":"<ul> <li>Use nonces: Include a unique nonce in each message to prevent reuse.</li> <li>Validate timestamps: Ensure messages are only valid for a limited time.</li> <li>Implement replay protection: Use established libraries or mechanisms to prevent replay attacks.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-022/#examples","title":"Examples","text":"<ul> <li> <p>Vulnerable to Replay Attacks <pre><code>pragma solidity ^0.8.0;\n\ncontract ReplayVulnerable {\n    function processMessage(bytes memory message) public {\n        // Process message without replay protection\n    }\n}\n</code></pre></p> </li> <li> <p>Protected Against Replay Attacks <pre><code>pragma solidity ^0.8.0;\n\ncontract ReplayProtected {\n    mapping(bytes32 =&gt; bool) public usedMessages;\n\n    function processMessage(bytes memory message, uint nonce, uint chainId) public {\n        bytes32 messageHash = keccak256(abi.encodePacked(message, nonce, chainId));\n        require(!usedMessages[messageHash], \"Message already used\");\n        usedMessages[messageHash] = true;\n        // Process message\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-023/","title":"SCWE-023: Lack of Communication Authenticity","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-023/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-023/#description","title":"Description","text":"<p>Lack of communication authenticity refers to the failure to verify the authenticity of messages or transactions. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of the contract's logic.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-023/#remediation","title":"Remediation","text":"<ul> <li>Use signatures: Require signed messages for critical actions.</li> <li>Validate inputs: Ensure all messages are properly validated before processing.</li> <li>Implement secure communication: Use secure protocols and libraries for communication.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-023/#examples","title":"Examples","text":"<ul> <li> <p>Lack of Authenticity <pre><code>pragma solidity ^0.8.0;\n\ncontract NoAuthenticity {\n    function processMessage(bytes memory message) public {\n        // Process message without authenticity check\n    }\n}\n</code></pre></p> </li> <li> <p>Authentic Communication <pre><code>pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract AuthenticCommunication {\n    using ECDSA for bytes32;\n\n    function processMessage(bytes memory message, bytes memory signature) public {\n        bytes32 messageHash = keccak256(message);\n        address signer = messageHash.recover(signature);\n        require(signer == msg.sender, \"Invalid signature\");\n        // Process message\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-035/","title":"SCWE-035: Insecure Delegatecall Usage","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-035/#relationships","title":"Relationships","text":"<ul> <li>CWE-250: Execution with Unnecessary Privileges CWE-250 Link</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-035/#description","title":"Description","text":"<p>Insecure delegatecall usage refers to vulnerabilities that arise when using <code>delegatecall</code> to execute code from another contract. This can lead to: - Unauthorized access to sensitive functions. - Exploitation of vulnerabilities in the called contract. - Loss of funds or data.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-035/#remediation","title":"Remediation","text":"<ul> <li>Validate targets: Ensure the target contract is trusted and secure.</li> <li>Restrict permissions: Restrict <code>delegatecall</code> usage to trusted addresses.</li> <li>Test thoroughly: Conduct extensive testing to ensure <code>delegatecall</code> is used securely.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-035/#examples","title":"Examples","text":"<ul> <li>Insecure Delegatecall Usage <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureDelegatecall {\n    function executeDelegatecall(address target, bytes memory data) public {\n        (bool success, ) = target.delegatecall(data); // \u274c No validation, attacker-controlled contract can be used\n        require(success, \"Delegatecall failed\");\n    }\n}\n</code></pre></li> <li>Anyone can call <code>executeDelegatecall()</code> with a malicious contract, which will execute arbitrary code within the caller\u2019s context.</li> <li> <p>Can lead to theft of funds, privilege escalation, or state corruption.</p> </li> <li> <p>Secure Delegatecall Usage <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureDelegatecall {\n    address public owner;\n    address public trustedTarget;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not authorized\");\n        _;\n    }\n\n    constructor(address _trustedTarget) {\n        owner = msg.sender;\n        trustedTarget = _trustedTarget;\n    }\n\n    function updateTrustedTarget(address _newTarget) public onlyOwner {\n        require(isTrusted(_newTarget), \"Untrusted target\");\n        trustedTarget = _newTarget;\n    }\n\n    function executeDelegatecall(bytes memory data) public onlyOwner {\n        require(trustedTarget != address(0), \"Invalid target\");\n        (bool success, ) = trustedTarget.delegatecall(data);\n        require(success, \"Delegatecall failed\");\n    }\n\n    function isTrusted(address _target) internal pure returns (bool) {\n        // Implement further checks if needed\n        return _target != address(0);\n    }\n}\n</code></pre></p> </li> </ul> <p>Fixes: - Only the contract owner can update trustedTarget. - Validation of trusted target before executing delegatecall. - Prevents arbitrary execution by restricting calls to trustedTarget.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-1"]},{"location":"SCWE/SCSVS-COMM/SCWE-042/","title":"SCWE-042: Insecure Use of External Calls","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-042/#relationships","title":"Relationships","text":"<ul> <li>CWE-829: Inclusion of Functionality from Untrusted Control Sphere CWE-829 Link</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-042/#description","title":"Description","text":"<p>Insecure use of external calls refers to vulnerabilities that arise when calling external contracts without proper validation or safeguards. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of vulnerabilities in the called contract.</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-042/#remediation","title":"Remediation","text":"<ul> <li>Validate targets: Ensure the target contract is trusted and secure.</li> <li>Use secure libraries: Leverage well-audited libraries for external calls.</li> <li>Test thoroughly: Conduct extensive testing to ensure external calls are secure.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-042/#examples","title":"Examples","text":"<ul> <li> <p>Insecure External Call <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureExternalCall {\n    function callExternal(address target, bytes memory data) public {\n        (bool success, ) = target.call(data); // No validation\n        require(success, \"Call failed\");\n    }\n}\n</code></pre></p> </li> <li> <p>Secure External Call <pre><code>pragma solidity ^0.8.0;\n\ninterface ITrustedContract {\n    function executeAction(uint256 param) external;\n}\n\ncontract SecureExternalCall {\n    address public immutable trustedTarget;\n    address public owner;\n\n    constructor(address _trustedTarget) {\n        trustedTarget = _trustedTarget;\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Unauthorized\");\n        _;\n    }\n\n    function callExternal(uint256 param) public onlyOwner {\n        ITrustedContract(trustedTarget).executeAction(param);\n    }\n}\n</code></pre> Why is this secure?</p> </li> <li>No arbitrary data input\u2014Only predefined <code>function executeAction(uint256)</code> can be called.</li> <li>Access control added\u2014Only the owner can execute external calls.</li> <li>Interface-based call\u2014Avoids raw <code>.call()</code>, reducing attack vectors.</li> <li>Immutable trusted address\u2014Prevents runtime modifications to the target contract.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/","title":"SCWE-063: Insecure Event Emission","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/#relationships","title":"Relationships","text":"<ul> <li>CWE-778: Insufficient Logging https://cwe.mitre.org/data/definitions/778.html </li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/#description","title":"Description","text":"<p>Events in Solidity play a critical role in logging contract activity and ensuring transparency. Improper event handling can lead to security risks such as:  </p> <ol> <li>Missing critical event emissions \u2013 Making external monitoring difficult.  </li> <li>Emitting misleading or incorrect data \u2013 Resulting in users or external systems making incorrect assumptions.  </li> <li>Logging sensitive information \u2013 Leaking private or security-sensitive data.  </li> </ol> <p>Failure to handle events properly can affect contract auditing, debugging, and external monitoring tools, making it difficult to detect anomalies or track contract states correctly.  </p>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/#remediation","title":"Remediation","text":"<ul> <li>Emit events for all critical state changes, such as token transfers, ownership changes, or contract upgrades.  </li> <li>Ensure that the data logged in events accurately represents the actual contract state.  </li> <li>Avoid logging sensitive information such as private keys, hashes used for authentication, or confidential business logic.  </li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    mapping(address =&gt; uint) public balances;\n    event Withdraw(address indexed user, uint amount);\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        require(balances[msg.sender] &gt;= _amount, \"Insufficient funds\");\n        payable(msg.sender).transfer(_amount);\n        balances[msg.sender] -= _amount;\n\n        // Incorrect event emission: Logs the requested amount instead of the actual withdrawn amount\n        emit Withdraw(msg.sender, _amount);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/#issues-in-the-vulnerable-code","title":"Issues in the Vulnerable Code","text":"<ul> <li>The Withdraw event logs <code>_amount</code>, which is the requested <code>withdrawal</code> amount, but if the transfer fails (due to gas limits, reentrancy, or an external issue), the event still logs it as if the withdrawal happened.</li> <li>If an attacker exploits a discrepancy between event logs and actual state changes, they could mislead users, external indexers, or off-chain services.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Example {\n    mapping(address =&gt; uint) public balances;\n    event Withdraw(address indexed user, uint actualAmount);\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        require(balances[msg.sender] &gt;= _amount, \"Insufficient funds\");\n\n        uint beforeBalance = address(this).balance;\n        (bool success, ) = payable(msg.sender).call{value: _amount}(\"\");\n        uint afterBalance = address(this).balance;\n\n        require(success, \"Transfer failed\");\n\n        uint actualWithdrawn = beforeBalance - afterBalance;\n        balances[msg.sender] -= actualWithdrawn;\n\n        // Logs the correct amount actually withdrawn\n        emit Withdraw(msg.sender, actualWithdrawn);\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMM/SCWE-063/#fixes-in-the-secure-code","title":"Fixes in the Secure Code","text":"<ul> <li>Uses <code>call{value: _amount}(\"\")</code> to send funds safely and ensures success before updating the balance.</li> <li>Calculates the actual withdrawn amount <code>(beforeBalance - afterBalance)</code> to ensure accurate logging.</li> <li>Prevents false event emissions by only logging an event if the transaction succeeds.</li> </ul>","tags":["scwe","L1","SCSVS-COMM","SCSVS-COMM-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-057/","title":"SCWE-057: Write to Arbitrary Storage Location","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-057/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation https://cwe.mitre.org/data/definitions/20.html </li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-057/#description","title":"Description","text":"<p>Writing to arbitrary storage locations can occur when a contract fails to properly validate inputs before interacting with storage variables. An attacker may exploit this vulnerability to overwrite sensitive storage slots, leading to unintended contract behavior, state manipulation, or loss of funds.</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-057/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, ensure that all inputs to storage-related operations are properly validated. Avoid allowing external users to specify arbitrary storage locations. Use access control mechanisms to restrict who can modify sensitive state variables and ensure that only trusted users or contract functions can write to critical storage locations.</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-057/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract ArbitraryStorageWrite {\n    uint256 public balance;\n\n    function setStorage(uint256 storageLocation, uint256 value) public {\n        assembly {\n            sstore(storageLocation, value)  // Writing to arbitrary storage location\n        }\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-057/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract SecureStorageWrite {\n    uint256 public balance;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function setBalance(uint256 value) public onlyOwner {\n        balance = value;  // Only the owner can modify the balance\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/","title":"SCWE-083: Failure to Handle Edge Cases","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#relationships","title":"Relationships","text":"<ul> <li>CWE-754: Improper Check for Unusual or Exceptional Conditions https://cwe.mitre.org/data/definitions/754.html </li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#description","title":"Description","text":"<p>Failure to account for edge cases can result in unexpected behaviors, security vulnerabilities, and unintended contract failures. Edge cases are unusual but possible inputs or states that developers often overlook, leading to incorrect logic, reverts, or even exploits.</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#common-scenarios-include","title":"Common scenarios include:","text":"<ul> <li>Arithmetic Issues (e.g., division by zero, integer overflow/underflow, precision loss).</li> <li>Boundary Conditions (e.g., handling empty arrays, minimum/maximum values).</li> <li>State-Dependent Bugs (e.g., failing to check for uninitialized variables, invalid state transitions).</li> <li>Gas-Related Failures (e.g., unbounded loops consuming excessive gas).</li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#remediation","title":"Remediation","text":"<p>Ensure that all edge cases are properly considered and handled during the development of the contract. Utilize <code>require</code> and <code>assert</code> to ensure proper validation of inputs, outputs, and states. - Implement explicit validation for all possible edge cases. - Use Solidity's built-in safety features (e.g., SafeMath, Solidity 0.8 overflow checks). - Use require/assert statements to enforce input constraints and expected states. - Test contracts thoroughly, including stress tests, fuzzing, and invariant testing.</p>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#vulnerable-contract-example-arithmetic-issue","title":"Vulnerable Contract Example-  (Arithmetic Issue)","text":"<pre><code>contract Example {\n    function divide(uint256 _numerator, uint256 _denominator) public pure returns (uint256) {\n        return _numerator / _denominator; // Division by zero is not checked\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#fixed-contract-example","title":"Fixed Contract Example","text":"<ul> <li>Solution: Use <code>require</code> to check for division by zero. <pre><code>contract Example {\n    function divide(uint256 _numerator, uint256 _denominator) public pure returns (uint256) {\n        require(_denominator != 0, \"Cannot divide by zero\");\n        return _numerator / _denominator;\n    }\n}\n</code></pre></li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#handling-empty-arrays","title":"Handling Empty Arrays","text":"<ul> <li>Issue: A function assumes that the array is never empty, leading to an out-of-bounds error.</li> </ul> <pre><code>contract Example {\n    uint256[] public data;\n\n    function getLast() public view returns (uint256) {\n        return data[data.length - 1]; // \u274c Reverts if array is empty\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-COMP/SCWE-083/#fixed-code","title":"Fixed Code:","text":"<ul> <li>Solution: Validate that the array is not empty before accessing elements. <pre><code>contract Example {\n    uint256[] public data;\n\n    function getLast() public view returns (uint256) {\n        require(data.length &gt; 0, \"Array is empty\");\n        return data[data.length - 1];\n    }\n}\n</code></pre></li> </ul>","tags":["scwe","L1","SCSVS-COMP","SCSVS-COMP-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-025/","title":"SCWE-025: Improper Cryptographic Key Management","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-025/#relationships","title":"Relationships","text":"<ul> <li>CWE-310: Cryptographic Issues CWE-310 Link</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-025/#description","title":"Description","text":"<p>Improper cryptographic key management refers to the failure to securely generate, store, or use cryptographic keys. This can lead to: - Unauthorized access to sensitive data. - Exploitation of the contract's logic. - Loss of funds or data.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-025/#remediation","title":"Remediation","text":"<ul> <li>Use secure key management: Leverage secure key management systems or libraries.</li> <li>Avoid hardcoding keys: Never hardcode cryptographic keys in the contract.</li> <li>Regularly rotate keys: Periodically update cryptographic keys to reduce risks.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-025/#examples","title":"Examples","text":"<ul> <li> <p>Improper Key Management <pre><code>pragma solidity ^0.8.0;\n\ncontract ImproperKeyManagement {\n    bytes32 private key = keccak256(\"insecure-key\"); // Hardcoded key\n}\n</code></pre></p> </li> <li> <p>Proper Key Management <pre><code>pragma solidity ^0.8.0;\n\ncontract ProperKeyManagement {\n    bytes32 private key;\n\n    constructor(bytes32 _key) {\n        key = _key; // Configurable key\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-026/","title":"SCWE-026: Insufficient Hash Verification","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-026/#relationships","title":"Relationships","text":"<ul> <li>CWE-347: Improper Verification of Cryptographic Signature CWE-347 Link</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-026/#description","title":"Description","text":"<p>Insufficient hash verification refers to the failure to properly verify hashes, such as message hashes or transaction hashes. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of the contract's logic.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-026/#remediation","title":"Remediation","text":"<ul> <li>Validate hashes: Ensure all hashes are properly verified before processing.</li> <li>Use secure libraries: Leverage well-audited libraries for hash verification.</li> <li>Test thoroughly: Conduct extensive testing to ensure hash verification works as intended.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-026/#examples","title":"Examples","text":"<ul> <li> <p>Insufficient Hash Verification <pre><code>pragma solidity ^0.8.0;\n\ncontract InsufficientHashVerification {\n    function processHash(bytes32 hash) public {\n        // Process hash without verification\n    }\n}\n</code></pre></p> </li> <li> <p>Sufficient Hash Verification <pre><code>pragma solidity ^0.8.0;\n\ncontract SufficientHashVerification {\n    function processHash(bytes32 hash, bytes memory data) public {\n        require(keccak256(data) == hash, \"Invalid hash\");\n        // Process hash\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-027/","title":"SCWE-027: Vulnerable Cryptographic Algorithms","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-027/#relationships","title":"Relationships","text":"<ul> <li>CWE-327: Use of a Broken or Risky Cryptographic Algorithm CWE-327 Link</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-027/#description","title":"Description","text":"<p>Vulnerable cryptographic algorithms refer to the use of outdated or insecure cryptographic algorithms, such as MD5 or SHA-1. This can lead to: - Exploitation of the contract\u2019s logic. - Loss of funds or data. - Reduced trust in the contract\u2019s security.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-027/#remediation","title":"Remediation","text":"<ul> <li>Use secure algorithms: Leverage modern cryptographic algorithms like SHA-256 or Keccak-256.</li> <li>Avoid deprecated algorithms: Do not use algorithms known to be insecure.</li> <li>Test thoroughly: Conduct extensive testing to ensure cryptographic security.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-027/#examples","title":"Examples","text":"<ul> <li> <p>Vulnerable Algorithm <pre><code>pragma solidity ^0.8.0;\n\ncontract VulnerableAlgorithm {\n    function hashData(bytes memory data) public pure returns (bytes32) {\n        return sha256(data); // Insecure algorithm\n    }\n}\n</code></pre></p> </li> <li> <p>Secure Algorithm <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureAlgorithm {\n    function hashData(bytes memory data) public pure returns (bytes32) {\n        return keccak256(data); // Secure algorithm\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-054/","title":"SCWE-054: Signature Malleability","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-054/#relationships","title":"Relationships","text":"<ul> <li>CWE-345: Insufficient Verification of Data Authenticity https://cwe.mitre.org/data/definitions/345.html </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-054/#description","title":"Description","text":"<p>Signature malleability refers to the ability to modify a valid signature without changing its validity. This can occur when signatures are not properly verified or when certain components of a signature (like the <code>v</code>, <code>r</code>, and <code>s</code> values) can be altered while still producing a valid signature.</p> <p>Attackers can modify a signature\u2019s <code>s</code> value or flip <code>v</code> between 27 and 28, generating different valid signatures for the same message. This can lead to:</p> <ul> <li>Replay attacks, where transactions can be re-executed with modified signatures.</li> <li>Transaction hijacking, where a valid signature is altered to redirect funds or manipulate contract state.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-054/#remediation","title":"Remediation","text":"<p>To mitigate signature malleability, ensure that the signature verification process is robust. Use secure cryptographic libraries that properly handle signature validation, such as ECDSA or EdDSA with additional checks to prevent malleability. When verifying signatures, consider using a canonical format for signature components to avoid malleability.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-054/#vulnerable-contract-example-allows-signature-malleability","title":"Vulnerable Contract Example- (Allows Signature Malleability)","text":"<p><pre><code>contract MalleableSignatureExample {\n    function verifySignature(bytes32 message, uint8 v, bytes32 r, bytes32 s) public pure returns (bool) {\n        address signer = ecrecover(message, v, r, s);  // Signature malleability risk\n        return signer != address(0);\n    }\n}\n</code></pre> - This contract does not restrict <code>s</code> values, allowing malleable signatures. - Issue: The contract does not check if <code>s</code> is in the lower half of the <code>curve (s &lt; secp256k1n/2)</code>, allowing multiple valid signatures for the same message.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-054/#fixed-contract-example-prevents-signature-malleability","title":"Fixed Contract Example- Prevents Signature Malleability)","text":"<pre><code>  pragma solidity ^0.8.0;\n\n  import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n  contract SecureSignatureExample {\n      using ECDSA for bytes32;\n\n      function verifySignature(bytes32 message, bytes memory signature) public pure returns (address) {\n          return message.toEthSignedMessageHash().recover(signature);\n      }\n  }\n</code></pre> <ul> <li>Fix: Uses <code>OpenZeppelin\u2019s ECDSA library</code>, which ensures <code>s</code> is in the lower half and restricts <code>v</code> to 27 or 28.</li> <li>Outcome: Prevents attackers from modifying valid signatures to create alternate, equally valid ones.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-055/","title":"SCWE-055: Missing Protection against Signature Replay Attacks","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-055/#relationships","title":"Relationships","text":"<ul> <li>CWE-294: Authentication Bypass by Capture-replay https://cwe.mitre.org/data/definitions/294.html </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-055/#description","title":"Description","text":"<p>Signature replay attacks occur when a valid signature from a previous transaction is reused in a different context, such as a different transaction or contract call. Without proper protection, an attacker can capture and replay a signature, potentially bypassing authentication checks and causing unauthorized actions or transactions.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-055/#remediation","title":"Remediation","text":"<p>To prevent signature replay attacks, include additional checks that ensure the signature is valid for a specific transaction or context. This can be done by incorporating unique identifiers like a nonce, timestamp, or a unique transaction hash into the signature to bind it to a specific use. Always verify that the signature is only valid for the intended action.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-055/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract ReplayAttackExample {\n    mapping(address =&gt; uint256) public nonces;\n\n    function authenticate(bytes32 message, uint8 v, bytes32 r, bytes32 s) public {\n        address signer = ecrecover(message, v, r, s);\n        require(signer == msg.sender, \"Invalid signature\");\n        // No protection against replay attacks; attacker can reuse the same signature\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-055/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>  pragma solidity ^0.8.0;\n\n  import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n  contract SecureReplayProtectionExample {\n      using ECDSA for bytes32;\n\n      mapping(address =&gt; uint256) public nonces;\n\n      function authenticate(bytes32 message, bytes memory signature) public {\n          uint256 nonce = nonces[msg.sender]++;\n          bytes32 messageWithContext = keccak256(abi.encodePacked(message, nonce, block.chainid));  \n          address signer = messageWithContext.toEthSignedMessageHash().recover(signature);\n          require(signer == msg.sender, \"Invalid signature\");\n      }\n  }\n</code></pre> Fixes Implemented: -  Binds signature to a nonce (ensuring it's only usable once). -  Includes <code>chainId</code> (prevents cross-chain replay attacks). - Uses OpenZeppelin\u2019s ECDSA library (avoids signature malleability risks).</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-056/","title":"SCWE-056: Lack of Proper Signature Verification","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-056/#relationships","title":"Relationships","text":"<ul> <li>CWE-345: Insufficient Verification of Data Authenticity https://cwe.mitre.org/data/definitions/345.html </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-056/#description","title":"Description","text":"<p>This vulnerability occurs when a smart contract fails to properly verify whether a signature was produced by an authorized entity. In Ethereum, contracts often use <code>ecrecover</code> to check signatures, but failing to validate who signed the message allows:</p> <ul> <li>Unauthorized transactions, where attackers submit signatures from any key.</li> <li>Replay attacks, where valid signatures are reused to repeat actions.</li> <li>Malicious contract state manipulation, where attackers gain unauthorized access.</li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-056/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, always implement proper signature verification using secure cryptographic methods. Use the <code>ecrecover</code> function to recover the signer\u2019s address and ensure that the recovered address matches the expected address. Additionally, verify that the signature is valid for the intended message or transaction and that the signer is authorized to perform the action.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-056/#vulnerable-contract-example-lack-of-signer-verification","title":"Vulnerable Contract Example- (Lack of Signer Verification)","text":"<p><pre><code>contract SignatureVerificationExample {\n    function authenticate(bytes32 message, uint8 v, bytes32 r, bytes32 s) public view returns (address) {\n        address signer = ecrecover(message, v, r, s);\n        return signer;  // No further validation of the signer or message\n    }\n}\n</code></pre> - Issue: The contract does not check if the recovered address matches an authorized signer. - Exploit: Any valid ECDSA signature can be used, even from an attacker\u2019s key.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-056/#fixed-contract-example-proper-signature-verification","title":"Fixed Contract Example- (Proper Signature Verification)","text":"<p><pre><code>    pragma solidity ^0.8.0;\n\n    import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n    contract SecureSignatureVerificationExample {\n        using ECDSA for bytes32;\n\n        address public authorizedSigner;\n\n        constructor(address _authorizedSigner) {\n            require(_authorizedSigner != address(0), \"Invalid signer\");\n            authorizedSigner = _authorizedSigner;\n        }\n\n        function authenticate(bytes32 message, bytes memory signature) public view returns (bool) {\n            address signer = message.toEthSignedMessageHash().recover(signature);\n            require(signer == authorizedSigner, \"Unauthorized signer\"); // Proper validation\n            return true;\n        }\n    }\n</code></pre> - Fix: The contract now explicitly checks that the recovered address matches <code>authorizedSigner</code>. - Outcome: Prevents attackers from submitting arbitrary signatures and ensures only authorized signatures are accepted.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-1"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-074/","title":"SCWE-074: Hash Collisions with Multiple Variable Length Arguments","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-074/#relationships","title":"Relationships","text":"<ul> <li>CWE-347: Improper Verification of Cryptographic Signature https://cwe.mitre.org/data/definitions/347.html </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-074/#description","title":"Description","text":"<p>When hashing multiple variable-length arguments, there is a potential risk of hash collisions, which can occur if two different sets of inputs produce the same hash output. This vulnerability is particularly relevant in situations where hashes are used as identifiers, signatures, or keys, and collisions may lead to incorrect behavior or security breaches, such as false validation of signatures or unexpected contract logic execution.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-074/#remediation","title":"Remediation","text":"<p>To prevent hash collisions, use a strong cryptographic hashing function like <code>keccak256</code> or <code>sha256</code>, and ensure that the inputs to the hash function are well-structured. Consider combining different sources of entropy (e.g., timestamps, nonces) and always verify the integrity of the data before trusting a hash.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-074/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    function verifyData(bytes memory data1, bytes memory data2) public pure returns (bytes32) {\n        // Vulnerable to hash collisions with multiple variable-length arguments\n        return keccak256(abi.encodePacked(data1, data2));  // Possible collision risk\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-074/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Example {\n    function verifyData(bytes memory data1, bytes memory data2) public pure returns (bytes32) {\n        // Safe way to hash multiple variable-length arguments\n        return keccak256(abi.encode(data1, data2));  // More secure handling of variable-length inputs\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-084/","title":"SCWE-084: Insecure Use of blockhash","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-084/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation https://cwe.mitre.org/data/definitions/20.html </li> </ul>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-084/#description","title":"Description","text":"<p>The <code>blockhash</code> function is often misused to generate randomness in smart contracts. However, <code>blockhash</code> is publicly available and can be influenced by miners, making it an unreliable and insecure source of randomness.</p> <p>Attackers can manipulate <code>blockhash</code> by controlling which transactions are included in a block, reordering transactions, or discarding unfavorable blocks. This can lead to predictable random outcomes, allowing malicious actors to exploit lotteries, gaming, and other randomness-dependent mechanisms.</p> <p>Attack Scenarios - Lottery Manipulation: A miner can withhold or reorder transactions to ensure a favorable <code>blockhash</code> that lets them win. - Game Exploitation: If a game outcome depends on <code>blockhash</code>, an attacker can predict future results and place bets accordingly.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-084/#remediation","title":"Remediation","text":"<p>Do not rely on <code>blockhash</code> for generating randomness. Use more secure and unpredictable sources of randomness, such as using Chainlink VRF or other trusted oracles.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-084/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<p><pre><code>// Vulnerable contract using blockhash for randomness\npragma solidity ^0.8.0;\n\ncontract InsecureRandomness {\n    function getRandomNumber(uint256 _blockNumber) public view returns (uint256) {\n        return uint256(blockhash(_blockNumber)); // Predictable randomness\n    }\n}\n</code></pre> Why is this insecure? - Miners control block production - They can reorder or discard blocks to manipulate <code>blockhash</code>. - Predictability - Attackers can call this function for past block numbers, making randomness guessable.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-CRYPTO/SCWE-084/#fixed-contract-example-secure-random-number-generation-using-chainlink-vrf","title":"Fixed Contract Example- Secure Random Number Generation Using Chainlink VRF","text":"<pre><code>pragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\n\ncontract SecureLottery is VRFConsumerBase {\n    address[] public players;\n    bytes32 internal keyHash;\n    uint256 internal fee;\n    uint256 public randomResult;\n\n    constructor()\n        VRFConsumerBase(\n            0x514910771AF9Ca656af840dff83E8264EcF986CA, // Chainlink VRF Coordinator\n            0x514910771AF9Ca656af840dff83E8264EcF986CA // LINK Token address\n        )\n    {\n        keyHash = 0x6c3699283bda56ad74f6b855546325b68d482e983852a617d11109b44b8aab01; \n        fee = 0.1 * 10**18; // 0.1 LINK (varies by network)\n    }\n\n    function enter() public payable {\n        require(msg.value &gt; 0.1 ether, \"Minimum ETH required\");\n        players.push(msg.sender);\n    }\n\n    function requestRandomWinner() public returns (bytes32 requestId) {\n        require(players.length &gt; 0, \"No players joined\");\n        require(LINK.balanceOf(address(this)) &gt;= fee, \"Not enough LINK\");\n        return requestRandomness(keyHash, fee);\n    }\n\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n        uint256 index = randomness % players.length;\n        payable(players[index]).transfer(address(this).balance);\n    }\n}\n</code></pre> <p>Why is this secure? - Uses <code>Chainlink VRF</code> (Verifiable Random Function), which provides unpredictable, tamper-proof randomness. - Miners cannot manipulate the randomness as it is derived from a verifiable external source. - Players cannot predict the outcome before participating.</p>","tags":["scwe","L1","SCSVS-CRYPTO","SCSVS-CRYPTO-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-036/","title":"SCWE-036: Inadequate Gas Limit Handling","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-036/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption CWE-400 Link</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-036/#description","title":"Description","text":"<p>Inadequate gas limit handling occurs when a contract fails to manage gas constraints efficiently, leading to performance bottlenecks and denial-of-service (DoS) risks. Poor gas handling can result in: - Unoptimized execution: Unnecessary gas-heavy computations increasing costs. - DoS vulnerabilities: Transactions failing due to excessive gas usage, blocking operations. - Inefficient batch processing: Overloaded loops or storage updates causing out-of-gas (OOG) errors.</p> <p>Unlike SCWE-032, which focuses on the protocol-level block gas limit, this issue arises due to poor gas management at the smart contract level.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-036/#remediation","title":"Remediation","text":"<ul> <li>Optimize gas usage: Minimize gas consumption in contract operations.</li> <li>Avoid unbounded loops: Ensure loops have a fixed upper limit.</li> <li>Test thoroughly: Conduct extensive testing to ensure operations stay within gas limits.</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-036/#examples","title":"Examples","text":"<ul> <li>Inadequate Gas Handling <pre><code>pragma solidity ^0.8.0;\n\ncontract InefficientProcessing {\n    mapping(address =&gt; uint) public balances;\n\n    function batchTransfer(address[] memory recipients, uint amount) public {\n        for (uint i = 0; i &lt; recipients.length; i++) {\n            balances[recipients[i]] += amount; // Gas-intensive operation\n        }\n    }\n}\n</code></pre></li> </ul> <p>Issue: Processes large arrays in a single transaction, which can fail due to out-of-gas errors.</p> <p>Why is this a problem? - If recipients.length is too large, the transaction fails. - Attackers can exploit this by submitting large recipient lists, causing a DoS attack.</p> <ul> <li>Adequate Gas Handling <pre><code>pragma solidity ^0.8.0;\n\ncontract GasOptimizedProcessing {\n    mapping(address =&gt; uint) public balances;\n\n    function batchTransfer(address[] memory recipients, uint amount) public {\n        uint i = 0;\n        while (i &lt; recipients.length &amp;&amp; gasleft() &gt; 50000) { // Stop before out of gas\n            balances[recipients[i]] += amount;\n            i++;\n        }\n    }\n}\n</code></pre> \u2714\ufe0f Fix: Uses gasleft() to gracefully exit before running out of gas, ensuring some transfers complete. Why is this better? \u2705 Prevents complete transaction failure by handling only as many iterations as gas allows. \u2705 Reduces DoS risk by allowing partial execution instead of reverting everything. \u2705 Enables retrying to complete all operations over multiple calls.</li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-058/","title":"SCWE-058: DoS with Block Gas Limit","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-058/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html </li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-058/#description","title":"Description","text":"<p>Denial of Service (DoS) with block gas limit occurs when a contract is designed in such a way that its execution depends on a large amount of gas, potentially exceeding the block gas limit. This can result in the transaction failing, causing the contract to become unavailable or unusable. Attackers can exploit this vulnerability by creating transactions that consume excessive gas, effectively locking the contract or preventing normal operation.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-058/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, ensure that operations that depend on gas consumption are efficient and that gas limits are taken into account when designing contract logic. Avoid functions that require large amounts of gas to complete, and consider implementing features like batching or chunking operations to spread the gas usage across multiple transactions.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-058/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract GasLimitDoS {\n    uint256[] public data;\n\n    function addData(uint256[] memory newData) public {\n        for (uint256 i = 0; i &lt; newData.length; i++) {\n            data.push(newData[i]);  // Can consume a large amount of gas if the array is large\n        }\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-058/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract GasLimitSafe {\n    uint256[] public data;\n\n    function addData(uint256[] memory newData) public {\n        uint256 batchSize = 100;  // Limit the batch size to avoid excessive gas usage\n        for (uint256 i = 0; i &lt; newData.length &amp;&amp; i &lt; batchSize; i++) {\n            data.push(newData[i]);\n        }\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-059/","title":"SCWE-059: Insufficient Gas Griefing","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-059/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html </li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-059/#description","title":"Description","text":"<p>Insufficient gas griefing occurs when an attacker intentionally sends a transaction with insufficient gas to force the contract to fail. This can lead to resource consumption issues and potential denial of service for the contract or other users. If a contract relies on external calls or interacts with other contracts and does not properly handle gas estimation, it may be vulnerable to such attacks.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-059/#remediation","title":"Remediation","text":"<p>To mitigate this vulnerability, ensure that gas estimation and proper gas limits are handled when performing contract calls, especially when interacting with other contracts. Additionally, use mechanisms to handle failures gracefully, such as revert messages and checks for sufficient gas before initiating important operations.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-059/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract GasGriefing {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferFunds(address payable recipient, uint256 amount) public {\n        require(msg.sender == owner, \"Not the owner\");\n        recipient.transfer(amount);  // Potential for griefing with insufficient gas\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-059/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract GasGriefingSafe {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transferFunds(address payable recipient, uint256 amount) public {\n        require(msg.sender == owner, \"Not the owner\");\n        bool success = recipient.send(amount);  // Safe transfer with gas estimation\n        require(success, \"Transfer failed due to insufficient gas\");\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-077/","title":"SCWE-077: Lack of Rate Limiting","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-077/#relationships","title":"Relationships","text":"<ul> <li>CWE-770: Allocation of Resources Without Limits or Throttling https://cwe.mitre.org/data/definitions/770.html </li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-077/#description","title":"Description","text":"<p>Lack of rate limiting in a smart contract can lead to Denial of Service (DoS) attacks, excessive gas consumption, or contract state bloating. Without a mechanism to restrict the frequency of function calls, an attacker can flood the contract with transactions, causing delays, increased gas fees, or complete unavailability of critical functions.  </p> <p>This vulnerability is particularly dangerous in DeFi protocols, where unlimited function calls could drain funds, abuse governance mechanisms, or overload on-chain processing.  </p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-077/#remediation","title":"Remediation","text":"<ul> <li>Implement rate-limiting mechanisms such as time-based constraints (e.g., requiring a cooldown period between calls).  </li> <li>Use counters with expiration timestamps to track and restrict repetitive actions.  </li> <li>Introduce gas fees or staking requirements to deter spam transactions.  </li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-077/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    mapping(address =&gt; uint) public userRequests;\n\n    // \u274c No rate limiting: users can spam this function indefinitely\n    function request() public {\n        userRequests[msg.sender]++;\n        // No restrictions or cooldowns, allowing abuse\n    }\n}\n</code></pre> <p>Why is this vulnerable? - No restrictions on how frequently a user can call <code>request()</code>. - An attacker can spam transactions, leading to high gas costs and DoS. - Storage bloat from excessive <code>userRequests</code> mappings.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-077/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>contract SecureExample {\n    struct RequestData {\n        uint count;\n        uint lastReset;\n    }\n\n    mapping(address =&gt; RequestData) public userRequests;\n    uint public constant REQUEST_LIMIT = 5;\n    uint public constant TIME_WINDOW = 1 hours;\n\n    // \u2705 Implement rate limiting with a cooldown period\n    function request() public {\n        RequestData storage requestData = userRequests[msg.sender];\n\n        if (block.timestamp &gt; requestData.lastReset + TIME_WINDOW) {\n            requestData.count = 0;  // Reset count after time window\n            requestData.lastReset = block.timestamp;\n        }\n\n        require(requestData.count &lt; REQUEST_LIMIT, \"Rate limit exceeded\");\n        requestData.count++;\n    }\n}\n</code></pre> Why is this safe? - Tracks request timestamps, resetting counts after a fixed period. - Restricts excessive calls, preventing abuse and DoS attacks. - Efficient state management, reducing unnecessary storage costs.</p> <p>By enforcing rate limits, contracts can prevent spam attacks and ensure fair access to on-chain resources.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-2"]},{"location":"SCWE/SCSVS-DEFI/SCWE-082/","title":"SCWE-082: Lack of Proper Gas Management","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-082/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html </li> </ul>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-082/#description","title":"Description","text":"<p>Gas management is crucial in smart contracts to ensure that they do not run out of gas or cause excessive consumption. If gas consumption is not properly controlled, a contract can fail to execute or can be exploited by attackers to cause denial of service (DoS).</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-082/#remediation","title":"Remediation","text":"<p>Properly estimate the gas required for functions and set appropriate gas limits. Use <code>require</code> or other mechanisms to handle gas consumption failures and ensure that gas usage remains within acceptable bounds.</p>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-082/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    function execute() public {\n        while (true) { \n            // Excessive gas consumption, no limit set\n        }\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-DEFI/SCWE-082/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Example {\n    uint public counter;\n\n    function execute(uint _iterations) public {\n        require(_iterations &lt;= 100, \"Too many iterations\"); // Limit iterations to avoid excessive gas usage\n        for (uint i = 0; i &lt; _iterations; i++) {\n            counter++;\n        }\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-DEFI","SCSVS-DEFI-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-012/","title":"SCWE-012: Lack of Multisig Governance","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-012/#relationships","title":"Relationships","text":"<ul> <li>CWE-285: Improper Authorization https://cwe.mitre.org/data/definitions/285.html</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-012/#description","title":"Description","text":"<p>Lack of multisig governance occurs when critical smart contract functions, such as upgrades, fund withdrawals, or parameter changes, are controlled by a single entity. This creates a single point of failure, increasing the risk of compromise, insider abuse, or unauthorized access. Without multisig governance, attackers or malicious actors can easily exploit privileged functions if the private key of a single administrator is compromised.</p> <p>Key risks associated with missing multisig governance: - Centralization Risk: A single entity can control and modify key contract parameters. - Single Point of Failure: Loss or compromise of the owner's private key can result in catastrophic consequences. - Unauthorized Access: An attacker gaining control of the private key can execute privileged functions without approval. - Lack of Accountability: Decisions are made unilaterally, reducing transparency and security.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-012/#remediation","title":"Remediation","text":"<ul> <li>Implement a Multisig Wallet: Use multisignature schemes (e.g., Gnosis Safe) to require multiple signers for critical transactions.</li> <li>Role-Based Access Control (RBAC): Assign multiple roles with different privileges to prevent centralized control.</li> <li>Timelocks for Critical Functions: Introduce a delay for privileged actions, allowing time for community intervention if needed.</li> <li>On-Chain Governance Mechanisms: Decentralize decision-making using DAO-based governance where applicable.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-012/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-012/#example-of-a-contract-without-multisig-governance-centralized-owner","title":"Example of a Contract Without Multisig Governance (Centralized Owner)","text":"<pre><code>pragma solidity ^0.8.0;\n\ncontract CentralizedGovernance {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function upgradeContract(address newContract) public {\n        require(msg.sender == owner, \"Only owner can upgrade\");\n        // \u274c Only a single owner can perform critical actions\n    }\n\n    function withdrawFunds(address payable recipient, uint256 amount) public {\n        require(msg.sender == owner, \"Only owner can withdraw funds\");\n        recipient.transfer(amount); // \u274c No multisig verification\n    }\n}\n</code></pre> <ul> <li>In this example, all governance actions depend on a single owner, making it a high-risk design.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-012/#refactored-to-use-multisig-governance","title":"Refactored to Use Multisig Governance","text":"<pre><code>pragma solidity ^0.8.0;\n\ninterface IMultiSig {\n    function submitTransaction(address destination, uint256 value, bytes calldata data) external;\n}\n\ncontract SecureGovernance {\n    IMultiSig public multisigWallet;\n\n    constructor(address _multisigWallet) {\n        multisigWallet = IMultiSig(_multisigWallet);\n    }\n\n    function upgradeContract(address newContract) public {\n        bytes memory data = abi.encodeWithSignature(\"upgradeTo(address)\", newContract);\n        multisigWallet.submitTransaction(address(this), 0, data); // \u2705 Requires multisig approval\n    }\n\n    function withdrawFunds(address payable recipient, uint256 amount) public {\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", recipient, amount);\n        multisigWallet.submitTransaction(address(this), 0, data); // \u2705 Multisig verification for withdrawals\n    }\n}\n</code></pre> <ul> <li>This improved version delegates authority to a multisig wallet, requiring multiple approvals before executing critical actions.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/","title":"SCWE-015: Poor Governance Documentation","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#relationships","title":"Relationships","text":"<ul> <li> <p>CWE-933: Security Misconfiguration https://cwe.mitre.org/data/definitions/933.html</p> </li> <li> <p>CWE-1118: Insufficient Documentation of Error Handling Techniques     https://cwe.mitre.org/data/definitions/1118.html</p> </li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#description","title":"Description","text":"<p>Poor governance documentation refers to the lack of clear, transparent, and publicly accessible records regarding a smart contract system\u2019s decision-making processes, upgrade mechanisms, and role-based permissions. Without proper documentation, users, developers, and auditors struggle to understand the governance model, leading to reduced trust, misconfigurations, and potential security vulnerabilities.</p> <p>Key risks associated with poor governance documentation: - Unclear Decision-Making Process: Users may not understand how governance proposals are initiated, approved, or executed. - Hidden Centralization Risks: Critical governance powers may be concentrated in a small group without public awareness. - Lack of Upgradeability Transparency: If upgrade procedures are not well-documented, malicious or unintended changes may go unnoticed. - Poor Incident Response Handling: Without clear emergency protocols, governance failures can lead to slow or inadequate responses to attacks.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#remediation","title":"Remediation","text":"<ul> <li>Comprehensive Governance Documentation: Clearly outline roles, permissions, voting mechanisms, and upgradeability in technical and non-technical formats.</li> <li>Public Governance Reports: Regularly publish governance decisions, major votes, and protocol updates in a transparent manner.</li> <li>Well-Defined Emergency Procedures: Establish and document response plans for governance failures, protocol attacks, or keyholder compromises.</li> <li>On-Chain Governance Visibility: Ensure that governance smart contracts expose relevant functions for transparency and accountability.</li> <li>Third-Party Audits of Governance Mechanisms: Periodically review governance documentation and processes through independent audits.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#examples","title":"Examples","text":"<p>Unlike code vulnerabilities, poor governance documentation is a process failure rather than a direct coding flaw. However, its consequences can be illustrated with real-world governance failures:</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#example-unclear-upgradeability-policy-leads-to-a-security-breach","title":"Example: Unclear Upgradeability Policy Leads to a Security Breach","text":"<p>A DeFi protocol allows smart contract upgrades but fails to document the governance process for approving upgrades. A small group of developers, holding majority control over the governance multisig, pushes an unreviewed upgrade that introduces a critical vulnerability, resulting in a protocol exploit.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#fixed-ensuring-transparent-upgradeability-policies","title":"Fixed: Ensuring Transparent Upgradeability Policies","text":"<p>Protocols should establish a clear and documented upgradeability framework outlining who can propose, review, and approve upgrades. Implementing timelocks, community review periods, and independent security audits ensures upgrades are thoroughly vetted before execution. Additionally, maintaining an on-chain governance audit log enhances accountability and prevents unauthorized changes.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#example-lack-of-transparency-in-governance-voting","title":"Example: Lack of Transparency in Governance Voting","text":"<p>A DAO implements an opaque governance process, where voting power is controlled by a few insiders without a clear framework on how votes are counted or executed. Community members later discover that critical protocol changes were pushed without public discussion, leading to governance disputes and loss of user trust.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-015/#enhancing-transparency-in-governance-voting","title":"Enhancing Transparency in Governance Voting","text":"<p>Governance processes should be transparent, well-documented, and resistant to centralization risks to maintain trust. Clearly defining voting mechanisms, proposal review procedures, and decision-making criteria prevents manipulation and governance capture. Public governance discussions, decentralized voting structures, and immutable records of voting outcomes further enhance credibility and community trust.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-037/","title":"SCWE-037: Insufficient Protection Against Front-Running","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-037/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-037/#description","title":"Description","text":"<p>Insufficient protection against front-running refers to vulnerabilities that allow malicious actors to exploit the order of transactions for profit. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of the contract\u2019s logic.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-037/#remediation","title":"Remediation","text":"<ul> <li>Use commit-reveal schemes: Implement commit-reveal mechanisms to hide transaction details until they are finalized.</li> <li>Add delays: Introduce time delays for critical operations to reduce the risk of front-running.</li> <li>Test thoroughly: Conduct extensive testing to ensure front-running protection is effective.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-037/#examples","title":"Examples","text":"<ul> <li>Vulnerable to Front-Running <pre><code>pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract FrontRunningVulnerable {\n    IERC20 public token;\n    uint256 public price = 1 ether; // 1 token = 1 ETH\n\n    constructor(address _token) {\n        token = IERC20(_token);\n    }\n\n    function buyTokens(uint256 amount) public payable {\n        require(msg.value &gt;= amount * price, \"Insufficient ETH\");\n        token.transferFrom(address(this), msg.sender, amount);\n    }\n}\n</code></pre> Why is this vulnerable?</li> <li>Attackers see the transaction in the mempool and execute a transaction to buy first, raising the price.</li> <li>Victim's transaction executes at a higher price or fails due to slippage.</li> <li> <p>Attacker sells at a profit, exploiting sandwich attacks.</p> </li> <li> <p>Protected Against Front-Running-  Commit-Reveal to Hide Trade Intent <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureTrade {\n    mapping(address =&gt; bytes32) public commitments;\n    uint256 public price = 1 ether; // 1 token = 1 ETH\n\n    function commitTrade(bytes32 hash) public {\n        commitments[msg.sender] = hash;\n    }\n\n    function executeTrade(uint256 amount, bytes32 secret) public payable {\n        require(commitments[msg.sender] == keccak256(abi.encodePacked(amount, secret)), \"Invalid commitment\");\n        require(msg.value &gt;= amount * price, \"Insufficient ETH\");\n\n        commitments[msg.sender] = 0; // Prevent reusing commitment\n        // Execute trade after revealing the commitment\n    }\n}\n</code></pre> Why is this better?</p> </li> <li>Traders commit to the trade off-chain before revealing the amount, preventing mempool sniping.</li> <li>Transactions cannot be front-run because attackers don\u2019t know the amount until revealed.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/","title":"SCWE-043: Insecure Use of Fallback Functions","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/#relationships","title":"Relationships","text":"<ul> <li>CWE-250: Execution with Unnecessary Privileges CWE-250 Link</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/#description","title":"Description","text":"<p>Insecure use of fallback functions refers to vulnerabilities that arise when fallback functions are used improperly. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data due to unintended execution. - Exploitation of contract logic if the fallback function allows arbitrary interactions.</p> <p>Fallback functions are triggered when a contract receives a call with no matching function signature. They can be used to handle Ether transfers or proxy unknown function calls. If misconfigured, they may enable unintended behaviors, such as unauthorized access or fund loss.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/#remediation","title":"Remediation","text":"<ul> <li>Restrict logic execution in fallback functions: Avoid placing critical execution logic inside fallback functions unless necessary.  </li> <li>Separate Ether reception: Use <code>receive()</code> explicitly to handle Ether transfers instead of overloading <code>fallback()</code>.  </li> <li>Validate calls: Ensure fallback functions do not execute unintended behavior. If required, use access control for specific use cases (e.g., controlled proxy calls).  </li> <li>Use explicit function definitions: Instead of relying on fallback functions for critical operations, define explicit functions with proper access control.  </li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/#examples","title":"Examples","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/#insecure-fallback-function","title":"\ud83d\udea8 Insecure Fallback Function","text":"","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/#problem-no-access-control-or-validation-allowing-unintended-execution","title":"Problem: No access control or validation, allowing unintended execution.","text":"<p><pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureFallback {\n    fallback() external {\n        // No access control or validation\n    }\n}\n</code></pre> - This contract allows any call with an unknown function signature to trigger the fallback function, which could result in unintended behavior.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-043/#secure-fallback-function-safe-handling-of-ether","title":"Secure Fallback Function (Safe Handling of Ether)","text":"<ul> <li>Solution: Explicitly handle Ether transfers using receive()</li> </ul> <p><pre><code>pragma solidity ^0.8.0;\n\ncontract SecureFallback {\n    address public admin;\n\n    constructor(address _admin) {\n        admin = _admin;\n    }\n\n    // Explicitly define a receive function to safely accept Ether\n    receive() external payable {}\n\n    // Safe fallback function (does nothing if unintentionally called)\n    fallback() external payable {\n        // Optional: Log unexpected calls for security monitoring\n    }\n}\n</code></pre> This version properly separates Ether reception from fallback execution, preventing unintended behavior.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-044/","title":"SCWE-044: Insecure Use of Storage","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-044/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-044/#description","title":"Description","text":"<p>Insecure use of storage refers to vulnerabilities that arise when storage variables are improperly managed. This can lead to: - Unauthorized access to sensitive data. - Loss of funds or data. - Exploitation of vulnerabilities in contract logic.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-044/#remediation","title":"Remediation","text":"<ul> <li>Encrypt sensitive data: Encrypt sensitive data before storing it.</li> <li>Validate inputs: Ensure all storage updates are properly validated.</li> <li>Test thoroughly: Conduct extensive testing to ensure storage is secure.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-044/#examples","title":"Examples","text":"<ul> <li> <p>Insecure Storage Usage <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureStorage {\n    uint public balance;\n\n    function updateBalance(uint newBalance) public {\n        balance = newBalance; // No validation\n    }\n}\n</code></pre></p> </li> <li> <p>Secure Storage Usage <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureStorage {\n    uint public balance;\n\n    function updateBalance(uint newBalance) public {\n        require(newBalance &gt; 0, \"Invalid balance\"); // Input validation\n        balance = newBalance;\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-1"]},{"location":"SCWE/SCSVS-GOV/SCWE-075/","title":"SCWE-075: Incorrect Ether Balance Tracking","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-075/#relationships","title":"Relationships","text":"<ul> <li>CWE-852: Untrusted Control Sphere https://cwe.mitre.org/data/definitions/852.html </li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-075/#description","title":"Description","text":"<p>Incorrect Ether balance tracking occurs when a contract manually maintains an internal balance variable instead of relying on <code>address(this).balance</code>. This creates inconsistencies when Ether is received outside of expected functions (e.g., via <code>selfdestruct()</code>, <code>transfer()</code>, or direct deposits).  </p> <p>Attackers can exploit this by artificially inflating the contract's perceived balance, leading to unauthorized withdrawals or failed transactions. This issue is common in poorly designed deposit/withdraw systems that do not properly verify the actual contract balance.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-075/#attack-scenario","title":"Attack Scenario","text":"<p>An attacker sends Ether to the contract using <code>selfdestruct()</code>, increasing its actual balance without updating the internal tracking variable. Later, a user tries to withdraw funds, but the contract incorrectly assumes it has more Ether than it actually does, causing unexpected failures or exploits.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-075/#remediation","title":"Remediation","text":"<ul> <li>Use <code>address(this).balance</code> instead of manually tracking Ether balance.</li> <li>Prevent external Ether deposits by disabling the fallback function unless explicitly needed.</li> <li>Ensure proper accounting by always reconciling balances before allowing withdrawals.</li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-075/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<p><pre><code>// \u274c Vulnerable to incorrect balance tracking due to external Ether deposits\ncontract IncorrectBalanceTracking {\n    uint public balance;  // \u274c Manually tracking Ether balance\n\n    function deposit() public payable {\n        balance += msg.value;\n    }\n\n    function withdraw(uint _amount) public {\n        require(balance &gt;= _amount, \"Insufficient funds\");\n        payable(msg.sender).transfer(_amount);\n        balance -= _amount;\n    }\n}\n</code></pre> Why is this vulnerable? - The contract does not account for direct Ether transfers outside deposit(). - An attacker can send Ether via <code>selfdestruct()</code>, inflating the contract balance without updating balance. - This can lead to withdrawals being blocked or excessive withdrawals.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-075/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>// \u2705 Secure implementation that tracks actual balance correctly\ncontract CorrectBalanceTracking {\n    function deposit() public payable {}\n\n    function withdraw(uint _amount) public {\n        require(address(this).balance &gt;= _amount, \"Insufficient funds\");  // \u2705 Correct balance check\n        payable(msg.sender).transfer(_amount);\n    }\n\n    // Optional: Prevent direct Ether transfers\n    receive() external payable {\n        revert(\"Direct deposits not allowed\");\n    }\n}\n</code></pre> Why is this secure? - Uses <code>address(this).balnce</code> for accurate balance tracking. - Prevents external deposits unless explicitly intended. - No manual <code>balance</code> variable, reducing risk of inconsistencies.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-078/","title":"SCWE-078: Improper Handling of Ether Transfers","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-078/#relationships","title":"Relationships","text":"<ul> <li>CWE-703: Improper Check or Handling of Exceptional Conditions https://cwe.mitre.org/data/definitions/703.html </li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-078/#description","title":"Description","text":"<p>Improper handling of Ether transfers in Solidity can lead to unexpected behaviors, such as failed transactions or loss of funds. For instance, when using <code>transfer()</code> or <code>send()</code>, failure to check for successful execution or not handling exceptions correctly can cause Ether to be locked or lost in the contract.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-078/#remediation","title":"Remediation","text":"<p>Always handle exceptions properly when transferring Ether. Ensure that you check for success or failure using <code>require()</code> or <code>assert()</code> after Ether transfers. Additionally, use <code>call()</code> with a specified gas limit for greater flexibility and error handling.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-078/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    function transferEther(address payable _to) public payable {\n        // Fails silently if transfer fails\n        _to.transfer(msg.value);  // No error handling, can cause issues\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-078/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>contract Example {\n    function transferEther(address payable _to) public payable {\n        // Properly check for success\n        require(_to.send(msg.value), \"Transfer failed\");  // Using require to check for failure\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-079/","title":"SCWE-079: Insecure Use of Transfer and Send","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-079/#relationships","title":"Relationships","text":"<ul> <li>CWE-400: Uncontrolled Resource Consumption https://cwe.mitre.org/data/definitions/400.html </li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-079/#description","title":"Description","text":"<p>The use of <code>.transfer()</code> and<code>.send()</code>for Ether transfers in Solidity is insecure because they impose a fixed gas limit of 2300 gas. This restriction can cause transactions to fail unexpectedly when the receiving contract has complex logic that requires more gas. Additionally, it can result in a Denial of Service (DoS) vulnerability if the receiving contract cannot execute due to insufficient gas.</p> <p>This issue is especially problematic in upgradable smart contracts or protocol interactions, where the gas requirements of a receiving contract might change over time.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-079/#remediation","title":"Remediation","text":"<p>Instead of <code>.transfer()</code> and <code>.send()</code>, use <code>.call{value: msg.value}(\"\")</code>, which allows more flexible gas allocation and prevents DoS risks. Always check for the return value of <code>.call()</code> to ensure the transfer was successful.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-079/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<p><pre><code>contract Example {\n    function transferEther(address payable _to) public payable {\n        // Fixed gas limit of 2300 gas can cause unintended failures\n        _to.transfer(msg.value);  \n    }\n}\n</code></pre> Problem: - If <code>_to</code> is a contract that requires more than <code>2300 gas</code> (e.g., it has a fallback function with state changes), this transfer will fail. - The contract has no error handling, meaning the sender won't be aware of the failure.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-079/#fixed-contract-example","title":"Fixed Contract Example","text":"<p><pre><code>contract Example {\n    function transferEther(address payable _to) public payable {\n        // Use call() for better gas flexibility and proper error handling\n        (bool success, ) = _to.call{value: msg.value}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n</code></pre> Why is this better? - <code>.call{value: msg.value}(\"\")</code> does not impose a gas limit, allowing the receiving contract to execute as needed. - It includes a <code>require(success, \"Transfer failed\");</code> check, ensuring failures are properly handled.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-3"]},{"location":"SCWE/SCSVS-GOV/SCWE-081/","title":"SCWE-081: Improper Handling of Nonce","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-GOV/SCWE-081/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation https://cwe.mitre.org/data/definitions/20.html </li> </ul>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-GOV/SCWE-081/#description","title":"Description","text":"<p>Nonce values are used to ensure that transactions are processed in the correct order and prevent replay attacks. Improper handling or validation of nonces can lead to issues such as transaction replay or improper sequencing of transactions, which can be exploited by attackers.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-GOV/SCWE-081/#remediation","title":"Remediation","text":"<p>Always validate nonce values to ensure that they are correctly incremented and avoid reusing nonces. Ensure that nonce handling is robust, especially in cases where external calls are involved, to prevent replay attacks or transaction malleability.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-GOV/SCWE-081/#vulnerable-contract-example","title":"Vulnerable Contract Example","text":"<pre><code>contract Example {\n    mapping(address =&gt; uint256) public nonces;\n\n    function transfer(address _to, uint256 _amount) public {\n        uint256 nonce = nonces[msg.sender]; // Nonce is not validated properly\n        nonces[msg.sender] = nonce + 1;     // This could allow replay attacks\n        // Transfer logic\n    }\n}\n</code></pre>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-GOV/SCWE-081/#fixed-contract-example","title":"Fixed Contract Example","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SecureExample {\n    mapping(address =&gt; uint256) public nonces;\n\n    function transfer(\n        address _to,\n        uint256 _amount,\n        uint256 _nonce,\n        bytes memory _signature\n    ) public {\n        require(_nonce == nonces[msg.sender], \"Invalid nonce\");\n\n        // Hash the message\n        bytes32 messageHash = keccak256(abi.encodePacked(msg.sender, _to, _amount, _nonce));\n        bytes32 ethSignedMessageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash));\n\n        // Recover the signer's address\n        address signer = recoverSigner(ethSignedMessageHash, _signature);\n        require(signer == msg.sender, \"Invalid signature\");\n\n        nonces[msg.sender] = _nonce + 1;\n        // Transfer logic\n    }\n\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) internal pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        require(sig.length == 65, \"Invalid signature length\");\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n    }\n}\n</code></pre> <p>Why is this better? - Nonce is no longer user input: It is validated as part of a signed message, preventing arbitrary replay attempts. - Prevents transaction replay attacks: By signing the message, an attacker cannot reuse an old transaction because the signature includes the nonce. - Ensures integrity &amp; authenticity: The contract only processes the transaction if the signed message is valid and matches the expected sender.</p>","tags":["scwe","L1","SCSVS-GOV","SCSVS-GOV-2"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-028/","title":"SCWE-028: Price Oracle Manipulation","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-028/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-028/#description","title":"Description","text":"<p>Price Oracle manipulation refers to the exploitation of vulnerabilities in price oracles to manipulate contract logic. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of the contract's logic.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-028/#remediation","title":"Remediation","text":"<ul> <li>Use decentralized oracles: Leverage multiple decentralized oracles for price data.</li> <li>Validate inputs: Ensure all oracle data is properly validated before use.</li> <li>Implement circuit breakers: Add mechanisms to halt operations in case of suspicious activity.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-028/#examples","title":"Examples","text":"<ul> <li> <p>Vulnerable to Oracle Manipulation- Exploiting Weak Price Feeds</p> </li> <li> <p>Flash Loan-Based Price Manipulation</p> <pre><code>pragma solidity ^0.8.0;\n\ninterface Oracle {\n    function getPrice() external view returns (uint);\n}\n\ncontract VulnerableLending {\n    Oracle public priceOracle;\n    mapping(address =&gt; uint) public balances;\n\n    constructor(address _oracle) {\n        priceOracle = Oracle(_oracle);\n    }\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value * priceOracle.getPrice();\n    }\n\n    function withdraw(uint amount) external {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount / priceOracle.getPrice()); // Uses current price\n    }\n}\n</code></pre> </li> </ul> <p>Why is this vulnerable?</p> <ul> <li>Flash loan attack: The attacker can manipulate the price before calling withdraw(), draining funds.</li> <li> <p>No validation mechanism to reject manipulated prices.</p> </li> <li> <p>Protected Against Oracle Manipulation- Fixed Code: Using TWAP &amp; Price Guards</p> <pre><code>pragma solidity ^0.8.0;\n\ninterface Oracle {\n    function getPrice() external view returns (uint);\n}\n\ncontract SecureLending {\n    Oracle public priceOracle;\n    mapping(address =&gt; uint) public balances;\n    uint public lastValidPrice;\n\n    constructor(address _oracle) {\n        priceOracle = Oracle(_oracle);\n        lastValidPrice = priceOracle.getPrice();\n    }\n\n    function updatePrice() external {\n        uint newPrice = priceOracle.getPrice();\n        require(newPrice &gt; lastValidPrice * 95 / 100 &amp;&amp; newPrice &lt; lastValidPrice * 105 / 100, \"Price deviation too high\");\n        lastValidPrice = newPrice;\n    }\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value * lastValidPrice;\n    }\n\n    function withdraw(uint amount) external {\n        require(balances[msg.sender] &gt;= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount / lastValidPrice);\n    }\n}\n</code></pre> </li> </ul> <p>Fixes: - Uses TWAP (Time-Weighted Average Price) instead of relying on instantaneous price updates. - Implements price guards to prevent extreme price fluctuations.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-029/","title":"SCWE-029: Lack of Decentralized Oracle Sources","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-029/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-029/#description","title":"Description","text":"<p>Lack of decentralized oracle sources refers to the reliance on a single oracle for critical data, which can be manipulated or compromised. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of the contract's logic.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-029/#remediation","title":"Remediation","text":"<ul> <li>Use multiple oracles: Leverage multiple decentralized oracles for critical data.</li> <li>Validate inputs: Ensure all oracle data is properly validated before use.</li> <li>Implement fallback mechanisms: Use fallback oracles in case of failure.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-029/#examples","title":"Examples","text":"<ul> <li>Single Oracle Source/ Single Point of Failure <pre><code>pragma solidity ^0.8.0;\n\ninterface Oracle {\n    function getPrice() external view returns (uint);\n}\n\ncontract SingleOracle {\n    Oracle public priceOracle;\n\n    constructor(address _oracle) {\n        priceOracle = Oracle(_oracle);\n    }\n\n    function getPrice() public view returns (uint) {\n        return priceOracle.getPrice(); // Single source of truth\n    }\n}\n</code></pre></li> </ul> <p>Why is this vulnerable? - If the oracle fails, is compromised, or is manipulated, the contract has no fallback. - Attackers could hijack the single oracle and return malicious data.</p> <ul> <li>Decentralized Oracle Sources- Using Multiple Oracles &amp; Fallbacks <pre><code>pragma solidity ^0.8.0;\n\ninterface Oracle {\n    function getPrice() external view returns (uint);\n}\n\ncontract MultiOracle {\n    Oracle[] public priceOracles;\n\n    constructor(address[] memory _oracles) {\n        for (uint i = 0; i &lt; _oracles.length; i++) {\n            priceOracles.push(Oracle(_oracles[i]));\n        }\n    }\n\n    function getPrice() public view returns (uint) {\n        uint totalPrice = 0;\n        for (uint i = 0; i &lt; priceOracles.length; i++) {\n            totalPrice += priceOracles[i].getPrice();\n        }\n        return totalPrice / priceOracles.length; // Averaging multiple oracles\n    }\n}\n</code></pre> Fixes:</li> <li>Uses multiple oracles and computes an average to prevent manipulation.</li> <li>If one oracle fails or gets compromised, the contract still functions correctly.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-030/","title":"SCWE-030: Insecure Oracle Data Updates","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-030/#relationships","title":"Relationships","text":"<ul> <li>CWE-20: Improper Input Validation CWE-20 Link</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-030/#description","title":"Description","text":"<p>Insecure oracle data updates refer to the failure to properly validate or secure updates to oracle data. This can lead to: - Unauthorized actions by malicious actors. - Loss of funds or data. - Exploitation of the contract's logic.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-030/#remediation","title":"Remediation","text":"<ul> <li>Validate updates: Ensure all oracle data updates are properly validated.</li> <li>Restrict access: Restrict update permissions to trusted addresses.</li> <li>Implement timelocks: Add delays to oracle updates to allow for review.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-030/#examples","title":"Examples","text":"<ul> <li> <p>Insecure Oracle Updates <pre><code>pragma solidity ^0.8.0;\n\ncontract InsecureOracleUpdates {\n    function updatePrice(address oracle, uint newPrice) public {\n        Oracle(oracle).updatePrice(newPrice); // No validation\n    }\n}\n</code></pre></p> </li> <li> <p>Secure Oracle Updates <pre><code>pragma solidity ^0.8.0;\n\ncontract SecureOracleUpdates {\n    address public admin;\n\n    constructor(address _admin) {\n        admin = _admin;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Unauthorized\");\n        _;\n    }\n\n    function updatePrice(address oracle, uint newPrice) public onlyAdmin {\n        Oracle(oracle).updatePrice(newPrice); // Restricted to admin\n    }\n}\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-085/","title":"SCWE-085: Misuse of Oracle Min/Max Price Band Without Validation","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-085/#relationships","title":"Relationships","text":"<ul> <li>CWE-345: Insufficient Verification of Data Authenticity</li> <li>CWE-20:  Improper Input Validation</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-085/#description","title":"Description","text":"<p>This weakness occurs when smart contracts consume price oracle data (e.g., from Chainlink) without verifying whether the returned price falls within an expected or trusted range (e.g., <code>minPrice</code>/<code>maxPrice</code>). Oracles may return fallback floor or ceiling values when actual prices exceed internal limits or when the feed encounters data instability.</p> <p>Failing to detect and reject such edge-case values can result in incorrect or exploitable logic paths in smart contracts. This weakness may allow attackers to:</p> <ul> <li>Trigger mispriced swaps or asset conversions.</li> <li>Exploit collateralization thresholds.</li> <li>Manipulate auction pricing or tiered reward structures.</li> <li>Influence governance systems based on price weightings.</li> </ul> <p>These issues are especially dangerous during periods of high volatility or partial oracle outages, where fallback values may be automatically returned.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-085/#remediation","title":"Remediation","text":"<p>To mitigate this risk:</p> <ul> <li>Always verify that the oracle-provided price lies within an expected range.</li> <li>Check whether the returned value is a fallback boundary by comparing it against known <code>minPrice</code>/<code>maxPrice</code> values.</li> <li>Monitor and log unusual oracle values for off-chain alerts and incident response.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-085/#example","title":"Example","text":"<ul> <li>Vulnerable contract </li> </ul> <p><pre><code>(int256 price,,,) = AggregatorV3Interface(oracle).latestRoundData();\n\n// Uses price directly without checking for boundary values\nuint256 tokenAmount = uint256(price) * userInput;\n</code></pre> - Fixed Contract </p> <p><pre><code>(int256 price,,,) = AggregatorV3Interface(oracle).latestRoundData();\n\n// Validate that the price is within trusted bounds\nrequire(price &gt; minPrice &amp;&amp; price &lt; maxPrice, \"Price out of expected bounds\");\n\nuint256 tokenAmount = uint256(price) * userInput;\n</code></pre> This ensures that the contract rejects unexpected oracle values that might be returned during errors or manipulation attempts.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-085/#references","title":"References","text":"<ul> <li>Chainlink Docs: Chainlink Price Feeds Documentation</li> <li>CWE-345: Insufficient Verification of Data Authenticity</li> <li>CWE-20:  Improper Input Validation</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-086/","title":"SCWE-086: Missing Validation of Oracle Response Fields (Stale or Incomplete Data)","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-086/#relationships","title":"Relationships","text":"<ul> <li>CWE-345: Insufficient Verification of Data Authenticity</li> <li>CWE-20:  Improper Input Validation</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-086/#description","title":"Description","text":"<p>This weakness occurs when smart contracts consume data from oracles (e.g., Chainlink) without validating critical fields in the response such as <code>answeredInRound</code>, <code>timestamp</code>, or even the <code>answer</code> itself. Failing to validate these fields can lead to:</p> <ul> <li>Use of stale price data from old oracle rounds.</li> <li>Acceptance of incomplete oracle responses (e.g., <code>timestamp == 0</code>).</li> <li>Execution based on invalid or zero-priced data.</li> </ul> <p>This can severely affect the security of DeFi protocols or any smart contract relying on accurate, fresh data feeds.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-086/#remediation","title":"Remediation","text":"<ul> <li>Validate <code>answer</code> field: Ensure the value returned is greater than zero and not malformed.</li> <li>Check <code>answeredInRound &gt;= roundId</code>: Confirms that the data is not from a stale round.</li> <li>Verify <code>timestamp != 0</code>: Ensures that the oracle actually returned a complete result.</li> </ul> <p>Additional best practices include: - Using fallback mechanisms or thresholds for deviation checks. - Halting sensitive functions if oracle data is suspect or missing.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-086/#examples","title":"Examples","text":"<ul> <li> <p>\u274c Vulnerable Code (No Response Validation) <pre><code>(, int256 answer,,,) = AggregatorV3Interface(oracle).latestRoundData();\nrequire(uint256(answer) &gt; 0, \"Zero price\"); // Minimal check only\n</code></pre></p> </li> <li> <p>\u2705 Secure Code (With Full Oracle Validation) <pre><code>(uint80 roundID, int256 answer,, uint256 timestamp, uint80 answeredInRound) = \n    AggregatorV3Interface(oracle).latestRoundData();\n\nrequire(answer &gt; 0, \"Invalid price: &lt;= 0\");\nrequire(answeredInRound &gt;= roundID, \"Stale round data\");\nrequire(timestamp != 0, \"Incomplete oracle response\");\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-086/#references","title":"References","text":"<ul> <li>Chainlink Oracle Security Best Practices</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/","title":"SCWE-088: Improper Decimal Normalization in Price-Based Calculations","text":"Stable Version v0.0.1 <p>This content is in the version-(v0.0.1) and still under active development, so it is subject to change any time (e.g. structure, IDs, content, URLs, etc.).</p> <p> Send Feedback</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/#relationships","title":"Relationships","text":"<ul> <li>CWE-681:  Incorrect Conversion between Numeric Types</li> <li>CWE-682:  Incorrect Calculation</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/#description","title":"Description","text":"<p>This issue arises when smart contracts perform arithmetic involving token values and price feeds without properly aligning decimal places across different sources (e.g. ERC-20 tokens with varying decimals and Chainlink oracles with fixed 8-decimal prices). Failing to normalize decimals before calculations can lead to severely inflated or deflated results, causing users to be overcharged, underpaid, or otherwise economically exploited.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/#impact","title":"Impact","text":"<p>Smart contracts often rely on cross-asset conversions, such as paying fees in tokens or using collateralization logic involving price feeds. Improper decimal handling in these calculations may: - Lead to gross overcharging or underpayment. - Introduce systemic financial imbalances in vaults or accounting logic. - Enable economic exploits by arbitraging rounding errors or precision gaps. - Remain undetected during tests if decimals coincidentally align. This issue is especially critical when: - ERC-20 tokens with non-18 decimals (e.g., USDC = 6) are involved. - Chainlink oracles return 8-decimal fixed-point prices. - Arithmetic mixes native ETH values (in 18 decimals) with token values or prices.</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/#remediation","title":"Remediation","text":"<ul> <li>Always normalize decimals across all involved assets and feeds.</li> <li>Use centralized utility functions for all price/token conversions.</li> <li>Add sanity checks to detect outlier results (e.g., revert if output is &gt;1000x expected range).</li> <li>When possible, emit intermediate calculation steps for auditing.</li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/#examples","title":"Examples","text":"<ul> <li> <p>\u274c Vulnerable Code (Missing Decimal Normalization) <pre><code>// Assume ETH/USD = 3000e8 (8 decimals), Token/USD = 1e8, and token has 6 decimals\nuint256 tokenAmount = (ethAmountInWei * ethPriceInUsd) / tokenPriceInUsd;\n// Result is in 18-decimal scale, not adjusted for the 6-decimal USDC token\n</code></pre></p> </li> <li> <p>\u2705 Safe Code (With Proper Decimal Alignment) <pre><code>uint8 tokenDecimals = IERC20(token).decimals();\n\nuint256 rawAmount = (ethAmountInWei * ethPriceInUsd) / tokenPriceInUsd;\nuint256 adjustedAmount = rawAmount / (10 ** (18 - tokenDecimals));\n// Now 'adjustedAmount' is in correct units for the target token\n</code></pre></p> </li> </ul>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/#realistic-exploit-example","title":"Realistic Exploit Example","text":"<p>Assumptions:</p>","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"SCWE/SCSVS-ORACLE/SCWE-088/#registrar-fee-001-eth-1e16-wei-ethusd-price-3000-1e8-300000000000-usdcusd-price-1-1e8-100000000-usdc-has-6-decimals-faulty-calculation-result-1e16-300000000000-100000000-3e19-return-result-1e6-3e13-30-trillion-base-units-30-million-usdc-expected-001-eth-3000-30-30-1e6-30000000-usdc-units-overcharge-actual-charged-30000000-usdc-expected-30-usdc-overcharge-999900x","title":"<pre><code>Registrar fee = 0.01 ETH = 1e16 wei\n\nETH/USD price = 3000 * 1e8 = 300000000000\n\nUSDC/USD price = 1 * 1e8 = 100000000\n\nUSDC has 6 decimals\n\nFaulty Calculation:\n\nresult = (1e16 * 300000000000) / 100000000 = 3e19\nreturn result / 1e6 = 3e13 (30 trillion base units = 30 million USDC)\nExpected:\n\n0.01 ETH * $3,000 = $30\n\u2192 30 * 1e6 = 30,000,000 USDC units\n\nOvercharge:\n\nActual charged: 30,000,000 USDC\nExpected: 30 USDC\nOvercharge: 999,900x\n</code></pre>","text":"","tags":["scwe","L1","SCSVS-ORACLE","SCSVS-ORACLE-1"]},{"location":"checklists/SCSVS-ARCH/","title":"SCSVS-ARCH","text":"<p>Temporary Checklist</p> <p>This checklist contains the SCSVS v0.0.1 verification levels (L1, L2 and L3) which we are currently reworking into \"security testing profiles\". The levels were assigned according to the SCSVS v1 ID that the test was previously covering and might differ in the upcoming version of the SCSTG and SCS Checklist.</p> <p>For the upcoming of the SCSTG version we will progressively split the SCSTG tests into smaller tests, the so-called \"atomic tests\" and assign the new SCS profiles to their respective SCWE weaknesses.</p> SCG ID VR ID TEST ID Control / SCSTG Test Checklist SCSVS-ARCH-1 S1.1.A1 SCSTG-TEST-0005 Verify modularity and upgradability. - Are the smart contracts using import statements to include other contracts and libraries? - Are functions within the contract logically separated and grouped into different contracts or libraries? SCSVS-ARCH-1 S1.1.A2 SCSTG-TEST-0006 Ensure secure and controlled updates. - Is the contract using a proxy pattern (e.g., Transparent Proxy or UUPS Proxy) for upgradability? - Are the upgradeTo or similar functions protected with onlyOwner or onlyAdmin modifiers? - Are there migration functions to safely transfer state variables to the new contract version? SCSVS-ARCH-1 S1.1.A3 SCSTG-TEST-0006 Check module boundaries and dependencies. - Are interfaces and abstract contracts used to define boundaries between modules? - Are external calls to other modules made through well-defined interfaces? SCSVS-ARCH-1 S1.1.A4 SCSTG-TEST-0006 Ensure changes to storage variables are managed. - Is there a well-documented storage layout for the contract? - Are storage variables added in storage gaps to avoid conflicts? SCSVS-ARCH-1 S1.1.A5 SCSTG-TEST-0006 Verify critical privilege transfers. - Is there a two-step process for transferring ownership using transferOwnership and claimOwnership? - Are there events emitted for each step of the transfer process? SCSVS-ARCH-1 S1.1.A6 SCSTG-TEST-0006 Verify data location handling in function overrides. - Are memory and storage keywords correctly used for parameters and return variables in overridden functions? - Are there tests covering function overrides to ensure no invalid virtual function calls? SCSVS-ARCH-1 S1.1.B1 No Test ID Verify separation of different functionalities. - Are the contracts modular with clearly defined responsibilities? - Is there a single responsibility per contract or module? SCSVS-ARCH-1 S1.1.B2 No Test ID Ensure minimal dependencies between modules. - Are modules loosely coupled? - Is each module's responsibility clearly defined and limited? SCSVS-ARCH-1 S1.1.B3 No Test ID Check for cross-module dependencies. - Are there dependencies that could introduce security vulnerabilities? - Is each module's responsibility clearly defined and limited? SCSVS-ARCH-1 S1.1.B4 No Test ID Ensure consistent operation during privilege transfers. - Are edge cases considered during privilege transfers? - Is there a fallback mechanism in case of transfer failure? SCSVS-ARCH-1 S1.1.B5 No Test ID Verify proxy contract initialization. - Are proxy contracts using the onlyInitializing modifier? - Is there a check to prevent re-initialization? SCSVS-ARCH-1 S1.1.B6 No Test ID Verify storage layout consistency. - Are storage layouts compatible across different contract versions? - Is there documentation for storage layout changes? SCSVS-ARCH-1 S1.1.B7 No Test ID Ensure immutable variable consistency. - Are immutable variables properly defined and documented? - Is there a verification process for consistency across upgrades? SCSVS-ARCH-1 S1.1.B8 No Test ID Verify consistency in logic implementation. - Is logic implemented consistently across the contract? - Is there a review process for verifying consistency? SCSVS-ARCH-1 S1.1.B9 No Test ID Ensure separate handling of ETH and WETH. - Are ETH and WETH treated as distinct entities? - Are there checks in place to handle ETH and WETH appropriately? SCSVS-ARCH-1 S1.1.B10 No Test ID Verify proxy setup for contracts with constructors. - Are contracts designed without constructors for proxy setups? - Is initializer logic implemented and verified? SCSVS-ARCH-2 S1.2.A1 No Test ID Verify implementation of upgrade mechanisms. - Is the contract using a well-known proxy pattern such as Transparent Proxy or UUPS Proxy? - Are there unit tests verifying the upgrade functionality? - Is the upgrade mechanism designed to be easily extensible for future upgrades? SCSVS-ARCH-2 S1.2.A2 No Test ID Ensure safeguards against unauthorized upgrades. - Is the upgradeTo function protected by onlyOwner or onlyAdmin modifiers? - Are access controls and ownership mechanisms properly tested and reviewed? - Are multi-signature wallets or other advanced access control mechanisms used for upgrade authorization? SCSVS-ARCH-2 S1.2.A3 No Test ID Review and document the upgrade mechanism. - Is the upgrade mechanism thoroughly documented in the project documentation? - Has the upgrade mechanism undergone a formal security audit? - Are there guidelines and best practices documented for performing upgrades? SCSVS-ARCH-2 S1.2.A4 No Test ID Verify consistency of immutable variables. - Are immutable variables defined and documented across all contract versions? - Is there a validation process to ensure consistency of immutable variables during upgrades? - Are there automated tests checking the state of immutable variables before and after upgrades? SCSVS-ARCH-2 S1.2.A5 No Test ID Verify use of selfdestruct and delegatecall in proxy setup. - Is there a review process for identifying and mitigating risks associated with selfdestruct and delegatecall? - Are there unit tests covering scenarios involving selfdestruct and delegatecall? - Is the use of selfdestruct and delegatecall documented and justified in the contract? SCSVS-ARCH-2 S1.2.A6 No Test ID Protect UUPSUpgradeable contracts. - Are UUPSUpgradeable contracts tested for initialization-related vulnerabilities? - Is there a mechanism to ensure that implementation contracts are properly initialized before use? - Are there security reviews focused on initialization and upgrade vulnerabilities in UUPSUpgradeable contracts? SCSVS-ARCH-2 S1.2.B1 No Test ID Verify handling of deprecated contract versions. - Are deprecated contract versions clearly marked with appropriate deprecation notices in the code and documentation? - Is there a mechanism to disable functionality in deprecated contracts while maintaining state integrity? - Are deprecated contracts archived and isolated from the main deployment pipeline to prevent accidental usage? SCSVS-ARCH-2 S1.2.B2 No Test ID Ensure restriction or disabling of access to deprecated versions. - Are access controls updated to restrict interactions with deprecated contract versions? - Is there a revocation process in place to revoke permissions or keys associated with deprecated contracts? - Are deprecated contracts audited to ensure no critical functions remain accessible post-deprecation? SCSVS-ARCH-2 S1.2.B3 No Test ID Check security of migration paths from deprecated versions. - Is there a documented and tested migration plan for transitioning from deprecated to new contract versions? - Are migration scripts and tools audited for security vulnerabilities that could compromise the migration process? - Is there a rollback mechanism in case the migration encounters issues, ensuring no loss of state or functionality? SCSVS-ARCH-3 S1.3.C1 No Test ID Verify implementation of high-priority risk mitigations. - Are there specific mitigations in place for reentrancy attacks, such as the use of checks-effects-interactions pattern or reentrancy guards? - Are overflow and underflow checks implemented using SafeMath or Solidity's built-in overflow protection? - Are access controls and role-based permissions thoroughly tested to prevent unauthorized access? SCSVS-ARCH-3 S1.3.C2 No Test ID Ensure documentation and testing of mitigation strategies. - Are all mitigation strategies documented with clear explanations of how they address specific vulnerabilities? - Are there unit and integration tests specifically designed to validate the effectiveness of each mitigation strategy? - Is there a process for continuously updating the documentation and tests as new threats and mitigations are identified? SCSVS-ARCH-3 S1.3.C3 No Test ID Review and validate effectiveness of implemented mitigations. - Are periodic security audits conducted to review and validate the effectiveness of implemented mitigations? - Are there automated tools and scripts in place to continuously monitor the security posture of the smart contracts? - Is there a feedback loop for integrating audit findings and monitoring results into the mitigation strategy? SCSVS-ARCH-3 S1.3.G1 No Test ID Understanding Protocol Actors - Have all actors and their interactions within the protocol been clearly identified and documented? - Are the roles and permissions of each actor clearly defined and appropriate? - Does the contract inherit functions from parent contracts? - Are functions that override parent contract functions explicitly marked with the override keyword? SCSVS-ARCH-3 S1.3.G3 No Test ID Verify Sybil Attack Protection - Is the protocol's quorum mechanism or rewarding system designed to resist Sybil attacks? Verify the criteria used for participation or rewards. - How does the contract ensure that actions or decisions are not unduly influenced by Sybil attacks? - Are there checks or balances in place to validate the legitimacy of addresses participating in quorum or rewarding mechanisms? SCSVS-ARCH-3 S1.3.G4 No Test ID Verify Front-Running Protection for Initializer - Does the contract use a factory pattern or other mechanism to prevent front-running of the initializer function? - Is the initializer function protected from being called by unauthorized parties immediately after deployment? - Have you implemented safeguards to ensure the initializer cannot be front-run to alter critical access controls? <p></p> <p></p>","tags":[]},{"location":"checklists/SCSVS-AUTH/","title":"SCSVS-AUTH","text":"<p>Temporary Checklist</p> <p>This checklist contains the SCSVS v0.0.1 verification levels (L1, L2 and L3) which we are currently reworking into \"security testing profiles\". The levels were assigned according to the SCSVS v1 ID that the test was previously covering and might differ in the upcoming version of the SCSTG and SCS Checklist.</p> <p>For the upcoming of the SCSTG version we will progressively split the SCSTG tests into smaller tests, the so-called \"atomic tests\" and assign the new SCS profiles to their respective SCWE weaknesses.</p> SCG ID VR ID TEST ID Control / SCSTG Test Checklist SCSVS-AUTH-1 S4.1.G1 No Test ID Verify Authorization Using msg.sender - Does the contract use tx.origin in validation? If yes, this must be avoided as tx.origin phishing attacks are possible and can be exploited. - Are proper authorization mechanisms in place using msg.sender to ensure secure and accurate access control? SCSVS-AUTH-1 S4.1.G2 No Test ID Verify Role-Based Access Control Implementation - Are there different roles that have been assigned and have different access control mechanisms? - If yes, check and verify that correct access control mechanisms are implemented and least privilege policy is implemented. SCSVS-AUTH-1 S4.1.G3 No Test ID Verify Modifier Logic - Are all custom modifiers correctly implemented and applied to the intended functions? - Are there any modifiers that contain redundant or conflicting logic? - Have the modifiers been reviewed and tested for potential vulnerabilities? SCSVS-AUTH-1 S4.1.G4 No Test ID Verify debit function validation. - Does the _debitFrom function properly verify token ownership and transfer permissions? - Are there any gaps in validation that could impact token security? - How does the function ensure that only authorized transfers occur? SCSVS-AUTH-1 S4.1.G5 No Test ID Verify presence of required code components. - Is it checked if the target address of a call has code deployed? - How does the system handle calls to addresses without code? - What mechanisms are in place to verify code presence before making calls? SCSVS-AUTH-1 S4.1.G6 No Test ID Verify Access Control Implementation - Are there any functions lacking access control mechanisms? - Are there any public functions that should have a more restricted visibility (e.g., internal, private)? - Are access controls correctly implemented to prevent unauthorized access or modifications? SCSVS-AUTH-1 S4.1.G7 No Test ID Verify Admin Asset Pull Privilege - Can the admin of the protocol pull assets from the protocol? Verify the extent of the admin's privileges and access controls. - Are there constraints or timelocks in place to regulate admin access to protocol funds? - How does the protocol track and report admin actions that involve user funds? SCSVS-AUTH-1 S4.1.G8 No Test ID Verify Timelocks for Critical Functions - Are timelocks implemented for all critical functions in the smart contract? - What is the duration of the timelock for each critical function? Is it adequate for review purposes? - Can timelocks be bypassed or modified? If so, under what conditions? SCSVS-AUTH-1 S4.1.G9 No Test ID Verify Whitelisting Implementation - Are certain addresses required to be whitelisted to interact with the contract? - Is the whitelisting mechanism properly implemented and enforced? SCSVS-AUTH-1 S4.1.G10 No Test ID Verify Contract Initialization Functions - Are initialization functions properly marked as internal? - Is there a mechanism in place to ensure initialization functions cannot be executed more than once? - Are there any fallback functions that might unintentionally allow reinitialization? SCSVS-AUTH-1 S4.1.G11 No Test ID Verify Secure Privilege Transfer - Does the protocol allow the transfer of privileges? - If yes, is the transfer process secure and includes a two-step (request and confirmation) mechanism? - What happens during the transfer of privileges? SCSVS-AUTH-2 S4.2.G1 No Test ID Verify Critical Function Access Control - Does the contract have the specified functions? - If yes, are proper access control measures in place? SCSVS-AUTH-2 S4.2.G2 No Test ID Prevent Arbitrary Calls Execution - Can the contract make arbitrary calls based on user input? - Have you validated and sanitized user inputs to prevent executing unintended calls? - Is there a mechanism to prevent execution of arbitrary code based on user input? SCSVS-AUTH-2 S4.2.G3 No Test ID Verify Caller Address in Callbacks - Does the integrating contract verify the caller address in its callback functions? - Have you implemented checks to validate the address of the calling contract in callback functions? - Is there a review of callback logic to ensure it prevents unauthorized access or manipulation? SCSVS-AUTH-2 S4.2.G4 No Test ID Mitigate Risks from Excessively High Allowances - Does the protocol implement safeguards against excessively high allowances? - Is there a revert mechanism in place for overly high approval values? <p></p> <p></p>","tags":[]},{"location":"checklists/SCSVS-BLOCK/","title":"SCSVS-BLOCK","text":"<p>Temporary Checklist</p> <p>This checklist contains the SCSVS v0.0.1 verification levels (L1, L2 and L3) which we are currently reworking into \"security testing profiles\". The levels were assigned according to the SCSVS v1 ID that the test was previously covering and might differ in the upcoming version of the SCSTG and SCS Checklist.</p> <p>For the upcoming of the SCSTG version we will progressively split the SCSTG tests into smaller tests, the so-called \"atomic tests\" and assign the new SCS profiles to their respective SCWE weaknesses.</p> SCG ID VR ID TEST ID Control / SCSTG Test Checklist SCSVS-BLOCK-1 S8.1.G1 No Test ID Verify secure iteration over operators and validators. - Does the protocol avoid iterating over the entire set of operators or validators to prevent gas limit issues? - Are there mechanisms to manage large sets of operators or validators without causing denial of service? - How does the protocol handle large numbers of operators or validators to maintain efficiency and avoid out-of-gas errors? SCSVS-BLOCK-1 S8.1.G2 No Test ID Verify handling of oracle reverts. - Does the system handle potential oracle reverts effectively? - If an oracle revert occurs, are there safeguards to prevent Denial-of-Service conditions? - Are there alternative strategies in place to address oracle reverts? SCSVS-BLOCK-1 S8.1.G3 No Test ID Verify blocking mechanism security. - Does the system use blocking or non-blocking mechanisms? - Can the use of a blocking mechanism lead to a DoS attack? - What are the risks associated with the current mechanism used? SCSVS-BLOCK-1 S8.1.G4 No Test ID Verify protocol stability without overreliance on reserves. - Is there excessive reliance on pool reserves? - What alternative methods or checks are implemented to mitigate risks associated with pool reserves? - Can pool reserves be manipulated through techniques like flashloans? SCSVS-BLOCK-1 S8.1.G5 No Test ID Verify Front-Running Risk - Are there safeguards to prevent front-running attacks by ensuring fair transaction processing? - Does the protocol include measures to handle transactions in a way that mitigates the risk of priority manipulation? - Is there a mechanism to protect against attacks that exploit transaction ordering or timing? SCSVS-BLOCK-1 S8.1.G6 No Test ID Verify correct pausing functionality. - Can functionality be bypassed if a related pause check is missing in one of the functions? - Are all functions that should be paused during a system-wide pause consistently checked for the paused state? - Is there a mechanism to ensure all related functions respect the pause state uniformly? SCSVS-BLOCK-2 S8.2.G1 No Test ID Verify Queue Processing DoS Risks - Is there a limit on the size or number of queued transactions to prevent denial of service? Verify that the contract enforces these limits. - Does the contract implement measures to prevent abuse of queue processing, such as rate limiting or prioritization? - How does the protocol handle excessive queue sizes or frequent updates to prevent system overload? SCSVS-BLOCK-2 S8.2.G2 No Test ID Prevent Same-Block Withdrawal Attacks - Are withdrawals disabled within the same block as other significant actions? - Does the protocol prevent flashloan attacks by implementing a delay or restriction on withdrawals within the same block? SCSVS-BLOCK-2 S8.2.G3 No Test ID Verify DoS in Loops - Is there a potential for a Denial-of-Service (DoS) attack in loops? Verify if external calls or user inputs could impact the loop execution. - How does the contract ensure that a failure in a single iteration does not affect the overall operation? - Are there mechanisms to handle or mitigate the impact of failed or problematic iterations in loops? SCSVS-BLOCK-2 S8.2.G7 No Test ID Verify msg.value in Loop - Is msg.value used within a loop? Verify if msg.value is accessed multiple times within a loop. - How does the contract manage msg.value to ensure consistent accounting throughout the transaction? - Are there potential issues or mistakes in accounting if msg.value is used in a loop? SCSVS-BLOCK-2 S8.2.G8 No Test ID Verify Batch Fund Transfer - Is there a loop to handle batch fund transfers? Verify how the mechanism handles residual or leftover funds. - How does the contract ensure that all funds are transferred correctly, including any residual amounts? - Are there specific checks or logic to handle the last transfer in a batch to account for dust funds? SCSVS-BLOCK-2 S8.2.G9 No Test ID Verify Block Timestamp Manipulation - Is block.timestamp used for critical logic where precision is crucial? Verify that it is used appropriately. - How does the contract account for potential inaccuracies or manipulations in block.timestamp? - Are there alternative mechanisms or fallback strategies used when precise timing is required? <p></p> <p></p>","tags":[]},{"location":"checklists/SCSVS-BRIDGE/","title":"SCSVS-BRIDGE","text":"<p>Temporary Checklist</p> <p>This checklist contains the SCSVS v0.0.1 verification levels (L1, L2 and L3) which we are currently reworking into \"security testing profiles\". The levels were assigned according to the SCSVS v1 ID that the test was previously covering and might differ in the upcoming version of the SCSTG and SCS Checklist.</p> <p>For the upcoming of the SCSTG version we will progressively split the SCSTG tests into smaller tests, the so-called \"atomic tests\" and assign the new SCS profiles to their respective SCWE weaknesses.</p> SCG ID VR ID TEST ID Control / SCSTG Test Checklist SCSVS-BRIDGE-1 S9.1.G1 No Test ID Verify handling of stale data in proof-of-reserves oracle. - Does the protocol verify the freshness of data retrieved from the Proof of Reserves Oracle? - Can the protocol process stale data due to lack of timestamp validation from the Oracle? - What measures are in place to ensure the data from the Proof of Reserves Oracle is current and reliable? SCSVS-BRIDGE-1 S9.1.G2 No Test ID Verify removal of deprecated Chainlink functions. - Is the protocol using deprecated Chainlink functions like latestAnswer() that may return stale data? - Are there updated Chainlink methods in use to ensure accurate and current data retrieval? - How does the protocol handle deprecated functions to maintain data integrity? SCSVS-BRIDGE-1 S9.1.G3 No Test ID Verify secure updating of price feed addresses. - Are price feed addresses hard-coded in the contract? - If price feed addresses are hard-coded, is there a mechanism to update them if they become deprecated? - Can the contract manage risks associated with outdated or inaccurate hard-coded price feed addresses? SCSVS-BRIDGE-1 S9.1.G4 No Test ID Verify correct cETH token integration. - Does the protocol use the cETH token, and if so, how is the absence of underlying() handled? - If cETH token integration is utilized, are there any issues or errors due to the absence of the underlying() function? - Are integration tests performed to ensure proper functionality with the cETH token? SCSVS-BRIDGE-1 S9.1.G5 No Test ID Verify management of cbETH rate decreases. - How does the system handle potential decreases in the cbETH/ETH rate? - What mechanisms are in place to inform users about significant rate changes? - Can users be affected by a dramatic decrease in the cbETH/ETH rate? SCSVS-BRIDGE-1 S9.1.G6 No Test ID Verify secure sfrxETH detachment handling. - Does the system handle potential detachment of sfrxETH from frxETH during reward transfers? - Is there transparency regarding actions of the Frax team's multi-sig contract in managing sfrxETH and frxETH? - Are mechanisms in place to alert users about discrepancies between sfrxETH and frxETH? SCSVS-BRIDGE-1 S9.1.G7 No Test ID Verify stability of sfrxETH rate calculations. - Does the system guarantee the stability of the sfrxETH/ETH rate, or can it change in the future? - Are users informed about potential changes to the sfrxETH/ETH rate? - Is there documentation available regarding the stability and future changes of the sfrxETH/ETH rate? SCSVS-BRIDGE-1 S9.1.G8 No Test ID Verify handling of stETH rebasing mechanisms. - Is the application aware of the rebasing nature of stETH? - Does the system consider using wstETH for simpler DeFi integrations? - Are there mechanisms in place to handle complexities introduced by rebasing tokens? SCSVS-BRIDGE-1 S9.1.G9 No Test ID Verify correct handling of stETH withdrawals. - Does the system account for overheads when withdrawing stETH or wstETH? - Are there mechanisms in place to handle queue time and limits associated with withdrawals? - How does the protocol address issues related to NFT receipt and withdrawal amount limits? SCSVS-BRIDGE-1 S9.1.G10 No Test ID Verify secure stETH-wstETH conversions. - Does the system handle conversions between stETH and wstETH accurately? - Are the rebasing characteristics of stETH managed correctly during conversions? - What measures are in place to ensure correct handling of stETH to wstETH conversions? SCSVS-BRIDGE-1 S9.1.G11 No Test ID Verify consistency of token order. - Is the order of token0 and token1 consistent across different chains? - What steps are taken to verify token order when interacting with various chains? - Can inconsistencies in token order impact functionality? SCSVS-BRIDGE-2 S9.2.G1 No Test ID Verify blockchain compatibility. - Has the protocol been reviewed for compatibility with target chains? - What steps are taken to address differences between chains? - How does the system ensure compatibility with various chains? SCSVS-BRIDGE-2 S9.2.G2 No Test ID Verify secure contract upgradability. - Have contract upgradability implications been evaluated for different chains? - What upgradability characteristics are documented for each chain? - How does the system address upgradability differences across chains? SCSVS-BRIDGE-2 S9.2.G3 No Test ID Verify security of cross-chain messaging. - Have cross-chain messaging implementations been thoroughly reviewed for permissions and functionality? - What security checks are in place for cross-chain messaging? - How does the system ensure correct permissions for cross-chain messages? SCSVS-BRIDGE-2 S9.2.G4 No Test ID Verify handling of unsupported chain messages. - Is there a whitelist of compatible chains for message handling? - What measures are in place to block messages from unsupported chains? - How does the system handle messages from non-whitelisted chains? SCSVS-BRIDGE-2 S9.2.5 No Test ID Verify correct PUSH0 opcode support. - Is the PUSH0 opcode supported for Solidity version &gt;=0.8.20 on the target chain? - What compatibility checks are performed for the PUSH0 opcode? - How does the system handle chains that do not support PUSH0? SCSVS-BRIDGE-2 S9.2.G6 No Test ID Prevent Accounting Issues from Direct Transfers - Could direct transfers of assets affect the protocol's internal accounting? - Does the protocol rely on balanceOf or address.balance for accounting purposes? - Have you ensured that direct transfers do not disrupt the protocol\u2019s logic or accounting? SCSVS-BRIDGE-2 S9.2.G7 No Test ID Handle Small Residual Balances - What happens if a small residual amount (e.g., 1 wei) remains in the pool? - Does the protocol handle minimal residual amounts appropriately? SCSVS-BRIDGE-2 S9.2.G8 No Test ID Verify Array Deletion Method - How does the protocol remove an item from an array? Verify the method used for array element removal. - Does the contract handle array reordering or element shifting after an item is deleted? - Are there mechanisms in place to update the array length or manage gaps created by delete? SCSVS-BRIDGE-2 S9.2.G9 No Test ID Verify Array Index Usage - Does any function get an index of an array as an argument? Verify if this index is used in contexts where the array might be modified. - How does the contract handle index-based access in arrays where elements might be added or removed? - Are there checks to ensure that index values are valid and consistent with the current state of the array? SCSVS-BRIDGE-2 S9.2.G10 No Test ID Verify Unique Array Validation - Is it acceptable to have duplicate items in the array? Verify the expected behavior of the array regarding uniqueness. - How does the protocol validate and handle duplicate entries in arrays, particularly user input arrays? - Are there checks or validations to enforce array uniqueness where required? SCSVS-BRIDGE-2 S9.2.G11 No Test ID Verify Loop Edge Cases - Is there any issue with the first and last iteration of loops? Verify if these iterations have different logic or edge cases. - How does the contract ensure consistent behavior throughout all iterations, including the initial and final ones? - Are there specific tests for the edge cases of loop iterations to prevent potential vulnerabilities? SCSVS-BRIDGE-2 S9.2.G13 No Test ID Verify Loop Control Statements - Is there a break or continue statement inside a loop? Verify how these statements are used within the loop. - How does the contract ensure that the use of break or continue does not lead to unexpected behaviors or logic errors? - Are there tests to cover scenarios where loop control statements might affect the loop's functionality? SCSVS-BRIDGE-2 S9.2.G14 No Test ID Verify State Variable Initialization - Are all important state variables explicitly initialized in the constructor or initialization functions? - Have you reviewed the contract to ensure no uninitialized state variables could lead to vulnerabilities or errors? - Is there a clear initialization strategy for all state variables used in the contract? SCSVS-BRIDGE-2 S9.2.G15 No Test ID Verify Proper Deletion of Nested Structures - Does the deletion logic ensure that all nested fields within a structure are properly handled and reset? - Are there mechanisms in place to delete or reset nested fields before removing the top-level field? - Have you verified that nested structures are correctly managed to avoid residual data issues? SCSVS-BRIDGE-2 S9.2.G16 No Test ID Verify External State Changes Impact - Does the contract rely on external states that can be modified by other actors? Verify how these external changes impact critical functions. - Are there protections against state changes that could disrupt normal user transactions, particularly for crucial operations like withdrawals or repayments? - How does the contract ensure that its core functionality remains intact despite potential manipulations by external actors? SCSVS-BRIDGE-2 S9.2.G17 No Test ID Verify Edge Case Handling - Are edge cases (such as zero or maximum values) specifically tested to ensure the contract handles them correctly? - Is there logic in place to handle unusual or extreme input values gracefully without failure? - Does the contract have mechanisms to validate and handle boundary values appropriately? <p></p> <p></p>","tags":[]},{"location":"checklists/SCSVS-CODE/","title":"SCSVS-CODE","text":"<p>Temporary Checklist</p> <p>This checklist contains the SCSVS v0.0.1 verification levels (L1, L2 and L3) which we are currently reworking into \"security testing profiles\". The levels were assigned according to the SCSVS v1 ID that the test was previously covering and might differ in the upcoming version of the SCSTG and SCS Checklist.</p> <p>For the upcoming of the SCSTG version we will progressively split the SCSTG tests into smaller tests, the so-called \"atomic tests\" and assign the new SCS profiles to their respective SCWE weaknesses.</p> SCG ID VR ID TEST ID Control / SCSTG Test Checklist SCSVS-CODE-1 S2.1.A1 TBD Ensure adherence to latest compiler recommendations. - Are the smart contracts compiled using the latest stable version of the Solidity compiler? - Are there automated checks in the CI/CD pipeline to enforce the use of specific compiler versions? - Is there documentation and enforcement of the project's policy on compiler versioning? SCSVS-CODE-1 S2.1.A2 TBD Verify non-usage of deprecated functions. - Are deprecated functions identified and removed from the codebase during code reviews? - Are automated static analysis tools used to detect the usage of deprecated functions? - Is there a process to update the codebase to replace deprecated functions with their recommended alternatives? SCSVS-CODE-1 S2.1.B1 TBD Independent expert code review. - Are pull requests (PRs) for smart contract changes reviewed and approved by at least two developers with smart contract security expertise? - Is there documentation of the review process, including comments and approvals from the reviewers? SCSVS-CODE-1 S2.1.B2 TBD Incorporate automated static analysis tools. - Are automated static analysis tools, such as MythX or Slither, integrated into the CI/CD pipeline for smart contract code reviews? - Are all issues flagged by these tools documented and resolved or justified before merging the code? SCSVS-CODE-1 S2.1.B3 TBD Thorough analysis for vulnerabilities. - Are code reviews checking for potential reentrancy vulnerabilities, such as unprotected external calls within functions? - Are integer overflow and underflow vulnerabilities being checked using SafeMath or Solidity's built-in overflow protection? - Is the code reviewed for proper access control mechanisms, ensuring that only authorized addresses can perform sensitive operations? SCSVS-CODE-1 S2.1.B4 TBD Adherence to development standards. - Are smart contracts using SafeMath libraries for all arithmetic operations to prevent overflows and underflows? - Is the use of design patterns like checks-effects-interactions consistently applied to mitigate reentrancy attacks? - Are fallback and receive functions implemented securely, with proper checks to prevent misuse? SCSVS-CODE-1 S2.1.B5 TBD Checklist for common vulnerabilities. - Is there a comprehensive checklist of common smart contract vulnerabilities (e.g., reentrancy, integer overflows, unchecked external calls) used during code reviews? - Are all items on the checklist reviewed and marked as addressed in the code review process? - Are the checklist and review process updated regularly to incorporate new vulnerabilities and best practices? SCSVS-CODE-1 S2.1.G1 No Test ID Verify Inherited Function Implementation - Have all required functions specified by parent contracts been implemented in the derived contract? - Are there any missing implementations that could affect the functionality or purpose of inheritance? - Is the inherited contract\u2019s behavior consistent with the parent contract\u2019s expectations? SCSVS-CODE-1 S2.1.G2 No Test ID Verify Interface Implementation - Does the contract correctly implement all functions defined in the interface it adheres to? - Have you verified that the interface methods are fully implemented and operational? - Are there any discrepancies between the interface specification and the contract implementation? SCSVS-CODE-1 S2.1.G3 No Test ID Verify Correct Inheritance Order - Is the inheritance chain ordered from the most base-like contract to the most derived contract? - Have you verified that the inheritance order does not affect variable initialization or functionality? - Are there any issues with storage layout or state variable initialization due to incorrect inheritance order? SCSVS-CODE-1 S2.1.G4 No Test ID Verify Initializable Usage - Does the contract use the onlyInitializing modifier if it is intended to be inherited? - Is the initializer modifier used appropriately and not exposed to inherited contracts? - Have you ensured that initialization is restricted correctly to avoid unauthorized access? SCSVS-CODE-1 S2.1.G5 No Test ID Verify Comment Accuracy - Are comments and documentation reviewed and updated regularly to match the current implementation? - Does the code review process include verification of comment accuracy and relevance? - Are there automated tools or practices in place to flag outdated or inconsistent comments? <p></p> <p></p>","tags":[]},{"location":"checklists/SCSVS-COMM/","title":"SCSVS-COMM","text":"<p>Temporary Checklist</p> <p>This checklist contains the SCSVS v0.0.1 verification levels (L1, L2 and L3) which we are currently reworking into \"security testing profiles\". The levels were assigned according to the SCSVS v1 ID that the test was previously covering and might differ in the upcoming version of the SCSTG and SCS Checklist.</p> <p>For the upcoming of the SCSTG version we will progressively split the SCSTG tests into smaller tests, the so-called \"atomic tests\" and assign the new SCS profiles to their respective SCWE weaknesses.</p> SCG ID VR ID TEST ID Control / SCSTG Test Checklist SCSVS-COMM-1 S5.1.G1 No Test ID Verify protection of exchange rates from sandwich attacks. - Does the protocol allow instant withdrawals that could be exploited through sandwich attacks? - Can an attacker manipulate the exchange rate through immediate deposits and withdrawals? - Is there a mechanism to prevent front-running and back-running attacks affecting ETH drainage from the protocol? SCSVS-COMM-1 S5.1.G2 No Test ID Verify front-running protections for oracle price updates. - Can oracle price updates be front-run to manipulate outcomes? - If oracle price updates are vulnerable to front-running, are there protections in place? - Are there mechanisms to safeguard the protocol from front-running attacks on oracle price updates? SCSVS-COMM-1 S5.1.G3 No Test ID Verify enforcement of Balancer flash loan fees. - Does the protocol currently use Balancer's flash loans, and how are potential fees handled? - If Balancer implements flash loan fees in the future, how will the protocol manage these fees? - Are there mechanisms to ensure the repayment of fees along with the original debt in the receiveFlashLoan function? SCSVS-COMM-1 S5.1.G4 No Test ID Verify accuracy of Balancer oracle pricing. - Does the protocol rely on Balancer's Oracle for pricing? - If Balancer's Oracle is used, are there safeguards against price updates that do not reflect the true asset value? - What are the potential risks of using Balancer's Oracle, and how are they mitigated? SCSVS-COMM-1 S5.1.G5 No Test ID Verify security of Balancer boosted pool supply calculations. - Does the protocol use Balancer's Boosted Pool, and if so, does it use virtualSupply correctly? - How is the total BPT supply in circulation determined in the context of Balancer's Boosted Pool? - Are there any discrepancies in using virtualSupply versus totalSupply? SCSVS-COMM-1 S5.1.G6 No Test ID Verify Balancer vault pool liquidity security. - Does the protocol use Balancer vault pool liquidity status for pricing or other calculations? - How is the protocol protected against manipulation of token balances and BPT supply in Balancer pools? - Are there precautions in place to prevent inaccuracies caused by manipulation of external queries? SCSVS-COMM-1 S5.1.G7 No Test ID Verify correct Chainlink VRF parameter configurations. - Are all parameters thoroughly verified before calling Chainlink VRF to ensure correct results? - What mechanisms are in place to validate parameters for Chainlink VRF calls? - How does the protocol handle potential issues with parameter verification in Chainlink VRF? SCSVS-COMM-1 S5.1.G8 No Test ID Verify secure Chainlink VRF subscription mechanisms. - Is it ensured that sufficient LINK is maintained in the Chainlink VRF subscription to avoid pending states? - How does the protocol handle scenarios where the subscription is low on LINK? - What measures are in place to prevent vulnerabilities related to insufficient LINK in the Chainlink VRF subscription? SCSVS-COMM-1 S5.1.G9 No Test ID Verify security of confirmation number selection. - Is the number of confirmations chosen appropriate for the chain's history and risks? - How does the choice of confirmations address past reorg events? - Are there any adjustments made based on the chain's reorg vulnerabilities? SCSVS-COMM-1 S5.1.G10 No Test ID Verify correct cbETH rate control. - How is control over the cbETH/ETH rate determined? - Are there specific addresses with control due to the onlyOracle modifier? - Can centralization risks or manipulations arise from this control? SCSVS-COMM-1 S5.1.G11 No Test ID Verify security of direct pool swap usage. - Is pool.swap() used directly in the application? - What security mechanisms are bypassed by using pool.swap() directly? - Does the system use the Router contract for swaps to enhance security? SCSVS-COMM-1 S5.1.G12 No Test ID Verify correct use of Uniswap math libraries. - Is unchecked used appropriately with Uniswap's TickMath and FullMath libraries? - How does the application ensure compliance with Solidity version specifics regarding unchecked? - Are there any safety concerns with the current usage of unchecked? SCSVS-COMM-1 S5.1.G13 No Test ID Verify protection against Slot0 manipulation. - Is pool.slot0 used for calculating sensitive information like current price and exchange rates? - What alternatives are used for sensitive calculations to avoid manipulation risks? - Are secure mechanisms like UniswapV3 TWAP or Chainlink Price Oracle used for price and rate calculations? SCSVS-COMM-1 S5.1.G14 No Test ID Verify removal of hardcoded fee tiers. - Is there a hard-coded fee tier parameter in swap functions? - Can users specify the fee tier parameter when initiating Uniswap V3 swaps? - What impact does hard-coding the fee tier have on swap functionality? SCSVS-COMM-2 S5.2.G1 No Test ID Verify Untrusted External Contract Calls - Are there any state changes after interactions with untrusted external contracts? Verify if these interactions are securely managed. - Does the contract use the check-effects-interactions pattern or reentrancy guards to handle external contract calls? - How does the protocol handle potential issues arising from external contract callbacks, such as multiple withdrawals or event order? SCSVS-COMM-2 S5.2.G2 No Test ID Verify Input Validation - Are all function inputs validated for type, range, and format before processing? - Is there validation logic for boundary values and unexpected input scenarios? - Are there checks in place to prevent unauthorized or malicious data from being processed? SCSVS-COMM-2 S5.2.G3 No Test ID Verify Output Validation - Are outputs validated for correctness and consistency before being returned or used? - Does the contract include checks to ensure outputs do not introduce security vulnerabilities or logical errors? - Is there validation to confirm that outputs are within expected ranges and formats? SCSVS-COMM-2 S5.2.G4 No Test ID Verify Price Manipulation Vectors - How does the protocol obtain asset prices? Verify if the method is susceptible to manipulation through flash loans or donations. - Are there external or decentralized price oracles used to mitigate risks associated with price manipulation? - Does the contract include mechanisms to verify the accuracy and integrity of price data? SCSVS-COMM-3 S5.3.G1 No Test ID Verify Arbitrary Input and Low-Level Calls - Are all low-level calls restricted or validated to prevent exploitation with arbitrary user input? - Does the contract include checks to ensure that arbitrary data used in low-level calls does not lead to unintended behavior? - Is there a mechanism to sanitize and validate user input before passing it to low-level calls? SCSVS-COMM-3 S5.3.G2 No Test ID Verify External Contract Interaction Safety - Does the contract use the check-effects-interactions pattern to ensure safe interactions with external contracts? - Are there fallback mechanisms in place to handle failures or unexpected results from external contract interactions? - How does the contract ensure that external dependencies do not affect its core functionality or state? <p></p> <p></p>","tags":[]},{"location":"checklists/SCSVS-COMP/","title":"SCSVS-COMP","text":"<p>Temporary Checklist</p> <p>This checklist contains the SCSVS v0.0.1 verification levels (L1, L2 and L3) which we are currently reworking into \"security testing profiles\". The levels were assigned according to the SCSVS v1 ID that the test was previously covering and might differ in the upcoming version of the SCSTG and SCS Checklist.</p> <p>For the upcoming of the SCSTG version we will progressively split the SCSTG tests into smaller tests, the so-called \"atomic tests\" and assign the new SCS profiles to their respective SCWE weaknesses.</p> SCG ID VR ID TEST ID Control / SCSTG Test Checklist SCSVS-COMP-1 S11.1.G1 No Test ID Verify validation of zero price transactions. - Does the protocol validate that the returned price from the price feed is non-zero? - What safeguards are in place to handle zero or invalid price values? - How does the protocol ensure that price feeds do not return zero values that could affect operations? SCSVS-COMP-1 S11.1.G2 No Test ID Verify accuracy of price update time validation. - Does the protocol validate the last update timestamp of the price feed to ensure it is within an acceptable delay? - What mechanisms are in place to compare the price feed's update time against predefined maximum delays? - How does the protocol handle outdated price feeds to prevent inaccuracies in price usage? SCSVS-COMP-1 S11.1.G3 No Test ID Verify enforcement of rollup sequencer validation. - Does the protocol validate the operational status of the rollup sequencer to ensure it is online? - Is there a method to check if the rollup sequencer is running to prevent stale price issues? - How does the protocol handle the scenario where the rollup sequencer is offline? SCSVS-COMP-1 S11.1.G4 No Test ID Verify security of TWAP period calculations. - Can the TWAP period be adjusted to mitigate risks of price manipulation? - If the TWAP period is set, does it align with the protocol\u2019s requirements for accurate price updates? - Are there mechanisms in place to adjust the TWAP period based on identified manipulation risks? SCSVS-COMP-1 S11.1.G5 No Test ID Verify consistency of price feeds across chains. - Does the desired price feed pair consistently appear across all deployed chains? - If there is a process to verify price feed pairs, is it effective in maintaining consistency across chains? - Are there checks in place to ensure that price feed pairs remain uniform across all chains? SCSVS-COMP-1 S11.1.G6 No Test ID Verify appropriateness of price feed heartbeat intervals. - Is the heartbeat of the price feed appropriate for the protocol\u2019s specific use case? - If the price feed heartbeat is set, does it meet the operational needs of the protocol? - Are there controls to ensure the price feed heartbeat aligns with the protocol\u2019s requirements? SCSVS-COMP-1 S11.1.G7 No Test ID Verify suitability of price feeds for financial operations. - Are the price feeds accurately matched to the underlying assets they represent? - If using a price feed, does it correctly reflect the value of the underlying asset? - Are there checks to ensure the appropriateness of the price feeds for the underlying assets? SCSVS-COMP-1 S11.1.G8 No Test ID Verify security of AMM spot price calculations. - Can the protocol be manipulated through AMM spot prices, especially with flash loans? - If spot prices from AMMs are used, are there additional checks to prevent manipulation? - Are there safeguards to ensure the reliability of price data from AMMs? SCSVS-COMP-1 S11.1.G9 No Test ID Verify mitigation of flash crash price inaccuracies. - Does the system have measures to handle inaccuracies in price feeds during flash crashes? - If a flash crash occurs, are price feed values validated to be within an acceptable range? - Are there safeguards to manage potential flash crash vulnerabilities in price feeds? SCSVS-COMP-1 S11.1.G10 No Test ID Verify secure usage of LzApp functions. - Is the _lzSend function correctly utilized in place of direct lzEndpoint.send calls? - Are there vulnerabilities associated with using direct calls to lzEndpoint.send? - How does the protocol ensure proper usage of _lzSend? SCSVS-COMP-1 S11.1.G11 No Test ID Verify correct LayerZero user application configurations. - Is the ILayerZeroUserApplicationConfig interface implemented correctly? - Does the implementation include the forceResumeReceive function? - How does the system handle unexpected scenarios that require unblocking the message queue? SCSVS-COMP-1 S11.1.G12 No Test ID Verify security of default contract configurations. - Are default configuration contracts used in the application? - What steps are taken to ensure applications are configured uniquely? - How are default settings avoided in the contract configuration? SCSVS-COMP-1 S11.1.G13 No Test ID Verify correct handling of refunds for failed orders. - Does the protocol issue refunds for failed or partially filled orders? - What mechanisms are in place to handle refunds after swaps? - Are there clear procedures for managing failed or incomplete transactions? SCSVS-COMP-1 S11.1.G14 No Test ID Ensure ERC20 Decimal Compatibility - Can the protocol handle ERC20 tokens with decimals other than 18? - Are there mechanisms in place to adjust for different decimal configurations of ERC20 tokens? SCSVS-COMP-1 S11.1.G15 No Test ID Ensure ERC20 Token Compatibility - Does the protocol support all kinds of ERC20 tokens? - Is there a whitelist or compatibility check for ERC20 tokens? - Are there any unsupported token types clearly documented? SCSVS-COMP-1 S11.1.G16 No Test ID Verify Reorg Vulnerability with CREATE - Does the contract deployment process use CREATE2 instead of CREATE to ensure contract stability across block reorgs? - Is there a fallback mechanism in place to handle contract creation failures due to block reorgs? - Has the protocol been tested for resilience against block reorgs affecting contract creation? SCSVS-COMP-1 S11.1.G17 No Test ID Validate Token Decimal Handling - Does the AMM handle tokens with varying decimal places and types correctly? - Have you verified compatibility with tokens of different decimal configurations? - Is there validation for token types and decimal places before processing? SCSVS-COMP-1 S11.1.G18 No Test ID Ensure Fee-On-Transfer Token Support - Does the AMM support fee-on-transfer tokens? - Have you accounted for discrepancies between the sent and received amounts with fee-on-transfer tokens? - Is there functionality to handle or adjust for fee-on-transfer tokens appropriately? SCSVS-COMP-1 S11.1.G19 No Test ID Handle Rebasing Token Effects - Does the AMM support rebasing tokens? - Have you accounted for changes in balance due to rebasing tokens? - Is there functionality to correctly handle rebasing tokens and their balance changes? SCSVS-COMP-1 S11.1.G20 No Test ID Mitigate ERC4626 Flashloan Manipulation - Can ERC4626 be manipulated through flashloans? - Are there protections in place against flashloan attacks in ERC4626-related operations? - Is the protocol aware of flashloan risks and has it implemented safeguards? SCSVS-COMP-1 S11.1.G21 No Test ID Analyze Risks in Forked Code - Is the AMM using code forked from known projects? - Have you reviewed the forked code for known vulnerabilities? - Is there a comparison of the forked code against the original to identify potential security issues? <p></p> <p></p>","tags":[]},{"location":"checklists/SCSVS-CRYPTO/","title":"SCSVS-CRYPTO","text":"<p>Temporary Checklist</p> <p>This checklist contains the SCSVS v0.0.1 verification levels (L1, L2 and L3) which we are currently reworking into \"security testing profiles\". The levels were assigned according to the SCSVS v1 ID that the test was previously covering and might differ in the upcoming version of the SCSTG and SCS Checklist.</p> <p>For the upcoming of the SCSTG version we will progressively split the SCSTG tests into smaller tests, the so-called \"atomic tests\" and assign the new SCS profiles to their respective SCWE weaknesses.</p> SCG ID VR ID TEST ID Control / SCSTG Test Checklist SCSVS-CRYPTO-1 S6.1.G1 No Test ID Verify protection against reentrancy in reward withdrawals. - Does the reward or withdrawal code of the protocol handle ETH transfers or NFT minting in a manner that prevents re-entrancy attacks? - Are all state changes completed before external calls to prevent re-entrancy vulnerabilities? - Can re-entrancy be exploited in the reward distribution or withdrawal process due to improper sequencing of operations? SCSVS-CRYPTO-1 S6.1.G2 No Test ID Verify EVM opcode compatibility. - Are the EVM opcodes and operations used by the protocol compatible across all targeted chains? - What steps are taken to ensure compatibility with chains like Arbitrum and Optimism? - How does the system handle unsupported EVM operations? SCSVS-CRYPTO-2 S6.2.G1 No Test ID Verify Failed Transaction Replay Protection - Is there a mechanism in place to prevent replay attacks on failed transactions? Verify the use of nonces or other protections. - How does the contract ensure that each transaction can only be executed once, even if it fails initially? - Are there specific measures to differentiate between unique and replayed transactions? SCSVS-CRYPTO-2 S6.2.G2 No Test ID Verify Signature Replay Protection - Is there a protection mechanism to prevent signatures from being replayed on different chains? Verify the use of domain separators or chain-specific parameters. - How does the protocol ensure that signatures are only valid on the intended chain? - Are there safeguards to prevent cross-chain replay attacks on signed transactions? SCSVS-CRYPTO-2 S6.2.G3 No Test ID Verify Event Emitting on State Change - Are events emitted for all critical state changes and function executions to ensure traceability? - Is there a comprehensive list of all state-changing functions that should emit events? - Does the contract's event logging cover edge cases and error scenarios effectively? <p></p> <p></p>","tags":[]},{"location":"checklists/SCSVS-DEFI/","title":"SCSVS-DEFI","text":"<p>Temporary Checklist</p> <p>This checklist contains the SCSVS v0.0.1 verification levels (L1, L2 and L3) which we are currently reworking into \"security testing profiles\". The levels were assigned according to the SCSVS v1 ID that the test was previously covering and might differ in the upcoming version of the SCSTG and SCS Checklist.</p> <p>For the upcoming of the SCSTG version we will progressively split the SCSTG tests into smaller tests, the so-called \"atomic tests\" and assign the new SCS profiles to their respective SCWE weaknesses.</p> SCG ID VR ID TEST ID Control / SCSTG Test Checklist SCSVS-DEFI-1 S10.1.G1 No Test ID Verify accuracy of gas estimation. - Is gas estimated accurately for cross-chain messages? - What measures are in place to validate gas estimates? - Can inaccuracies in gas estimation lead to message failures? SCSVS-DEFI-1 S10.1.G2 No Test ID Verify enforcement of input data validation. - Is there validation on the size of the input data? - How does the system handle input data that exceeds the expected size? - Are there measures to revert or clean unused bits if data size is invalid? SCSVS-DEFI-1 S10.1.G3 No Test ID Verify security of gas fee mechanisms. - Is there a risk of exploiting low gas fees to execute a high volume of transactions? - What measures are in place to mitigate potential attacks associated with low gas fees? - How does the system address issues related to transaction volume and gas costs? SCSVS-DEFI-1 S10.1.G4 No Test ID Verify consistency in block production timing. - Is block production consistency ensured in the protocol? - How does the system handle potential inconsistencies in block production? - What measures are in place to address unexpected application behaviors due to block production variability? SCSVS-DEFI-1 S10.1.G5 No Test ID Verify Slippage Protection - Does the protocol include slippage protection mechanisms for user transactions? Verify if users can set a minimum output amount. - How does the contract handle price manipulation risks from front-running attacks? - Are there any controls in place to prevent attackers from exploiting slippage to benefit from user transactions? SCSVS-DEFI-1 S10.1.G6 No Test ID Verify Transaction Gas Limit - Is there a possibility of iterating over a huge array in a single transaction? Verify the gas usage and limits associated with such operations. - How does the contract handle scenarios where the gas limit might be exceeded due to large-scale operations? - Are there safeguards or limits in place to prevent transactions from exceeding the block gas limit? <p></p> <p></p>","tags":[]},{"location":"checklists/SCSVS-GOV/","title":"SCSVS-GOV","text":"<p>Temporary Checklist</p> <p>This checklist contains the SCSVS v0.0.1 verification levels (L1, L2 and L3) which we are currently reworking into \"security testing profiles\". The levels were assigned according to the SCSVS v1 ID that the test was previously covering and might differ in the upcoming version of the SCSTG and SCS Checklist.</p> <p>For the upcoming of the SCSTG version we will progressively split the SCSTG tests into smaller tests, the so-called \"atomic tests\" and assign the new SCS profiles to their respective SCWE weaknesses.</p> SCG ID VR ID TEST ID Control / SCSTG Test Checklist SCSVS-GOV-1 S3.1.G1 No Test ID Verify correct handling of operational pauses and liquidations. - Does the protocol prevent liquidations during operational pauses or interruptions? - Are there mechanisms to handle user intentions to increase collateral during such pauses? - How does the system manage collateral and liquidation processes during temporary pauses? SCSVS-GOV-1 S3.1.G2 No Test ID Verify resumption of paused liquidations without issues. - What specific procedures are in place for resuming liquidations after a pause? - How is solvency monitored and maintained during and after a liquidation pause? - Are there mechanisms to ensure that resumed liquidations do not disrupt system stability? SCSVS-GOV-1 S3.1.G3 No Test ID Verify fair distribution of small position incentives. - Does the protocol provide adequate incentives for liquidators to address small positions? - How are incentives structured to ensure small positions are effectively managed? - Are there measures in place to prevent neglect of small liquidation opportunities? SCSVS-GOV-1 S3.1.G4 No Test ID Verify correct interest rate calculations in LTV computations. - Is accrued interest included in the Loan-to-Value (LTV) calculations? - How does the system ensure that interest is factored into credit evaluations accurately? - Are there checks to confirm that interest calculations do not affect LTV assessments? SCSVS-GOV-1 S3.1.G5 No Test ID Verify consistency in liquidation and repayment logic. - Can the liquidation and repaying mechanisms be independently enabled or disabled? - What controls are in place to ensure consistent operation of both mechanisms? - How does the protocol prevent operational discrepancies between liquidation and repaying functions? SCSVS-GOV-1 S3.1.G6 No Test ID Verify accuracy of liquidation return calculations. - Is there a mechanism to ensure that liquidation returns are consistent and predictable? - How does the protocol handle discrepancies in liquidation returns? - What steps are taken to ensure that liquidators receive the expected returns? SCSVS-GOV-1 S3.1.G7 No Test ID Verify mitigation of perpetual debt risks. - Can users be trapped in perpetual debt due to protocol conditions or system design? - What safeguards are in place to prevent users from being unable to repay their loans? - How does the protocol address situations where repayment becomes unfeasible? SCSVS-GOV-1 S3.1.G8 No Test ID Verify prevention of arbitrary exchange rate settings in withdrawals. - Can an arbitrary exchange rate be set during the processing of queued withdrawals? - Does the protocol ensure that the exchange rate used during withdrawal matches the rate at the time of withdrawal request? - Are there safeguards to prevent manipulation of the exchange rate during withdrawal processing? SCSVS-GOV-1 S3.1.G9 No Test ID Verify security of time lock amplification. - Can users extend another user\u2019s time lock duration by stacking tokens on their behalf? - If token stacking is possible, are there checks to prevent unintended extensions of time locks? - Are there controls to ensure that time locks cannot be manipulated through token stacking? SCSVS-GOV-1 S3.1.G10 No Test ID Verify fairness of reward distribution mechanisms. - Can reward distribution be manipulated to delay or accelerate payouts? - If rewards are distributed, are there controls to ensure timely and correct distribution? - Are there mechanisms to prevent premature or delayed reward claims? SCSVS-GOV-1 S3.1.G11 No Test ID Verify security of update rewards function. - Does the updateRewards function get called appropriately before relevant operations? - Can the reward update function be overlooked or missed in any use-case scenarios? - Are there checks to ensure that rewards are up-to-date in all relevant cases? SCSVS-GOV-1 S3.1.G12 No Test ID Verify financial operation consistency. - Does calling a function multiple times with smaller amounts produce the same contract state as calling it once with the aggregate amount? - Are there inconsistencies or unintended discrepancies when performing financial operations in parts versus as a whole? - If variations exist, are they intentional and well-documented, or do they indicate potential issues? SCSVS-GOV-1 S3.1.G13 No Test ID Verify correct enforcement of AAVE protocol pauses. - What happens to protocol interactions if the AAVE protocol is paused? - Are there contingency plans or alternative mechanisms in place if AAVE is paused? - Does the protocol handle the paused state of AAVE without causing disruptions? SCSVS-GOV-1 S3.1.G14 No Test ID Verify removal of deprecated pools. - What mechanisms are in place to handle pools that become deprecated? - If a pool is deprecated, how does the protocol adjust or manage its operations? - Are there fallback strategies for deprecated pools to avoid service interruptions? SCSVS-GOV-1 S3.1.G15 No Test ID Verify correct classification of eMode category assets. - What are the rules or limitations when lending or borrowing assets within the same eMode category? - Does the protocol handle transactions involving assets in the same eMode category without issues? - Are there constraints in place for interacting with assets in the same eMode category? SCSVS-GOV-1 S3.1.G16 No Test ID Verify accuracy of flash loan pool index calculations. - Do flash loans impact the pool index, and if so, how is this managed? - Are there mechanisms to mitigate the effects of flash loans on the pool index? - How does the protocol address the maximum number of flash loans per block affecting the pool index? SCSVS-GOV-1 S3.1.G17 No Test ID Verify correct implementation of on-chain slippage calculations. - Is slippage calculated on-chain? - Can users specify the slippage parameter in the asset amount? - What measures are in place to ensure accurate slippage calculation? SCSVS-GOV-1 S3.1.G18 No Test ID Verify minimization of intermediate swap slippage. - Is the slippage parameter enforced at the last step before transferring funds to users? - How is slippage enforced during the final fund transfer step? - Does the system check the slippage parameter before completing transactions? SCSVS-GOV-1 S3.1.G19 No Test ID Verify enforcement of zero denominator checks. - Is there a non-zero check for the denominator before division or modulo operations? - How does the system handle division or modulo by zero in Yul/inline assembly? - What measures are in place to prevent division or modulo by zero? SCSVS-GOV-1 S3.1.G20 No Test ID Verify Two Transaction Actions Frontrunning - Are two-transaction actions designed with measures to prevent frontrunning? Verify if there are checks or locks between transactions. - How does the protocol ensure that critical two-step actions are not vulnerable to attack during the intermediary state? - Are there safeguards to prevent malicious actors from intervening between the two transactions? SCSVS-GOV-1 S3.1.G21 No Test ID Verify Dust Transactions Reversion - Can users front-run transactions with negligible amounts to cause reverts? Verify the contract\u2019s handling of such scenarios. - Are there checks to prevent transactions with minimal amounts from impacting the contract's state or execution flow? - How does the contract manage or mitigate the effects of dust transactions on legitimate operations? SCSVS-GOV-1 S3.1.G22 No Test ID Verify Unexpected Rewards Handling - Are there additional rewards accruing for user deposited assets? - Does the protocol track and manage all potential rewards for user deposits? - Are users provided with clear methods to claim or manage unexpected rewards? SCSVS-GOV-1 S3.1.G23 No Test ID Ensure Stability for Pegged Tokens - Are the protocol tokens pegged to any other asset? - Have you tested the protocol\u2019s behavior when the pegged asset depegs? SCSVS-GOV-1 S3.1.G24 No Test ID Verify Visibility Modifier - Is the visibility of each function limited to the strictest level necessary (private or internal)? - Are there any functions that are currently public or external but could be restricted to internal or private? - Does the contract expose any sensitive operations or state changes to external parties that should be restricted? SCSVS-GOV-2 S3.2.G1 No Test ID Verify ERC20 Compliance - Are the token's transfer functions (transfer, transferFrom) fully compliant with the EIP20 standard, including returning a boolean flag and reverting on failure? - Are safe transfer functions (safeTransfer, safeTransferFrom) consistently used throughout the contract? SCSVS-GOV-2 S3.2.G2 No Test ID Verify Approval Race Condition - Is there a risk of race conditions in the approval process that could lead to unexpected fund loss for the signer? - Are there mechanisms in place to prevent double-spending or front-running attacks? SCSVS-GOV-2 S3.2.G3 No Test ID Verify Decimal Discrepancies - Could differences in the number of decimals between various ERC20 tokens lead to calculation or interpretation errors? - Are there any conversions or calculations that might be affected by differing decimal places? SCSVS-GOV-2 S3.2.G4 No Test ID Verify Caller Checking - Does the function restrict calls to only externally owned accounts (EOA) or only contract addresses as intended? - Are there access control checks in place to differentiate between EOA and contract callers when required? - Has the protocol been reviewed to ensure it meets the intended caller requirements? SCSVS-GOV-2 S3.2.G5 No Test ID Verify Address Checks - Does the token implement any forms of address whitelisting, blacklisting, or validation checks that could introduce issues? - Are there any hardcoded addresses in the contract that could pose security risks? SCSVS-GOV-2 S3.2.G6 No Test ID Verify Transfer Fees - Does the token impose a fee on transfers, resulting in the receiver getting less than the specified amount? - How are transfer fees calculated and collected? SCSVS-GOV-2 S3.2.G7 No Test ID Verify ERC777 Compatibility - Can the token also function as an ERC777 token, which includes hooks that execute code before and after transfers, potentially leading to reentrancy attacks? - Are there safeguards in place to handle the hooks securely? SCSVS-GOV-2 S3.2.G8 No Test ID Verify Solmate's ERC20.safeTransferLib Usage - Does the protocol utilize Solmate's ERC20.safeTransferLib, which does not check for the existence of a contract and could be exploited for honeypot attacks? - Are there alternative libraries or methods that could enhance security? SCSVS-GOV-2 S3.2.G9 No Test ID Verify Zero Amount Transfers - What is the token's behavior when transferring a zero amount? Does it revert, and could this cause issues in certain integrations and operations? - Are there any edge cases related to zero-amount transfers? SCSVS-GOV-2 S3.2.G10 No Test ID Verify ERC2612 Implementation - Is the token an ERC2612 implementation, and is the DOMAIN_SEPARATOR() function properly implemented to avoid vulnerabilities? - How is the permit() function implemented, and are there any potential issues? SCSVS-GOV-2 S3.2.G11 No Test ID Verify Permit Function Replay Protection - Does the permit() function have adequate replay protection, or could someone reuse a permit signature multiple times to authorize multiple transfers? - Is the nonces mapping updated correctly, and does the implementation properly prevent replays? SCSVS-GOV-3 S3.3.G1 No Test ID Verify Token Donation Manipulation - Does the contract rely on balance or balanceOf for determining token balances or ownership? If so, are there safeguards against manipulation through token donations? - Are token balances verified against internal accounting records rather than solely using balanceOf? - Does the contract implement additional validation to ensure donated tokens do not alter accounting in unexpected ways? SCSVS-GOV-3 S3.3.G2 No Test ID Detect On-Chain Slippage Manipulation - Is slippage calculated directly on-chain? - Can the slippage calculation be influenced or manipulated by attackers? - Is there a mechanism to allow users to specify slippage based on off-chain calculations? SCSVS-GOV-3 S3.3.G3 No Test ID Ensure Slippage is Enforced at All Stages - Is the slippage parameter enforced at all stages of the swap process, including the final step? - Can users receive less than the specified minimum if the final step does not enforce slippage? SCSVS-GOV-3 S3.3.G4 No Test ID Verify Initial Deposit Behavior - Does the initial deposit set parameters or conditions for subsequent deposits? - Have you tested to ensure that the first deposit initializes parameters correctly? SCSVS-GOV-3 S3.3.G5 No Test ID Verify Read-Only Reentrancy - Are there view functions that could be reentered in a way that might return stale or inconsistent values? - Does the contract have measures to prevent reentrancy issues in view functions, such as extending reentrancy guards? - How does the protocol ensure that read-only functions do not lead to inconsistent state or unintended actions? SCSVS-GOV-3 S3.3.G6 No Test ID Prevent Flashloan-Based Withdrawals - Is it possible to withdraw in the same transaction as the deposit? - Does the protocol have protections against flashloan-based deposit-harvest-withdraw cycles? SCSVS-GOV-3 S3.3.G7 No Test ID Ensure Liquidation Resilience in Volatile Markets - Does the liquidation mechanism include logic to handle extreme price drops effectively? - Is there a safeguard to ensure liquidation occurs even when price volatility is high? - How is the liquidation trigger threshold adjusted during rapid market downturns? SCSVS-GOV-3 S3.3.G8 No Test ID Manage Risks in Liquidation Processes - Is there a mechanism to automatically trigger liquidation if a position's collateral falls below the required threshold? - Are there specific conditions that can prevent liquidation, and how are these managed? - How does the system handle outstanding loans when the collateral value drops significantly? SCSVS-GOV-3 S3.3.G9 No Test ID Prevent Self-Liquidation Abuse - Is there validation to prevent users from exploiting self-liquidation for profit? - How are self-liquidation scenarios tested for potential vulnerabilities? - Are there limits or conditions imposed on self-liquidation to prevent abuse? SCSVS-GOV-3 S3.3.G10 No Test ID Verify Parent Contract Visibility - Have you reviewed the visibility of functions in parent contracts to ensure they are appropriately exposed? - Are there any public or external functions in parent contracts that should be restricted or hidden in the derived contract? - Is the visibility of inherited functions aligned with the desired access levels? SCSVS-GOV-3 S3.3.G11 No Test ID Verify Commit Reveal Scheme - Does the protocol implement a commit-reveal scheme to protect against front-running? Verify the presence of both commit and reveal phases. - How does the protocol ensure that the commit-reveal pattern is followed to prevent adversaries from gaining insight into actions before they are finalized? - Are there mechanisms in place to ensure confidentiality and integrity of actions until the reveal phase? SCSVS-GOV-3 S3.3.G12 No Test ID Ensure Dynamic Slippage Implementation - Is slippage implemented as a hardcoded value in the contract? - Have you ensured that slippage can be adjusted dynamically based on market conditions? - Is there functionality allowing users to specify slippage parameters based on their own calculations? SCSVS-GOV-3 S3.3.G13 No Test ID Validate Deadline Protection Mechanisms - Does the protocol implement deadline protection to prevent transactions from being manipulated? - Is there an option for users to set deadlines for their transactions? - Have you validated that transactions cannot be processed outside the specified deadline? SCSVS-GOV-3 S3.3.G14 No Test ID Ensure Proper Reserve Validation - Is there a validation check in place for protocol reserves? - Have you ensured that reserves are verified before being used or lent out? - Does the protocol include mechanisms to safeguard against reserve depletion? SCSVS-GOV-3 S3.3.G15 No Test ID Ensure Slippage Protection - Is there a mechanism to protect against excessive slippage in trades? - Can users specify their own slippage parameters to manage risk? - Are there safeguards to prevent losses from large price deviations? SCSVS-GOV-3 S3.3.G16 No Test ID Ensure Reliable Min Amount Out Calculation - Does the protocol calculate minAmountOut before executing swaps? - Is the source of rates for minAmountOut reliable and protected from manipulation? - Have you validated the minAmountOut logic to prevent unfavorable rates and potential vulnerabilities? <p></p> <p></p>","tags":[]},{"location":"checklists/SCSVS-ORACLE/","title":"SCSVS-ORACLE","text":"<p>Temporary Checklist</p> <p>This checklist contains the SCSVS v0.0.1 verification levels (L1, L2 and L3) which we are currently reworking into \"security testing profiles\". The levels were assigned according to the SCSVS v1 ID that the test was previously covering and might differ in the upcoming version of the SCSTG and SCS Checklist.</p> <p>For the upcoming of the SCSTG version we will progressively split the SCSTG tests into smaller tests, the so-called \"atomic tests\" and assign the new SCS profiles to their respective SCWE weaknesses.</p> SCG ID VR ID TEST ID Control / SCSTG Test Checklist SCSVS-ORACLE-1 S7.1.G1 No Test ID Verify security of lending and borrowing the same token. - Are there constraints to prevent lending and borrowing the same token within a single transaction? - How does the protocol handle rapid price changes or flash loans involving the same token? - What measures are in place to prevent manipulation by exploiting lend-borrow actions? SCSVS-ORACLE-1 S7.1.G2 No Test ID Verify minimization of precision loss in calculations. - Does the protocol avoid precision loss in deposit, withdrawal, and reward calculations? - Are there any instances of division before multiplication or rounding errors that could affect calculations? - How does the protocol handle precision and rounding to prevent inaccuracies in financial operations? SCSVS-ORACLE-1 S7.1.G3 No Test ID Verify decimal precision consistency. - Can variations in decimal precision from different price feeds lead to inaccuracies? - If decimal precision varies, does the contract handle these variations correctly? - Are there measures to standardize decimal precision across different price feeds? SCSVS-ORACLE-1 S7.1.G4 No Test ID Verify avoidance of off-by-one errors. - Can off-by-one errors occur in the contract, such as using &lt;= instead of &lt;? - If variables are set to the length of a list or the length minus one, is this done correctly? - Are there any potential off-by-one errors in iterations or boundary conditions? SCSVS-ORACLE-1 S7.1.G5 No Test ID Verify prevention of rounding errors. - Are there rounding errors that can be magnified or cause significant issues? - If rounding errors occur, can they be amplified through repeated function invocations or specific conditions? - Are there safeguards to prevent rounding errors from adversely affecting the system or its users? SCSVS-ORACLE-1 S7.1.G6 No Test ID Verify secure reward claims implementation. - Does the protocol properly implement AAVE/COMP reward claims? - Are there any discrepancies in the implementation of reward claims for AAVE/COMP? - How is the accuracy of reward claims ensured and tested? SCSVS-ORACLE-1 S7.1.G7 No Test ID Verify correct handling of request confirmation numbers. - Is the request confirmation number chosen high enough to account for potential chain re-orgs? - What considerations are made to evaluate the chain's vulnerability to re-orgs? - Are there adjustments made to the request confirmation number based on re-org risk assessments? SCSVS-ORACLE-1 S7.1.G8 No Test ID Verify front-running protections for VRF calls. - Are there measures implemented to prevent frontrunning of VRF calls? - How does the protocol ensure user interactions are closed before initiating a VRF call? - What safeguards are in place to prevent exploitation of VRF call timing? SCSVS-ORACLE-1 S7.1.G9 No Test ID Verify correct nonce increments in exec transactions. - Does the execTransactionFromModule() function increment the nonce appropriately? - What mechanisms are in place to ensure the nonce is incremented? - Can issues arise if the nonce is not incremented in this function? SCSVS-ORACLE-1 S7.1.G10 No Test ID Verify enforcement of Ethereum Beacon Chain penalties. - Does the application account for potential penalties or slashes from validator misbehavior? - How are these potential penalties or slashes reflected in the value of rETH? - Are there mechanisms to manage or mitigate the impact of such penalties on rETH? SCSVS-ORACLE-1 S7.1.G11 No Test ID Verify secure management of staking rewards. - How does the system manage rewards accrued from staking? - Are these rewards properly accounted for in the management of rETH? - What mechanisms are in place to ensure accurate distribution of staking rewards? SCSVS-ORACLE-1 S7.1.G12 No Test ID Verify correct handling of Rocket Pool deposit burns. - Does the system handle potential reverts in the burn() function when there is insufficient ether in the RocketDepositPool? - Is there a mechanism to prevent or manage failures in the burn() function? - Can the application gracefully handle a revert due to insufficient ether? SCSVS-ORACLE-1 S7.1.G13 No Test ID Verify validation of precompiled code return sizes. - Is there a check on the return data size when calling precompiled code? - How does the system handle calls to precompiled code that return a size of 0? - What checks are in place for detecting failures in precompiled code calls? SCSVS-ORACLE-1 S7.1.G14 No Test ID Verify Variable Bounds Handling - Have you ensured that variables do not exceed their bounds and cause reverts, even in versions greater than 0.8.0? - Are there explicit checks to prevent variable underflows and overflows in all critical operations? - Is there any logic to handle boundary conditions for variables to avoid unintended reverts? SCSVS-ORACLE-1 S7.1.G15 No Test ID Ensure Correct Handling of Unsigned Integer Values - Are you aware of and have you ensured that unsigned integers are never assigned negative values? - Is there validation in place to prevent negative values from being assigned to unsigned integers? - Have you reviewed all assignments to ensure that only non-negative values are used for unsigned integers? SCSVS-ORACLE-1 S7.1.G16 No Test ID Verify Unchecked Blocks Usage - Have you reviewed all usages of the unchecked{} block to ensure they are applied correctly? - Is there a clear guarantee that no overflow or underflow occurs within unchecked{} blocks? - Are there sufficient tests to confirm that operations inside unchecked{} blocks do not cause unintended behavior? SCSVS-ORACLE-1 S7.1.G17 No Test ID Prevent Time Units Overflow - Does the contract use time units (like days) and handle them as uint8? - Have you verified that all calculations involving time units are checked for potential overflow, considering their range? - Are there safeguards in place to prevent overflow in time-related calculations using uint8? SCSVS-ORACLE-2 S7.2.G1 No Test ID Verify Low Decimal Token Handling - Does the contract handle tokens with low decimal precision appropriately? Verify if rounding issues are addressed. - Are there checks to ensure that transactions involving low decimal tokens do not result in unintended failures or errors? - How does the contract handle rounding or precision issues to maintain accurate token transactions? SCSVS-ORACLE-2 S7.2.G2 No Test ID Verify Precision in Summation - Is the summing of variables done accurately compared to separate calculations? Verify the approach used for summation. - How does the contract handle precision issues in financial calculations or other critical computations? - Are there tests in place to verify the accuracy of summation logic and address any discrepancies? SCSVS-ORACLE-2 S7.2.G3 No Test ID Verify Mathematical Calculation Accuracy - Have all mathematical calculations been reviewed to ensure accuracy and adherence to established rules? - Is there a clear and documented approach to handle mathematical operations in the contract? - Are there any potential sources of error or miscalculation that need to be addressed? SCSVS-ORACLE-2 S7.2.G4 No Test ID Verify Handling of Precision Loss - Is there potential for loss of precision in any calculations, especially those involving frequent or large numbers? - Are appropriate data types used to minimize precision loss and ensure accurate results? - Have rounding methods and precision handling been correctly applied and verified? SCSVS-ORACLE-2 S7.2.G6 No Test ID Verify Safe Data Type Conversion - Have you verified that expressions like 1 day are explicitly cast to avoid unintended conversions (e.g., to uint24)? - Are there any expressions in the contract where implicit type conversions could lead to unexpected behavior or overflow? - Is type conversion handled explicitly to prevent data loss or overflow issues? SCSVS-ORACLE-2 S7.2.G7 No Test ID Verify Multiplication Before Division - Does the contract ensure that multiplication occurs before division in calculations to preserve precision? - Are there any instances where division is performed before multiplication, potentially causing precision loss? - Have you reviewed all calculations to confirm that multiplication precedes division where necessary? SCSVS-ORACLE-2 S7.2.G8 No Test ID Verify Correct Rounding Direction - Is the rounding direction considered and correctly applied in accounting operations? - Does the rounding direction align with the protocol\u2019s requirements and user share calculations? - Have you verified that rounding is handled consistently across all relevant operations? SCSVS-ORACLE-2 S7.2.G9 No Test ID Verify Division by Zero Protection - Is there a check in place to prevent division by zero in any calculations? - Have you reviewed all divisions to ensure that denominators are never zero? - Are there safety checks implemented to handle potential division by zero scenarios? SCSVS-ORACLE-2 S7.2.G10 No Test ID Check for Correct Inequality Usage - In comparisons involving &lt; or &gt;, have you ensured that the correct operators (\u2264 or \u2265) are used where appropriate? - Are all edge cases covered to avoid unexpected behavior due to incorrect inequality operators? - Have you reviewed the logic to confirm that the appropriate comparison operators are applied? SCSVS-ORACLE-2 S7.2.G11 No Test ID Validate Inline Assembly Operations - Have you thoroughly tested and verified all mathematical operations performed in inline assembly? - Is there an awareness of how inline assembly handles division by zero, overflow, or underflow differently from high-level constructs? - Are there checks in place to handle potential issues with inline assembly operations? SCSVS-ORACLE-2 S7.2.G12 No Test ID Ensure Edge Case Coverage in Calculations - Have you tested calculations with minimum and maximum values for all terms to ensure accurate outcomes? - Are edge cases handled correctly to prevent unexpected results in complex calculations? - Is there a thorough review of calculations involving numerous terms to validate behavior with extreme values? SCSVS-ORACLE-2 S7.2.G13 No Test ID Validate Type Casting Operations - Is there any forced type casting in the contract? - Have you ensured that all forced type casting operations are validated to avoid overflow or underflow issues? - Is there a review of all type casting to confirm that values fall within the acceptable range for the target type? SCSVS-ORACLE-2 S7.2.G14 No Test ID Check for Rounding Errors in Calculations - Are rounding issues addressed in the AMM's product constant formulas? - Have you verified that rounding does not introduce inaccuracies in token swaps? - Is there a review of mathematical operations to ensure proper handling of rounding? <p></p> <p></p>","tags":[]},{"location":"contributing/1_How_Can_You_Contribute/","title":"How Can You Contribute?","text":"<p>You can directly contribute to the SCSVS or SCSTG in many different ways! First, go ahead and create a GitHub account for free on the GitHub homepage.</p>","tags":[]},{"location":"contributing/1_How_Can_You_Contribute/#contribution-flow","title":"Contribution Flow","text":"<pre><code>flowchart LR\n    A(Open Discussion) --&gt;|discuss| C{qualifies?}\n    C --&gt;|Yes| D(Issue)\n    C --&gt;|No| E[Close]\n    D --&gt;|open PR| F(Pull Request)\n    F --&gt;|review| G{approved?}\n    F --&gt;|make changes| F\n    G --&gt;|Yes| H[Merge]\n    G --&gt;|No| I[Close]</code></pre>","tags":[]},{"location":"contributing/1_How_Can_You_Contribute/#participate-in-discussions","title":"\ud83d\udcac Participate in Discussions","text":"<p>Our GitHub Discussions are the first place to go to ask questions, give feedback, and propose new ideas. If your proposal qualifies for the SCSTG/SCSVS, we'll convert it into an \"Issue\" (the discussion might take a while).</p>","tags":[]},{"location":"contributing/1_How_Can_You_Contribute/#create-issues","title":"\ud83c\udfaf Create Issues","text":"<p>Before creating a PR, first create an Issue to be discussed for missing requirements, content or errors.</p> <ul> <li>To avoid multiple people duplicating effort on the same issue, project leaders will assign it to only a few that will own it.</li> <li>Explain what you think is missing in the issue, including references (if available) and suggest where it could be added.</li> </ul>","tags":[]},{"location":"contributing/1_How_Can_You_Contribute/#open-a-pull-request","title":"\ud83d\udcdd Open a Pull Request","text":"<p>You can contribute with content or corrections by opening a Pull Request (PR).</p> <ul> <li>Your PR may be merged after review.</li> <li>Be sure to follow our style guide when writing content.</li> </ul> <p>Learn how to open a PR here.</p>","tags":[]},{"location":"contributing/1_How_Can_You_Contribute/#become-a-reviewer","title":"\u2705 Become a Reviewer","text":"<p>You can Review Pull Requests (PRs) and also gain contributions. If you are a fluent speaker in any of the different languages that the SCSVS is available in, feel free to give feedback on any of the submitted PRs.</p> <p>After your PR or issue has been submitted, we will review it as quickly as possible which typically only takes a few days. If you think we have forgotten about it, feel free to give us a nudge after 7 days have passed.</p> <p>Learn how to review a PR here.</p>","tags":[]},{"location":"contributing/1_How_Can_You_Contribute/#proof-reading","title":"\ud83d\udd0e Proof-reading","text":"<p>If you do proof-reading, these are the things we\u2019re looking for:</p> <ul> <li>Content cohesion &amp; coherence<ul> <li>is there a good linkage of ideas?</li> <li>does the paragraph make sense?</li> <li>does it make sense with the next one? Think that hundreds of people have written in here, often without considering the surroundings of the text they were including.</li> </ul> </li> <li>Reducing the content to a minimum (people tend to be very verbose/wordy) and in such a document we need clear and short/concise statements</li> <li>Optimize for scannability (maybe instead of a big paragraph it would be better to have a bullet point list).</li> <li>Any passive voice sentences? Convert to active voice.</li> <li>Does each paragraph focus on a single topic?</li> <li>Are key points stated at the start of each section?</li> <li>Are commas, parentheses, colons, em-dashes, and semicolons used properly?</li> </ul> <p>Refer to Google Technical Writing trainings for more info:</p> <ul> <li>Google Technical Writing One</li> <li>Google Technical Writing Two</li> </ul>","tags":[]},{"location":"contributing/2_Getting_Started/","title":"Getting Started","text":"<p>First of all Create a GitHub account (a free one is enough) by following these steps.</p> <p>Our workflow is like this:</p> <ol> <li>Open a Discussion (for ideas and proposals) If your proposal qualifies for the SCSTG/SCSVS we'll convert it into an \"Issue\" (the discussion might take a while).</li> <li>SCSVS Example: \"Add a SCSVS-CODE requirement on Key rotation\"</li> <li> <p>SCSTG Example: \"Add a Test case for key rotation\"</p> </li> <li> <p>Open an Issue (for concrete actionable things that have to / could be done) For instance, there's a typo, or it's clear that a certain Test case doesn't have e.g. \"Dynamic Analysis\" and it should be added.</p> </li> <li>Open a PR (to add actual content) This could be the fix for the mentioned typo, a whole new section or some other content. Usually a PR has a \"closes\" sentence in its description. For example \"Closes #543\" so that we (and GitHub) know which Issue(s) is being addressed on that PR.</li> </ol> <p>Normally, contributors should follow the whole flow. But sometimes it's clear what's needed so we directly go to 2 (open an issue) or even to 3 (open a PR). We recommend starting with a discussion or directly contacting us to save you the hurdle of writing and submitting new content that does not qualify so we have to reject it after the work is done.</p> <p>If you just have an specific question you can post it to (you need a GitHub Account):</p> <ul> <li>https://github.com/OWASP/www-project-smart-contract-security-verification-standard/discussions/categories/q-a</li> <li>https://github.com/OWASP/www-project-smart-contract-security-testing-guide/discussions/categories/q-a</li> </ul> <p>\"GitHub Discussions\" are re-posted to our Slack channel.</p> <p>Once you get your answer please mark it as answered. When you mark a question as an answer, GitHub will highlight the comment and replies to the comment to help visitors quickly find the answer.</p>","tags":[]},{"location":"contributing/2_Getting_Started/#contribute-online","title":"Contribute Online","text":"<p>GitHub makes this extremely easy.</p> <p>For small changes in one file:</p> <ol> <li>Go to the file you'd like to modify and click on \"Edit\".</li> <li>Do your changes and commit them. GitHub will guide you and suggest to open a Pull Request.</li> </ol> <p>For more complex changes or across files:</p> <ol> <li>Press <code>.</code> while browsing the repo or pull request.</li> <li>You'll be welcomed with a \"github.dev Web-based Editor\" where you can work using an online Visual Studio.</li> <li>Do your changes, commit and push them as you'd do locally.</li> </ol> <p></p> <p>Learn more about the github.dev Web-based Editor in \"GitHub Docs\".</p>","tags":[]},{"location":"contributing/2_Getting_Started/#contribute-offline","title":"Contribute Offline","text":"<p>For this you need an IDE or text editor and git on your machine. We recommend using the free Visual Studio Code editor with the markdownlint extension.</p> <ol> <li>Fork the repo. Forking the repo allows you to make your changes without affecting the original project until you're ready to merge them.</li> <li> <p>Clone your fork repo and add the remote upstream repo, e.g. for www-project-smart-contract-security-verification-standard:</p> <pre><code>$ git clone https://github.com/&lt;your_github_user&gt;/www-project-smart-contract-security-verification-standard.git\n$ cd www-project-smart-contract-security-verification-standard/\n$ git remote add upstream git@github.com:OWASP/www-project-smart-contract-security-verification-standard.git\n</code></pre> </li> <li> <p>Create a branch.</p> <pre><code>$ git checkout -b fix-issue-1456\n</code></pre> </li> <li> <p>Make your changes.</p> </li> <li>Commit and push your changes. This can be done by executing the command <code>git add MYFILE</code> for every file you have modified, followed by <code>git commit -m 'Your Commit Message'</code> to commit the modifications and <code>git push</code> to push your modifications to GitHub.</li> <li>Open a PR.</li> </ol>","tags":[]},{"location":"contributing/3_PRs_and_Reviews/","title":"Pull Requests &amp; Reviews","text":"","tags":[]},{"location":"contributing/3_PRs_and_Reviews/#how-to-open-a-pr","title":"How to Open a PR","text":"<p>You can create a Pull Request (PR) by following these steps. Remember that:</p> <ul> <li>The target branch should be <code>master</code>.</li> <li>If your PR closes and issue, write \"Closes <code>#&lt;issue-id&gt;</code>\".</li> </ul> <p>Your PR will be reviewed soon (refer to this page to learn more about reviews).</p> <p>Before opening a PR please self-review your changes in GitHub and ensure that you follow our style guide to speed up the review process\u26a1</p>","tags":[]},{"location":"contributing/3_PRs_and_Reviews/#how-to-incorporate-the-reviewers-feedback-to-your-pr","title":"How to Incorporate the Reviewer's Feedback to your PR","text":"<p>It might be directly approved and merged or one of our reviewers will send you some comments and suggested changes.</p> <p>When reviewers suggest changes in a pull request, you can automatically incorporate the changes into your PR.</p> <ul> <li>Apply any Suggested Changes using the \"Commit suggestions\" button.</li> <li>In order to process a comment, simply make modifications directly to your branch and push normally. GitHub will automatically detect these changes and add them to your existing PR.</li> <li>As you update your PR and apply changes, mark each conversation as resolved.</li> <li>If you run into any merge issues, refer to this page to learn how to resolve them.</li> </ul> <p>NOTE: Remember to regularly sync your fork with the upstream repo: <code>git pull upstream/master</code></p>","tags":[]},{"location":"contributing/3_PRs_and_Reviews/#how-to-review-a-pr","title":"How to Review a PR","text":"<p>If you'd like to review an open PR please follow these steps:</p>","tags":[]},{"location":"contributing/3_PRs_and_Reviews/#step-1-comment-and-suggest-changes","title":"Step 1: Comment and Suggest Changes","text":"<p>You can enter single or multi-line comments (click and drag to select the range of lines):</p> <p></p> <p>Always prefer making \"Suggested Changes\" using the <code>\u00b1</code> button:</p> <p></p> <p>If the suggestion you'd like to make cannot be expressed using \"suggested changes\" please enter a clear comment explaining what should be fixed (e.g. some paragraphs don't link properly or some essential information cannot be found and should be added).</p> <p>Using \"Suggested Changes\" saves you as a reviewer and the PR author a lot of time. And you get points (attributions) for the changes that you suggested (if the author commits them you become a co-author of those commits). If you're constant with your reviewer work you can apply to be recognize as an official reviewer in our Acknowledgements page.</p>","tags":[]},{"location":"contributing/3_PRs_and_Reviews/#step-2-submit-your-review","title":"Step 2: Submit your Review","text":"<p>Once you went through the whole PR you can submit your review</p> <ol> <li>Click on \"Review changes\".</li> <li>Enter a comment for the contributor.</li> <li>Select the type of review you'd like to leave (Comment, Approve or Request Changes).</li> <li>Click on \"Submit review\".</li> </ol> <p>Learn more: \"(GitHub Docs) Reviewing proposed changes in a pull request\".</p>","tags":[]},{"location":"contributing/4_Add_new_Language/","title":"Add a New Language","text":"","tags":[]},{"location":"contributing/4_Add_new_Language/#scstg-translations","title":"SCSTG Translations","text":"<p>The SCSTG is a living document that changes and adapts to the most recent security recommendations every day. While we do want to reach the maximum audience possible, our past experience shows that maintaining translations has proven to be an extremely challenging task. Therefore, please understand that any PRs containing SCSTG translations will be declined, but you're free to do them on your own forks.</p>","tags":[]},{"location":"contributing/4_Add_new_Language/#scsvs-translations","title":"SCSVS Translations","text":"","tags":[]},{"location":"contributing/5_Style_Guide/","title":"Style Guide","text":"<p>The following rules are meant to ensure consistency of the SCSTG:</p> <ol> <li>Keep the content factual, brief and focused. Avoid duplicating other sections of the guide;</li> <li>Refrain from advertising commercial tools or services;</li> <li>When giving technical instructions, address the reader in the second person.</li> </ol> <p>Technical Writing</p> <p>We recommend you to take these free Google courses when writing or reviewing content for the SCS project:</p> <ul> <li>Technical Writing One</li> <li>Technical Writing Two</li> </ul>","tags":[]},{"location":"contributing/5_Style_Guide/#1-how-to-write-content","title":"1. How to Write Content","text":"","tags":[]},{"location":"contributing/5_Style_Guide/#amount-of-content","title":"Amount of Content","text":"<p>The primary measure for amount of content on a page should be based on the purpose it serves.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#use-short-pages","title":"Use short pages","text":"<p>Those containing one or two screens of text at most. Users are scanning for link choices. Use longer pages (those that require more scrolling or reading) deeper within the chapter where content can be printed and read later.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#for-very-large-sections-of-information","title":"For very large sections of information","text":"<p>Consider creating a supporting document and linking to it from the page rather than displaying all the information directly on the page.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#gender-neutrality","title":"Gender Neutrality","text":"<p>The SCSTG reaches all kind of people all over the world. To ensure inclusiveness and diversity, please refrain from using the following throughout the book:</p> <ul> <li>she / her / hers / herself</li> <li>he / him / his / himself</li> </ul> <p>Or any other constructions like \"he/she\", \"s/he\", \"his or her\". Instead, use the following gender-neutral alternatives:</p> <ul> <li>Omit the pronoun if possible: \"The user authenticates himself using ...\" -&gt; \"The user authenticates using ...\"</li> <li>Replace pronouns with \"the or \"a\": \"When the user enters his password ...\" -&gt; \"When the user enters the password ...\"</li> <li>Use plural nouns and pronouns: \"An attacker will use his jailbroken device ...\" -&gt; \"Attackers will use their jailbroken devices ...\"</li> <li>Use the second person: \"If the attacker runs this code, he can bypass ...\" -&gt; \"If you run this code, you can bypass ...\"</li> <li>Use the imperative: \"A developer should never use ... in his code\" -&gt; \"Never use ... in your code!\"</li> </ul> <p>There is one exception: We are still using \"man in the middle\", as it is simply a common term in the industry and there is no common replacement for it.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#timeliness-of-content","title":"Timeliness of Content","text":"<p>Keeping accurate and timely content establishes the OWASP SCS deliverables as a credible and trustworthy source of information.</p> <p>When using statistical data on your page, ensure that the information is current and up-to-date and is accompanied by the source from which it was derived, along with the date the data was compiled.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#content-for-the-digital-platform-versus-for-print","title":"Content for the Digital Platform Versus for Print","text":"<p>Write concise content that the user can read quickly and efficiently. For digital content - create shorter pages that are cross-linked. If your content is likely to be printed, create one long page.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#audience","title":"Audience","text":"<p>Write for an international audience with a basic level of technical understanding i.e. they have a mobile phone and know how to install an app. Avoid hard-to-translate slang words/phrases to ensure content is accessible to readers who aren't native English speakers.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#context-and-orientation","title":"Context and Orientation","text":"<p>Let the users know where they are on every page. Establish the topic by using a unique page heading.</p> <p>Include a clear and concise introduction where possible.</p> <p>Link to background information where necessary.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#write-so-people-will-read-with-joy","title":"Write so People Will Read with Joy","text":"<p>Use the following methods to increase scannability:</p> <ul> <li>Use left alignment for headings, subheadings, and text</li> <li>Link where appropriate</li> <li>Use lists rather than paragraphs wherever possible</li> <li>Use dashes <code>-</code> rather than asterisks <code>*</code> for lists</li> <li>Include only one main idea in each paragraph</li> <li>Put the most important information at the top</li> <li>Start the page with the conclusion as well as a short summary of the remaining content</li> <li>Use headings where applicable</li> <li>Use short, simple words that are to the point</li> <li>Be concise and focused</li> </ul> <p>For longer pages, use the following tools to make the page easily scannable:</p> <ul> <li>Anchor links</li> <li>Subheadings and relevant links</li> <li>Bulleted copy</li> <li>Meaningful graphics, or pull quotes, to break up larger blocks of text</li> <li>End links</li> </ul>","tags":[]},{"location":"contributing/5_Style_Guide/#effective-use-of-lists","title":"Effective Use of Lists","text":"<p>When presenting your content in a list format:</p> <ul> <li>Use numbered lists when the order of entries is important.</li> <li>Use bulleted lists whenever the order of the entries is not important.</li> <li>Generally, limit the number of items in a single list to no more than nine.</li> <li>Generally, limit lists to no more than two levels: primary and secondary.</li> <li>Punctuate and capitalize list items consistently (CMOS 6.124-6.126).</li> <li>Don't add end punctuation to list items that are not complete sentences unless they complete the sentence that introduces the list.</li> <li>Use appropriate capitalization and end punctuation for list items that individually form complete sentences.</li> <li>If the list items complete an introductory sentence, end each (except the last item) with a comma and do not add \"and\" after the second-to-last item. End the last item with appropriate end punctuation (usu. a period).</li> </ul>","tags":[]},{"location":"contributing/5_Style_Guide/#numbering-conventions","title":"Numbering Conventions","text":"<p>When using a number between zero and ten, spell out the number (e.g., \"three\" or \"ten\").</p> <p>When using any number higher than ten, use the numeric version (e.g., \"12\" or \"300\").</p>","tags":[]},{"location":"contributing/5_Style_Guide/#2-language","title":"2. Language","text":"","tags":[]},{"location":"contributing/5_Style_Guide/#american-spelling-and-terminology","title":"American Spelling and Terminology","text":"<p>Use American spelling and terminology.</p> <p>Change all British spelling and terminology to the American equivalents where applicable. This includes \"toward\" (US) vs. \"towards\" (UK), \"among\" (US) vs. \"amongst\" (UK), \"analyze\" (US) vs. \"analyse\" (UK), \"behavior\" (US) vs \"behaviour\" (UK), etc.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#plurals","title":"Plurals","text":"<p>Adhere to standard grammar and punctuation rules when it comes to pluralization of typical words.</p> <p>The plural of calendar years does not take the apostrophe before the \"s\". For example, the plural form of 1990 is 1990s.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#title-capitalization","title":"Title Capitalization","text":"<p>We follow the title case rules from the \"Chicago Manual of Style\":  </p> <ul> <li>Capitalize the first and last word in a title, regardless of part of speech</li> <li>Capitalize all nouns (app, encryption, package), pronouns (you, she, it), verbs (analyze, compile, inspect), adjectives (active, insecure, weak), adverbs (immediately, quietly), and subordinating conjunctions (as, because, although)</li> <li>Lowercase \"to\" as part of an infinitive</li> <li>Lowercase all articles (a, the), prepositions (to, at, in, with), and coordinating conjunctions (and, but, or)</li> </ul> <p>When in doubt, you can verify proper capitalization on https://titlecaseconverter.com/.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#standardization","title":"Standardization","text":"<p>This is a list of words/abbreviations that are used inconsistently at the moment in the SCSTG and need standardization:</p> <ul> <li>man-in-the-middle attack (MITM)</li> </ul>","tags":[]},{"location":"contributing/5_Style_Guide/#contractions","title":"Contractions","text":"<p>Use the following common contractions:</p> <ul> <li>are not -&gt; aren't  </li> <li>cannot -&gt; can't  </li> <li>could not -&gt; couldn't  </li> <li>did not -&gt; didn't  </li> <li>do not -&gt; don't  </li> <li>does not -&gt; doesn't  </li> <li>has not -&gt; hasn't  </li> <li>had not -&gt; hadn't  </li> <li>have not -&gt; haven't</li> <li>is not -&gt; isn't</li> <li>it is -&gt; it's</li> <li>that is -&gt; that's  </li> <li>there is -&gt; there's  </li> <li>was not -&gt; wasn't  </li> <li>were not -&gt; weren't  </li> <li>will not -&gt; won't  </li> <li>would not -&gt; wouldn't  </li> <li>you are -&gt; you're  </li> <li>you have + verb -&gt; you've + verb</li> <li>you will -&gt; you'll  </li> </ul>","tags":[]},{"location":"contributing/5_Style_Guide/#abbreviations","title":"Abbreviations","text":"<p>Abbreviations include acronyms, initialisms, shortened words, and contractions.</p> <ul> <li>Spell out the term the first time it's used, followed by the abbreviation in parentheses. Example: OWASP Smart Contract Security Testing Guide (SCSTG). Subsequent usages in the same chapter may include the abbreviation only.</li> <li>If it only appears once in the content, spell out the term instead of using the abbreviation.</li> <li>In titles and headings, use the abbreviation but be sure to properly introduce it (see above) in the text that follows.</li> <li>Use \"a\" or \"an\" depending on the pronunciation of the acronym. Example: a DLL, an APK, a URL, a SQL.</li> <li>Add an \"s\" for the plural form unless the abbreviation already stands for a plural noun. Example: the APIs, CSS (not CSSs).</li> <li>If the abbreviation is better known as its full spelled-out term, use only the abbreviation. Example: PDF, URL, USB, ZIP.</li> </ul> <p>The following snippet demonstrates most of these points:</p> <pre><code>## JAR Files\n\nJAR (Java ARchive) files are [...]\n\nAPKs are packed using the ZIP format. An APK is a variation of a JAR file [...]\n</code></pre> <p>For commonly used file formats such as APK, IPA or ZIP, please do not refer to them as \".apk\", \".ipa\" or \".zip\" unless you're explicitly referring to the file extension.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#referencing-android-versions","title":"Referencing Android versions","text":"<p>Use the following format when referring to an Android version: Android X (API level YY). Usage of the descriptive name (Ex: Oreo) is discouraged.</p> <p>Ex: Android 9 (API level 28)</p>","tags":[]},{"location":"contributing/5_Style_Guide/#addressing-the-reader-in-test-cases","title":"Addressing the Reader in Test Cases","text":"<p>Throughout the guide, you may want to address the readers in order to tell them what to do, or what they should notice. For any such case, use an active approach and simply address the reader using \"you\".</p> <p>Correct: If you open the AndroidManifest.xml file, you will see a main Application tag, with the following attributes: atr1, atr2 and atr3. If you run the following command, you will see that atr1 is actually dangerous: [...].</p> <p>Wrong: The AndroidManifest.xml file contains an Application tag, with the following attributes: atr1, atr2 and atr3. The command below shows that atr1 is dangerous: [...].</p> <p>Wrong: If we open the AndroidManifest.xml file, we will see a main Application tag, with the following attributes: atr1, atr2 and atr3. If we run the following command, we will see that atr1 is actually dangerous: [...].</p>","tags":[]},{"location":"contributing/5_Style_Guide/#3-external-references","title":"3. External References","text":"","tags":[]},{"location":"contributing/5_Style_Guide/#web-links","title":"Web Links","text":"<p>Use markdown's in-line link format (A) <code>[TEXT](URL \"TITLE\")</code> or (B) <code>[TEXT](URL)</code>.</p> <p>For example:</p> <pre><code>The [threat modeling guidelines defined by OWASP](https://owasp.org/www-community/Threat_Modeling \"OWASP Threat Modeling\") are generally applicable to smart contracts.\n</code></pre> <p>When using (A), be sure to escape special characters such as apostrophe (\\') or single quote (`), as otherwise the link will be broken in Gitbook.</p> <p>Wrong usage, see \"iPhone's\":</p> <pre><code>[UDID of your iOS device via iTunes](https://medium.com/@igor_marques/how-to-find-an-iphones-udid-2d157f1cf2b9 \"How to Find Your iPhone's UDID\")\n</code></pre> <p>Right usage, see \"iPhone\\'s\":</p> <pre><code>[UDID of your iOS device via iTunes](https://medium.com/@igor_marques/how-to-find-an-iphones-udid-2d157f1cf2b9 \"How to Find Your iPhone\\'s UDID\")\n</code></pre> <p>When adding links to the \"References\" section at the end of the chapters use <code>- Title - &lt;url&gt;</code>. This is needed to force latex to print URLs properly for the PDF.</p> <p>For example:</p> <pre><code>- adb - &lt;https://developer.android.com/studio/command-line/adb&gt;\n</code></pre>","tags":[]},{"location":"contributing/5_Style_Guide/#books-and-papers","title":"Books and Papers","text":"<p>For books and papers, use the following format: <code>[#NAME]</code>.</p> <p>And include the full reference in the \"References\" section at the end of the markdown file manually. Example:</p> <pre><code>An obfuscated encryption algorithm can generate its key (or part of the key)\nusing data collected from the environment [#riordan].\n</code></pre> <p>And under the \"References\" section at the end of the chapters:</p> <pre><code>- [#riordan] -  James Riordan, Bruce Schneier. Environmental Key Generation towards Clueless Agents. Mobile Agents and Security, Springer Verlag, 1998\n</code></pre> <p>Papers:</p> <p>The general form for citing technical reports is to place the name and location of the company or institution after the author and title and to give the report number and date at the end of the reference.</p> <p>Basic Format:</p> <pre><code>- [shortname] J. K. Author, \"Title of report,\" Abbrev. Name of Co., City of Co., Abbrev. State, Rep. xxx, year\n\n- [shortname] \\[Author(s)\\], \\[Title\\] - Link\n</code></pre> <p>Books:</p> <pre><code>- [shortname] \\[Author(s)\\], \\[Title\\], \\[Published\\], \\[Year\\]\n\n- [examplebook] J. K. Author, \"Title of chapter in the book,\" in Title of His Published Book, xth ed. City of Publisher, Country if not USA: Abbrev. of Publisher, year, ch. x, sec. x, pp. xxx-xxx.\n</code></pre> <p>NOTE: Use et al. when three or more names are given</p> <p>e.g.</p> <pre><code>- [klaus] B. Klaus and P. Horn, Robot Vision. Cambridge, MA: MIT Press, 1986.\n- [stein] L. Stein, \"Random patterns,\" in Computers and You, J. S. Brake, Ed. New York: Wiley, 1994, pp. 55-70.\n- [myer] R. L. Myer, \"Parametric oscillators and nonlinear materials,\" in Nonlinear Optics, vol. 4, P. G. Harper and B. S. Wherret, Eds. San Francisco, CA: Academic, 1977, pp. 47-160.\n- [abramowitz] M. Abramowitz and I. A. Stegun, Eds., Handbook of Mathematical Functions (Applied Mathematics Series 55). Washington, DC: NBS, 1964, pp. 32-33.\n</code></pre>","tags":[]},{"location":"contributing/5_Style_Guide/#4-references-within-the-guide","title":"4. References Within The Guide","text":"<p>For references to other chapters in the SCSTG, simply name the chapter, e.g.: <code>See also the chapter \"Basic Security Testing\"</code>, <code>See the section \"Apktool\" in the chapter \"Basic Security Testing\"</code> etc. The SCSTG should be convenient to read as a printed book, so use internal references sparingly. Alternatively you can create a link for the specific section:</p> <pre><code>See the section \"[App Bundles](0x05a-Platform-Overview.md#app-bundles)\" in the chapter ...\n</code></pre> <p>Note that in such a case the anchor (everything after the <code>#</code>) should be lowercase, and spaces should be replaced with hyphens.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#5-insert-pictures","title":"5. Insert Pictures","text":"<p>Pictures must always be an HTML <code>&lt;img</code> element instead of the usual markdown image format.</p> <ul> <li><code>src</code> being the first value.</li> <li>a <code>width</code> may be specified.</li> <li>they must be included in the corresponding directory, e.g. in <code>Document/Images/Chapters</code> for SCSTG chapters.</li> </ul> <p>For example:</p> <pre><code>&lt;img src=\"Images/Chapters/0x05b/r2_pd_10.png\" width=\"80%\" /&gt;\n</code></pre>","tags":[]},{"location":"contributing/5_Style_Guide/#6-punctuation-conventions","title":"6. Punctuation Conventions","text":"","tags":[]},{"location":"contributing/5_Style_Guide/#lowercase-or-capital-letter-after-a-colon","title":"Lowercase or Capital Letter after a Colon","text":"<p>Chicago Manual of Style (6.61: Lowercase or capital letter after a colon) says: lowercase the first word unless it is a proper noun or the start of at least two complete sentences or a direct question.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#serial-comma-use","title":"Serial Comma Use","text":"<p>Use a serial comma before \"and\" for the last item in a run-in list of three or more items. For example:</p> <p>We bought apples, oranges, and tomatoes from the store.</p>","tags":[]},{"location":"contributing/5_Style_Guide/#quote-marks-and-apostrophes","title":"Quote Marks and Apostrophes","text":"<p>Use straight double quotes, straight single quotes, and straight apostrophes (not curly quotes/apostrophes).</p>","tags":[]},{"location":"contributing/5_Style_Guide/#technical-terms","title":"Technical Terms","text":"<p>Spell/punctuate specific technical terms as they are used by the company (e.g., use the company website).</p> <p>In order of preference, spell/punctuate generic technical terms according to</p> <ol> <li>Merriam Webster's Collegiate Dictionary, 11th edition.</li> <li>Microsoft Manual of Style, 4th edition</li> <li>foldoc.org (Free Online Dictionary of Computing)</li> </ol> Noun Form Adjectival Form App Store NA backend backend Base64 Base64- black box same Bundle ID NA bytecode NA client side client-side codebase same code signing same command line same disassembler NA end users NA file name same macOS NA OS X NA pentest same PhoneGap NA Python NA repackage NA runtime same server side server-side snapshot length NA use case same Wi-Fi same white box same","tags":[]},{"location":"contributing/5_Style_Guide/#7-comments","title":"7. Comments","text":"<p>Markdown blockquotes can be used for comments in the documents by using <code>&gt;</code></p> <pre><code>&gt; This is a blockquote\n</code></pre>","tags":[]},{"location":"contributing/5_Style_Guide/#8-code-and-shell-commands","title":"8. Code and Shell Commands","text":"<p>Use code blocks when including sample code, shell commands, and paths. In Markdown, code blocks are denoted by triple backticks (<code>```</code>). GitHub also supports syntax highlighting for a variety of languages. For example, a Java code block should be annotated as follows:</p> <pre><code>```java\npublic static void main(String[] args) { System.out.println(\" Hello World!\"); } } ;\n```\n</code></pre> <p>This produces the following result:</p> <pre><code>public static void main(String[] args) { System.out.println(\" Hello World!\"); } }\n</code></pre> <p>When including shell commands, make sure to use the correct language for syntax highlighting (e.g. <code>shell</code> or <code>bash</code>) and remove any prompt (host name, username, ...) from the commands, e.g.:</p> <pre><code>```shell\necho 'Hello World'\nHello World\n```\n</code></pre> <p>When a command requires parameters that need to be modified by the reader, surround them with angle brackets:</p> <pre><code>adb pull &lt;remote_file&gt; &lt;target_destination&gt;\n</code></pre>","tags":[]},{"location":"contributing/5_Style_Guide/#in-text-keywords","title":"In-text Keywords","text":"<p>When they do not occur in a code block, place the following code-related keywords in backticks (<code>``</code>), double straight quote marks (<code>\"\"</code>), or leave unpunctuated according to the table:</p> Backticks Quotation Marks No Punctuation function names section titles application name method names chapter titles folder names commands book titles memory addresses (e.g. 0x100044520) class names flags values (e.g., \"true\", lowercase) block names command options (e.g., \"help\" option) flag names single menu item (e.g., \"Home\" menu) file names system error msgs. package names file paths passwords port numbers binary names method/function arguments method/function argument or return values (e.g., <code>true</code>, <code>0</code>, <code>YES</code>) XML attributes (e.g., <code>get-task-allow</code> on iOS Plists, <code>\"@string/app_name\"</code> on Android Manifests) XML attribute values (e.g., <code>android:label</code> on Android Manifests) property names object names API calls interface names <p>If nouns in backticks are plural, place the \"s\" after the second backtick (e.g. <code>RuntimeException</code>s). Do not add parentheses, brackets, or other punctuation to any keywords that are in backticks (e.g., <code>main</code> not <code>main()</code>).</p>","tags":[]},{"location":"contributing/5_Style_Guide/#navigation","title":"Navigation","text":"<p>When referring to any UI element by name, put its name in boldface, using <code>**&lt;name&gt;**</code> (e.g., Home -&gt; Menu).</p>","tags":[]},{"location":"donate/how_to_donate/","title":"How to Donate","text":"<p>1. Make your Donation:</p> <p></p> <p>Click the button to make your donation directly in the official OWASP website:</p> <p> Fill in the form and be sure to select the option \"Publicly list me as a supporter of OWASP Smart Contract Security\"</p> :white_heart:{ .pump } Make your Donation <p></p> <p>2. Register your Donation Package (optional):</p> <p></p> <p>If your donation is above USD 500 you may opt-in for a Donation Package by registering it. We will then, together with the OWASP Foundation, verify and process it.</p> :material-check-all: Register your Donation <p></p>","tags":[]},{"location":"donate/packages/","title":"Donation Packages","text":"<p>These types of public recognition shall be online no less than one year, or no less than the next major release, whichever is greater.</p> <p> The Donation Packages have a maximum duration, once expired the logos will be removed and the donator will still be listed as supporter on the project website, GitHub and in the printed and digital versions. This can be renewed anytime.</p>   | :package: Good Samaritan (USD 500) | :package: Honorable Benefactor (USD 2,000 / 8 Available) | :package: God Mode Donator (USD 4,000 / 5 Available) | |---|---|---| |<ul><li>:material-check: Listed as a supporter.</li><li>:material-check: Small company logo.</li><li>:material-clock: 1 year</li></ul>|<ul><li>:material-check: Listed as a supporter.</li><li>:material-check: Medium company logo</li><li>:material-clock: 2 year</li></ul>|<ul><li>:material-check: Listed as a supporter.</li><li>:material-check:Large company logo.</li><li>:material-clock: 3 years</li></ul>|   <p>Please note that the OWASP Donation Policy has changed since 22-Sept-2020. All details can be found in OWASP Donations Policy page.</p> <p>Contact us if you have any questions regarding your donation.</p>","tags":[]},{"location":"news/","title":"OWASP Official Pages","text":"<ul> <li>OWASP Smart Contract Security Project</li> <li>OWASP Smart Contract Top 10</li> <li>OWASP Smart Contract Security Testing Guide</li> <li>OWASP Smart Contract Security Verification Standard</li> </ul>","tags":[]},{"location":"news/#blogs","title":"Blogs","text":"<ul> <li>OWASP Smart Contract Top 10 Security Risks and Vulnerabilities: A Deep Dive with Real-World Exploits and CredShields Contribution (SolidityScan)</li> <li>OWASP SC Top 10 2025 Breakdown: The Most Critical Smart Contract Risks of 2025 (Resonance Security)</li> <li>OWASP Smart Contract Top 10 2025 (Insecure.in)</li> </ul>","tags":[]},{"location":"news/#security-newsletters","title":"Security Newsletters","text":"<ul> <li>Blockthreat Week 4 2025</li> <li>Cybersecurity News: OWASP Top 10 2025 Smart Contract</li> <li>GBHackers: OWASP Smart Contract Top 10 2025</li> <li>AppSec Newsletter 0040 (Guia de AppSec)</li> </ul>","tags":[]},{"location":"news/#conferences","title":"Conferences","text":"<ul> <li>OWASP Smart Contract Top 10 at DEVWorld Conference (LinkedIn Post)</li> </ul>","tags":[]},{"location":"news/#social-media-highlights","title":"Social Media Highlights","text":"","tags":[]},{"location":"news/#linkedin","title":"LinkedIn","text":"<ul> <li>OWASP Official Announcement</li> <li>Star Brown's Post</li> <li>Cybersecurity News Coverage</li> <li>Community Post</li> <li>Cyber Security Hub Newsletter</li> <li>SolidityScan Announcement</li> <li>Amish Patel's Post</li> </ul>","tags":[]},{"location":"news/#x-twitter","title":"X (Twitter)","text":"<ul> <li>OWASP Official Tweet</li> <li>DeFiHackLabs' Coverage</li> <li>SolidityScan's Tweet</li> <li>CyberboyIndia's Post</li> <li>CredShields Announcement</li> <li>Harshleen Chawla's Post</li> <li>Web3 Security Tweet</li> <li>7h3h4ckv157's Post</li> </ul>","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/","title":"SC01:2025 Access Control Vulnerabilities","text":"","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/#vulnerability-improper-access-control","title":"Vulnerability: Improper Access Control","text":"","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/#description","title":"Description:","text":"<p>An access control vulnerability is a security flaw that allows unauthorized users to access or modify the contract's data or functions. These vulnerabilities arise when the contract's code fails to adequately restrict access based on user permission levels. Access control in smart contracts can relate to governance and critical logic, such as minting tokens, voting on proposals, withdrawing funds, pausing and upgrading the contracts, and changing ownership.</p>","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/#example-vulnerable-contract","title":"Example (Vulnerable contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_AccessControl {\n    mapping(address =&gt; uint256) public balances;\n\n    // Burn function with no access control\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/#impact","title":"Impact:","text":"<ul> <li>Attackers can gain unauthorized access to critical functions and data within the contract, compromising its integrity and security.</li> <li>Vulnerabilities can lead to the theft of funds or assets controlled by the contract, causing significant financial damage to users and stakeholders.</li> </ul>","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/#remediation","title":"Remediation:","text":"<ul> <li>Ensure initialization functions can only be called once and exclusively by authorized entities.</li> <li>Use established access control patterns like Ownable or RBAC (Role-Based Access Control) in your contracts to manage permissions and ensure that only authorized users can access certain functions. This can be done by adding appropriate access control modifiers, such as <code>onlyOwner</code> or custom roles to sensitive functions.</li> </ul>","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Import the Ownable contract from OpenZeppelin to manage ownership\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Solidity_AccessControl is Ownable {\n    mapping(address =&gt; uint256) public balances;\n\n    // Burn function with proper access control, only accessible by the contract owner\n    function burn(address account, uint256 amount) public onlyOwner {\n        _burn(account, amount);\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC01-AccessControlVulnerabilities/#examples-of-smart-contracts-that-fell-victim-to-improper-access-control-attacks","title":"Examples of Smart Contracts That Fell Victim to Improper Access Control Attacks:","text":"<ol> <li>HospoWise Hack : A Comprehensive Hack Analysis</li> <li>LAND NFT Hack : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/SC02-PriceOracleManipulation/","title":"SC02:2025 Price Oracle Manipulation","text":"","tags":[]},{"location":"sctop10/SC02-PriceOracleManipulation/#vulnerability-price-oracle-manipulation","title":"Vulnerability: Price Oracle Manipulation","text":"","tags":[]},{"location":"sctop10/SC02-PriceOracleManipulation/#description","title":"Description:","text":"<p>Price Oracle Manipulation is a critical vulnerability in smart contracts that rely on external data feeds (oracles) to fetch prices or other information. In decentralized finance (DeFi), oracles are used to provide real-world data, such as asset prices, to smart contracts. However, if the data provided by the oracle is manipulated, it can result in incorrect contract behavior. Attackers can exploit oracles by manipulating the data they supply, leading to devastating consequences such as unauthorized withdrawals, excessive leverage, or even draining liquidity pools. Proper safeguards and validation mechanisms are essential to prevent this type of attack. Example (Vulnerable contract):</p>","tags":[]},{"location":"sctop10/SC02-PriceOracleManipulation/#example-vulnerable-contract","title":"Example (Vulnerable Contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPriceFeed {\n    function getLatestPrice() external view returns (int);\n}\n\ncontract PriceOracleManipulation {\n    address public owner;\n    IPriceFeed public priceFeed;\n\n    constructor(address _priceFeed) {\n        owner = msg.sender;\n        priceFeed = IPriceFeed(_priceFeed);\n    }\n\n    function borrow(uint256 amount) public {\n        int price = priceFeed.getLatestPrice();\n        require(price &gt; 0, \"Price must be positive\");\n\n        // Vulnerability: No validation or protection against price manipulation\n        uint256 collateralValue = uint256(price) * amount;\n\n        // Borrow logic based on manipulated price\n        // If an attacker manipulates the oracle, they could borrow more than they should\n    }\n\n    function repay(uint256 amount) public {\n        // Repayment logic\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC02-PriceOracleManipulation/#impact","title":"Impact:","text":"<ul> <li>Attackers could manipulate the oracle to inflate the price of an asset, allowing them to borrow more funds than they would otherwise be entitled to.</li> <li>In cases where the manipulated price leads to a false assessment of collateral, legitimate users may face liquidation due to incorrect valuations.</li> <li>If an oracle is compromised, attackers can exploit the manipulated data to drain the contract\u2019s liquidity pools or even cause a contract to become insolvent.</li> </ul>","tags":[]},{"location":"sctop10/SC02-PriceOracleManipulation/#remediation","title":"Remediation:","text":"<ul> <li>Aggregate data from multiple, independent oracles to reduce the risk of manipulation by any single source.</li> <li>Set minimum and maximum thresholds for the prices received from the oracle to prevent drastic price swings from affecting the contract\u2019s logic.</li> <li>Introduce a time lock between price updates to prevent instant changes that could be exploited by attackers.</li> <li>Use cryptographic proofs to ensure the authenticity of data received from oracles, such as requiring signatures from trusted parties.</li> </ul>","tags":[]},{"location":"sctop10/SC02-PriceOracleManipulation/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPriceFeed {\n    function getLatestPrice() external view returns (int);\n}\n\ncontract PriceOracleManipulation {\n    address public owner;\n    IPriceFeed public priceFeed;\n    int public minPrice = 1000; // Set minimum acceptable price\n    int public maxPrice = 2000; // Set maximum acceptable price\n\n    constructor(address _priceFeed) {\n        owner = msg.sender;\n        priceFeed = IPriceFeed(_priceFeed);\n    }\n\n    function borrow(uint256 amount) public {\n        int price = priceFeed.getLatestPrice();\n        require(price &gt; 0 &amp;&amp; price &gt;= minPrice &amp;&amp; price &lt;= maxPrice, \"Price manipulation detected\");\n\n        uint256 collateralValue = uint256(price) * amount;\n\n        // Borrow logic based on valid price\n    }\n\n    function repay(uint256 amount) public {\n        // Repayment logic\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC02-PriceOracleManipulation/#examples-of-smart-contracts-that-fell-victim-to-price-oracle-manipulation-attacks","title":"Examples of Smart Contracts that fell victim to Price Oracle Manipulation Attacks :","text":"<ol> <li>Polter Finance Hack Analysis </li> <li>BonqDAO Protocol : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/SC03-LogicErrors/","title":"SC03:2025 Logic Errors","text":"","tags":[]},{"location":"sctop10/SC03-LogicErrors/#vulnerability-logic-errors","title":"Vulnerability: Logic Errors","text":"","tags":[]},{"location":"sctop10/SC03-LogicErrors/#description","title":"Description:","text":"<p>Logic errors, also known as business logic vulnerabilities, are subtle flaws in smart contracts. They occur when the contract's code does not match its intended behavior. These errors can manifest in various forms, such as faulty math in reward distribution, improper token minting mechanisms, or incorrect calculations in lending and borrowing logic. Such vulnerabilities are elusive, hiding within the contract's logic and waiting to be discovered.</p>","tags":[]},{"location":"sctop10/SC03-LogicErrors/#examples-of-logic-errors","title":"Examples of Logic Errors:","text":"<ol> <li>Faulty Reward Distribution: Miscalculations in dividing rewards among stakeholders, leading to unfair allocations.</li> <li>Improper Token Minting: Unchecked or erroneous minting logic that allows infinite or unintended token generation.</li> <li>Lending Pool Imbalances: Incorrect tracking of deposits and withdrawals, causing inconsistencies in pool reserves.</li> </ol>","tags":[]},{"location":"sctop10/SC03-LogicErrors/#example-vulnerable-contract","title":"Example (Vulnerable contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_LogicErrors {\n    mapping(address =&gt; uint256) public userBalances;\n    uint256 public totalLendingPool;\n\n    function deposit() public payable {\n        userBalances[msg.sender] += msg.value;\n        totalLendingPool += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(userBalances[msg.sender] &gt;= amount, \"Insufficient balance\");\n\n        // Faulty calculation: Incorrectly reducing the user's balance without updating the total lending pool\n        userBalances[msg.sender] -= amount;\n\n        // This should update the total lending pool, but it's omitted here.\n\n        payable(msg.sender).transfer(amount);\n    }\n\n    function mintReward(address to, uint256 rewardAmount) public {\n        // Faulty minting logic: Reward amount not validated\n        userBalances[to] += rewardAmount;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC03-LogicErrors/#impact","title":"Impact:","text":"<ul> <li>Logic errors can cause a smart contract to behave unexpectedly or even become entirely unusable. These errors can lead to:</li> <li>Loss of Funds: Incorrect reward distribution or pool imbalances draining contract funds.</li> <li>Excessive Token Minting: Inflating token supply, undermining trust and value.</li> <li>Operational Failures: Contracts failing to perform their intended functions.</li> <li>These consequences can result in significant financial and operational losses for users and stakeholders.</li> </ul>","tags":[]},{"location":"sctop10/SC03-LogicErrors/#remediation","title":"Remediation:","text":"<ul> <li>Always validate your code by writing comprehensive test cases that cover all possible business logic scenarios.</li> <li>Conduct thorough code reviews and audits to identify and fix potential logic errors.</li> <li>Document the intended behavior of each function and module, and compare it to the actual implementation to ensure alignment.</li> <li>Implement guardrails, such as:</li> <li>Safe math libraries to prevent calculation errors.</li> <li>Proper checks and balances for token minting.</li> <li>Auditable reward distribution algorithms.</li> </ul>","tags":[]},{"location":"sctop10/SC03-LogicErrors/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_LogicErrors {\n    mapping(address =&gt; uint256) public userBalances;\n    uint256 public totalLendingPool;\n\n    function deposit() public payable {\n        userBalances[msg.sender] += msg.value;\n        totalLendingPool += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(userBalances[msg.sender] &gt;= amount, \"Insufficient balance\");\n\n        // Correctly reducing the user's balance and updating the total lending pool\n        userBalances[msg.sender] -= amount;\n        totalLendingPool -= amount;\n\n        payable(msg.sender).transfer(amount);\n    }\n\n    function mintReward(address to, uint256 rewardAmount) public {\n        require(rewardAmount &gt; 0, \"Reward amount must be positive\");\n\n        // Safeguarded minting logic\n        userBalances[to] += rewardAmount;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC03-LogicErrors/#examples-of-smart-contracts-that-fell-victim-to-business-logic-attacks","title":"Examples of Smart Contracts That Fell Victim to Business Logic Attacks:","text":"<ol> <li>Level Finance Hack : A Comprehensive Hack Analysis</li> <li>BNO Hack : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/SC04-LackOfInputValidation/","title":"SC04:2025 Lack of Input Validation","text":"","tags":[]},{"location":"sctop10/SC04-LackOfInputValidation/#vulnerability-lack-of-input-validation","title":"Vulnerability: Lack of Input Validation","text":"","tags":[]},{"location":"sctop10/SC04-LackOfInputValidation/#description","title":"Description:","text":"<p>Input validation ensures that a smart contract processes only valid and expected data. When contracts fail to validate incoming inputs, they inadvertently expose themselves to security risks such as logic manipulation, unauthorized access, and unexpected behavior.For example, if a contract assumes user inputs are always valid without verification, attackers can exploit this trust to introduce malicious data. This lack of input validation compromises the security and reliability of the smart contract.</p>","tags":[]},{"location":"sctop10/SC04-LackOfInputValidation/#example-vulnerable-contract","title":"Example (Vulnerable Contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_LackOfInputValidation {\n    mapping(address =&gt; uint256) public balances;\n\n    function setBalance(address user, uint256 amount) public {\n        // The function allows anyone to set arbitrary balances for any user without validation.\n        balances[user] = amount;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC04-LackOfInputValidation/#impact","title":"Impact:","text":"<ul> <li>Attackers can manipulate inputs to drain funds, steal tokens, or cause other financial harm.</li> <li>Improper inputs can corrupt state variables, leading to unreliable and insecure contract behavior.</li> <li>Attackers may exploit the contract to perform unauthorized transactions or operations, impacting both the user and the broader system.</li> </ul>","tags":[]},{"location":"sctop10/SC04-LackOfInputValidation/#remediation","title":"Remediation:","text":"<ul> <li>Ensure that inputs conform to the expected type.</li> <li>Validate that inputs fall within acceptable boundaries.</li> <li>Ensure that only authorized entities can invoke specific functions.</li> <li>Validate the structure of inputs, such as address formats or string lengths.</li> <li>Always halt execution and provide clear error messages when inputs fail validation.</li> </ul>","tags":[]},{"location":"sctop10/SC04-LackOfInputValidation/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract LackOfInputValidation {\n    mapping(address =&gt; uint256) public balances;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not authorized\");\n        _;\n    }\n\n    function setBalance(address user, uint256 amount) public onlyOwner {\n        require(user != address(0), \"Invalid address\");\n        balances[user] = amount;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC04-LackOfInputValidation/#examples-of-smart-contracts-that-fell-victim-to-attacks-due-to-lack-of-input-validation","title":"Examples of Smart Contracts that fell victim to attacks due to Lack of Input Validation:","text":"<ol> <li>Convergence Finance : A Comprehensive Hack Analysis</li> <li>Socket Gateway : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/SC05-Reentrancy/","title":"SC05:2025 Reentrancy","text":"","tags":[]},{"location":"sctop10/SC05-Reentrancy/#vulnerability-reentrancy-attacks","title":"Vulnerability: Reentrancy Attacks","text":"","tags":[]},{"location":"sctop10/SC05-Reentrancy/#description","title":"Description:","text":"<p>A reentrancy attack exploits the vulnerability in smart contracts when a function makes an external call to another contract before updating its own state. This allows the external contract, possibly malicious, to reenter the original function and repeat certain actions, like withdrawals, using the same state. Through such attacks, an attacker can possibly drain all the funds from a contract.</p>","tags":[]},{"location":"sctop10/SC05-Reentrancy/#example-vulnerable-contract","title":"Example (Vulnerable contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_Reentrancy {\n    mapping(address =&gt; uint) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        uint amount = balances[msg.sender];\n        require(amount &gt; 0, \"Insufficient balance\");\n\n        // Vulnerability: Ether is sent before updating the user's balance, allowing reentrancy.\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n\n        // Update balance after sending Ether\n        balances[msg.sender] = 0;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC05-Reentrancy/#impact","title":"Impact:","text":"<ul> <li>The most immediate and impactful consequence is the draining of funds. Attackers exploit vulnerabilities to withdraw more money than they are entitled to, potentially emptying the contract's balance completely.</li> <li>An attacker can trigger unauthorized function calls. This can lead to unintended actions being executed within the contract or related systems.</li> </ul>","tags":[]},{"location":"sctop10/SC05-Reentrancy/#remediation","title":"Remediation:","text":"<ul> <li>Always ensure that every state change happens before calling external contracts, i.e., update balances or code internally before calling external code.</li> <li>Use function modifiers that prevent reentrancy, like OpenZeppelin\u2019s Re-entrancy Guard.</li> </ul>","tags":[]},{"location":"sctop10/SC05-Reentrancy/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_Reentrancy {\n    mapping(address =&gt; uint) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        uint amount = balances[msg.sender];\n        require(amount &gt; 0, \"Insufficient balance\");\n\n        // Fix: Update the user's balance before sending Ether\n        balances[msg.sender] = 0;\n\n        // Then send Ether\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC05-Reentrancy/#examples-of-smart-contracts-that-fell-victim-to-reentrancy-attacks","title":"Examples of Smart Contracts that fell victim to Reentrancy Attacks:","text":"<ol> <li>Rari Capital : A Comprehensive Hack Analysis</li> <li>Orion Protocol : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/","title":"SC06:2025 Unchecked External Calls","text":"","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/#vulnerability-unchecked-external-calls","title":"Vulnerability: Unchecked External Calls","text":"","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/#description","title":"Description:","text":"<p>Unchecked external calls refer to a security flaw where a contract makes an external call to another contract or address without properly checking the outcome of that call. In Ethereum, when a contract calls another contract, the called contract can fail silently without throwing an exception. If the calling contract doesn\u2019t check the return value, it might incorrectly assume the call was successful, even if it wasn't. This can lead to inconsistencies in the contract state and vulnerabilities that attackers can exploit.</p>","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/#example-vulnerable-contract","title":"Example (Vulnerable contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Solidity_UncheckedExternalCall {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function forward(address callee, bytes _data) public {\n        require(callee.delegatecall(_data));\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/#impact","title":"Impact:","text":"<ul> <li>Unchecked external calls can result in failed transactions, causing the intended operations to not be completed successfully. This can lead to the loss of funds, as the contract may proceed under the false assumption that the transfer was successful. Additionally, it can create an incorrect contract state, making the contract vulnerable to further exploits and inconsistencies in its logic.</li> </ul>","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/#remediation","title":"Remediation:","text":"<ul> <li>Whenever possible, use transfer() instead of send(), as transfer() reverts the transaction if the external call fails.</li> <li>Always check the return value of send() or call() functions to ensure proper handling if they return false.</li> </ul>","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0; \n\ncontract Solidity_UncheckedExternalCall {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function forward(address callee, bytes memory _data) public {\n        // Ensure that delegatecall succeeds\n        (bool success, ) = callee.delegatecall(_data);\n        require(success, \"Delegatecall failed\");  // Check the return value to handle failure\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC06-UncheckedExternalCalls/#examples-of-smart-contracts-that-fell-victim-to-unchecked-external-call-attacks","title":"Examples of Smart Contracts That Fell Victim to Unchecked External Call Attacks:","text":"<ol> <li>Punk Protocol Hack : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/SC07-FlashLoanAttacks/","title":"SC07:2025 Flash Loan Attacks","text":"","tags":[]},{"location":"sctop10/SC07-FlashLoanAttacks/#vulnerability-flash-loan-attacks","title":"Vulnerability: Flash Loan Attacks","text":"","tags":[]},{"location":"sctop10/SC07-FlashLoanAttacks/#description","title":"Description:","text":"<p>Flash loan attacks exploit the ability to borrow large sums of funds without collateral within a single transaction. These attacks leverage the atomic nature of blockchain transactions, where all operations must succeed or fail together. By combining flash loans with other vulnerabilities like oracle manipulation, reentrancy, or faulty logic, attackers can manipulate contract behavior and drain funds.</p>","tags":[]},{"location":"sctop10/SC07-FlashLoanAttacks/#examples-of-flash-loan-exploits","title":"Examples of Flash Loan Exploits:","text":"<ol> <li>Oracle Manipulation: Using borrowed funds to skew price oracles, triggering under-collateralized liquidations.</li> <li>Liquidity Pool Draining: Leveraging flash loans to remove liquidity or exploit poorly designed AMM mechanics.</li> <li>Arbitrage Exploits: Exploiting price discrepancies across platforms by manipulating liquidity.</li> </ol>","tags":[]},{"location":"sctop10/SC07-FlashLoanAttacks/#impact","title":"Impact:","text":"<ul> <li>Loss of Funds: Exploiters can drain protocol reserves or manipulate collateralized loans to steal assets.</li> <li>Market Disruptions: Temporary price manipulation or liquidity depletion affecting users and platforms.</li> <li>Ecosystem Damage: Loss of trust in protocols, resulting in reduced user adoption and financial impact.</li> </ul>","tags":[]},{"location":"sctop10/SC07-FlashLoanAttacks/#remediation","title":"Remediation:","text":"<ul> <li>Avoid reliance on flash loans in critical logic: Restrict sensitive functions to operate only within validated and predictable conditions.</li> <li>Robust Oracle Design: Use time-weighted average prices (TWAP) or decentralized oracles resistant to manipulation.</li> <li>Comprehensive Testing: Include tests simulating flash loan scenarios and edge cases.</li> <li>Access Control: Limit access to critical functions to prevent unauthorized or malicious transactions.</li> </ul>","tags":[]},{"location":"sctop10/SC07-FlashLoanAttacks/#examples-of-flash-loan-exploits_1","title":"Examples of Flash Loan Exploits:","text":"<ol> <li>UwUlend Hack: A Comprehensive Hack Analysis</li> <li>Doughfina Hack: A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/SC08-IntegerOverUnderFlow/","title":"SC08:2025 Integer Overflow and Underflow","text":"","tags":[]},{"location":"sctop10/SC08-IntegerOverUnderFlow/#vulnerability-integer-overflow-and-underflow","title":"Vulnerability: Integer Overflow and Underflow","text":"","tags":[]},{"location":"sctop10/SC08-IntegerOverUnderFlow/#description","title":"Description:","text":"<p>Ethereum Virtual Machine (EVM) defines fixed-size data types for integers. This implies that the range of numbers that an integer variable can represent is finite.For instance, a \u201cuint8\u201d (unsigned integer of 8 bits; i.e., non-negative) can only store integers that fall between 0 and 255. The outcome of trying to store any value greater than 255 into an \u201cuint8\u201d will lead to an overflow. Similarly, the outcome of subtracting \u201c1\u201d from \u201c0\u201d will produce 255. This is called underflow.When an arithmetic operation exceeds or falls short of a type\u2019s maximum or minimum size, an overflow or underflow occurs.For signed integers, the outcome will be a bit different. If we try subtracting \u201c1\u201d from an int8 whose value is -128, we get 127. This is because signed int types, which may represent negative values, start over once we reach the highest negative value.Two straightforward examples of this behavior include periodic mathematical functions (adding 2 to the argument of sin leaves the value intact) and odometers in automobiles, which track distance traveled (they reset to 000000 after the maximum number, i.e., 999999, is exceeded).</p> <p>Important Note:- In Solidity <code>0.8.0</code> and above, the compiler automatically handles checking for overflows and underflows in arithmetic operations, reverting the transaction if an overflow or underflow occurs. Solidity <code>0.8.0</code> also introduces the <code>unchecked</code> keyword, which allows developers to perform arithmetic operations without these automatic checks, explicitly permitting overflow without reverting. This can be particularly useful for optimizing gas usage in cases where overflow is not a concern or where the wraparound behavior is desired, similar to how arithmetic behaved in earlier versions of Solidity.</p>","tags":[]},{"location":"sctop10/SC08-IntegerOverUnderFlow/#example-vulnerable-contract","title":"Example (Vulnerable contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.4.17;\n\ncontract Solidity_OverflowUnderflow {\n    uint8 public balance;\n\n    constructor() public {\n        balance = 255; // Maximum value of uint8\n    }\n\n    // Increments the balance by a given value\n    function increment(uint8 value) public {\n        balance += value; // Vulnerable to overflow\n    }\n\n    // Decrements the balance by a given value\n    function decrement(uint8 value) public {\n        balance -= value; // Vulnerable to underflow\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC08-IntegerOverUnderFlow/#impact","title":"Impact:","text":"<ul> <li>An attacker could exploit such vulnerabilities to artificially increase account balances or token amounts, potentially allowing them to withdraw more funds than they legitimately own.</li> <li>An attacker might alter the intended flow of contract logic, leading to unauthorized actions like stealing assets or minting an excessive number of tokens.</li> </ul>","tags":[]},{"location":"sctop10/SC08-IntegerOverUnderFlow/#remediation","title":"Remediation:","text":"<ul> <li>The simplest approach is to use Solidity compiler version 0.8.0 or higher, as it automatically handles overflow and underflow checks.</li> <li>Make Use of the latest Safe Math Libraries: For the Ethereum community, OpenZeppelin has done a fantastic job creating and auditing secure libraries. Its SafeMath library, in particular, can be used to prevent under/overflow vulnerabilities. It provides functions like add(), sub(), mul(), etc., that carry out basic arithmetic operations and automatically revert if an overflow or underflow occurs.</li> </ul>","tags":[]},{"location":"sctop10/SC08-IntegerOverUnderFlow/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_OverflowUnderflow {\n    uint8 public balance;\n\n    constructor() {\n        balance = 255; // Maximum value of uint8\n    }\n\n    // Increments the balance by a given value\n    function increment(uint8 value) public {\n        balance += value; // Solidity 0.8.x automatically checks for overflow\n    }\n\n    // Decrements the balance by a given value\n    function decrement(uint8 value) public {\n        require(balance &gt;= value, \"Underflow detected\");\n        balance -= value;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC08-IntegerOverUnderFlow/#examples-of-smart-contracts-that-fell-victim-to-integer-overflow-and-underflow-attacks","title":"Examples of Smart Contracts that fell victim to Integer Overflow and Underflow Attacks:","text":"<ol> <li>PoWH Coin Ponzi Scheme : A Comprehensive Hack Analysis</li> <li>Poolz Finance : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/SC09-InsecureRandomness/","title":"SC09:2025 Insecure Randomness","text":"","tags":[]},{"location":"sctop10/SC09-InsecureRandomness/#vulnerability-insecure-randomness","title":"Vulnerability: Insecure Randomness","text":"","tags":[]},{"location":"sctop10/SC09-InsecureRandomness/#description","title":"Description:","text":"<p>Random number generators are essential for applications like gambling, game-winner selection, and random seed generation. On Ethereum, generating random numbers is challenging due to its deterministic nature. Since Solidity cannot produce true random numbers, it relies on pseudorandom factors. Additionally, complex calculations in Solidity are costly in terms of gas.</p> <p>Insecure Mechanisms Create Random Numbers in Solidity: Developers often use block-related methods to generate random numbers, such as:   - block.timestamp: Current block timestamp.   - blockhash(uint blockNumber): Hash of a given block (only for the last 256 blocks).   - block.difficulty: Current block difficulty.   - block.number: Current block number.   - block.coinbase: Address of the current block\u2019s miner.</p> <p>These methods are insecure because miners can manipulate them, affecting the contract\u2019s logic.</p>","tags":[]},{"location":"sctop10/SC09-InsecureRandomness/#example-vulnerable-contract","title":"Example (Vulnerable contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Solidity_InsecureRandomness {\n    constructor() payable {}\n\n    function guess(uint256 _guess) public {\n        uint256 answer = uint256(\n            keccak256(\n                abi.encodePacked(block.timestamp, block.difficulty, msg.sender) // Using insecure mechanisms for random number generation\n            ) \n        );\n\n        if (_guess == answer) {\n            (bool sent,) = msg.sender.call{value: 1 ether}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC09-InsecureRandomness/#impact","title":"Impact:","text":"<ul> <li>Insecure randomness can be exploited by attackers to gain an unfair advantage in games, lotteries, and any other contracts that rely on random number generation. By predicting or manipulating the supposedly random outcomes, attackers can influence the results in their favor. This can lead to unfair wins, financial losses for other participants, and a general lack of trust in the smart contract's integrity and fairness. </li> </ul>","tags":[]},{"location":"sctop10/SC09-InsecureRandomness/#remediation","title":"Remediation:","text":"<ul> <li>Using oracles (Oraclize) as external sources of randomness. Care should be taken while trusting the Oracle. Multiple Oracles can also be used.</li> <li>Using Commitment Schemes \u2014 A cryptographic primitive that uses a commit-reveal approach can be followed. It also has wide applications in coin flipping, zero-knowledge proofs, and secure computation. E.g.: RANDAO.</li> <li>Chainlink VRF \u2014 It is a provably fair and verifiable random number generator (RNG) that enables smart contracts to access random values without compromising security or usability.</li> <li>The Signidice Algorithm \u2014 Suitable for PRNG in applications involving two parties using cryptographic signatures.</li> <li>Bitcoin Block Hashes \u2014 Oracles like BTCRelay can be used which act as a bridge between Ethereum and Bitcoin. Contracts on Ethereum can request future block hashes from the Bitcoin Blockchain as a source of entropy. It should be noted that this approach is not safe against the miner incentive problem and should be implemented with caution.</li> </ul>","tags":[]},{"location":"sctop10/SC09-InsecureRandomness/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\n\ncontract Solidity_InsecureRandomness is VRFConsumerBase {\n    bytes32 internal keyHash;\n    uint256 internal fee;\n    uint256 public randomResult;\n\n    constructor(address _vrfCoordinator, address _linkToken, bytes32 _keyHash, uint256 _fee) \n        VRFConsumerBase(_vrfCoordinator, _linkToken) \n    {\n        keyHash = _keyHash;\n        fee = _fee;\n    }\n\n    function requestRandomNumber() public returns (bytes32 requestId) {\n        require(LINK.balanceOf(address(this)) &gt;= fee, \"Not enough LINK\");\n        return requestRandomness(keyHash, fee);\n    }\n\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n        randomResult = randomness;\n    }\n\n    function guess(uint256 _guess) public {\n        require(randomResult &gt; 0, \"Random number not generated yet\");\n        if (_guess == randomResult) {\n            (bool sent,) = msg.sender.call{value: 1 ether}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC09-InsecureRandomness/#examples-of-smart-contracts-that-fell-victim-to-insecure-randomness-attacks","title":"Examples of Smart Contracts That Fell Victim to Insecure Randomness Attacks:","text":"<ol> <li>Roast Football Hack : A Comprehensive Hack Analysis</li> <li>FFIST Hack : A Comprehensive Hack Analysis</li> </ol>","tags":[]},{"location":"sctop10/SC10-DenailOfService/","title":"SC10:2025 Denial Of Service","text":"","tags":[]},{"location":"sctop10/SC10-DenailOfService/#vulnerability-denial-of-service","title":"Vulnerability: Denial Of Service","text":"","tags":[]},{"location":"sctop10/SC10-DenailOfService/#description","title":"Description:","text":"<p>A Denial of Service (DoS) attack in Solidity involves exploiting vulnerabilities to exhaust resources like gas, CPU cycles, or storage, making a smart contract unusable. Common types include gas exhaustion attacks, where malicious actors create transactions requiring excessive gas, reentrancy attacks that exploit contract call sequences to access unauthorized funds, and block gas limit attacks that consume block gas, hindering legitimate transactions.</p>","tags":[]},{"location":"sctop10/SC10-DenailOfService/#example-vulnerable-contract","title":"Example (Vulnerable contract):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Solidity_DOS {\n    address public king;\n    uint256 public balance;\n\n    function claimThrone() external payable {\n        require(msg.value &gt; balance, \"Need to pay more to become the king\");\n\n        //If the current king has a malicious fallback function that reverts, it will prevent the new king from claiming the throne, causing a Denial of Service.\n        (bool sent,) = king.call{value: balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/SC10-DenailOfService/#impact","title":"Impact:","text":"<ul> <li>A successful DoS attack can render the smart contract unresponsive, preventing users from interacting with it as intended. This can disrupt critical operations and services relying on the contract.</li> <li>DoS attacks can lead to financial losses, especially in decentralized applications (dApps) where smart contracts manage funds or assets.</li> <li>A DoS attack can tarnish the reputation of the smart contract and its associated platform. Users may lose trust in the platform's security and reliability, leading to a loss of users and business opportunities.</li> </ul>","tags":[]},{"location":"sctop10/SC10-DenailOfService/#remediation","title":"Remediation:","text":"<ul> <li>Ensure smart contracts can handle consistent failures, such as asynchronous processing of potentially failing external calls, to maintain contract integrity and prevent unexpected behavior.</li> <li>Be cautious when using <code>call</code> for external calls, loops, and traversals to avoid excessive gas consumption, which could lead to failed transactions or unexpected costs.</li> <li>Avoid over-authorizing a single role in contract permissions. Instead, divide permissions reasonably and use multi-signature wallet management for roles with critical permissions to prevent permission loss due to private key compromise.</li> </ul>","tags":[]},{"location":"sctop10/SC10-DenailOfService/#example-fixed-version","title":"Example (Fixed version):","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Solidity_DOS {\n    address public king;\n    uint256 public balance;\n\n    // Use a safer approach to transfer funds, like transfer, which has a fixed gas stipend.\n    // This avoids using call and prevents issues with malicious fallback functions.\n    function claimThrone() external payable {\n        require(msg.value &gt; balance, \"Need to pay more to become the king\");\n\n        address previousKing = king;\n        uint256 previousBalance = balance;\n\n        // Update the state before transferring Ether to prevent reentrancy issues.\n        king = msg.sender;\n        balance = msg.value;\n\n        // Use transfer instead of call to ensure the transaction doesn't fail due to a malicious fallback.\n        payable(previousKing).transfer(previousBalance);\n    }\n}\n</code></pre>","tags":[]},{"location":"sctop10/Top10%3A2023/","title":"Top10:2023","text":"","tags":[]},{"location":"sctop10/Top10%3A2023/#owasp-smart-contract-top-10-2023","title":"OWASP Smart Contract Top 10: 2023","text":"<ul> <li>SC01:2023 - Reentrancy Attacks</li> <li>SC02:2023 - Integer Overflow and Underflow</li> <li>SC03:2023 - Timestamp Dependence</li> <li>SC04:2023 - Access Control Vulnerabilities</li> <li>SC05:2023 - Front-running Attacks</li> <li>SC06:2023 - Denial of Service (DoS) Attacks</li> <li>SC07:2023 - Logic Errors</li> <li>SC08:2023 - Insecure Randomness</li> <li>SC09:2023 - Gas Limit Vulnerabilities</li> <li>SC10:2023 - Unchecked External Calls</li> </ul>","tags":[]}]}